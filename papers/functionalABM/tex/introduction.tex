\chapter{Introduction}

\section{Reasoning}
Allowing to reason about a program is one of the most interesting and powerful features of a Haskell-program. Just by looking at the types one can show that there is no randomness in the simulation \textit{after} the random initialization, which is not slightest possible in the case of a Java, Scala, ReLogo or NetLogo solution. Things we can reason about just by looking at types:

\begin{itemize}
\item Concurrency involved?
\item Randomness involved?
\item IO with the system (e.g. user-input, read/write to file(s),...) involved?
\end{itemize}

This all boils down to the question of whether there are \textit{side-effects} included in the simulation or not.

\subsection{Reasoning about termination}
What about reasoning about the termination? Is this possible in Haskell? Is it possible by types alone? My hypothesis is that the types are an important hint but are not able to give a clear hint about termination and thus we we need a closer look at the implementation. In dependently-typed programming languages like Agda this should be then possible and the program is then also a 
proof that the program itself terminates.

\subsection{Debugging}
Because functions compose easier than classes \& objects (TODO: we need hard claims here, look for literature supporting this thesis or proof it by myself) it is also much easier to debug \textit{parts} of the implementation e.g. the rendering of the agents without any changes to the system as a whole - just the main-loop has do be adopted. Then it is very easy to calculate e.g. only one iteration and to freeze the result or to manually create agents instead of randomly create initial ones.

\section{World}
The coordinates calculated by the agents are \textit{virtual} ones ranging between 0.0 and 1.0. This prevents us from knowing the rendering-resolution and polluting code which has nothing to do with rendering with these implementation-details. Also this simulation could run without rendering-output or any rendering-frontend thus sticking to virtual coordinates is also very useful regarding this (but then again: what is the use of this simulation without any visual output=

\begin{itemize}
\item Clipping: \textit{calculated} coordinates are clipped at 0.0 and 1.0 
\item Wraparound: \textit{calculated} coordinates are wrapped around to 0.0 when reaching 1.0. Will lead pursuing friends to change direction apruptly when wrapping around.
\item Remainder: \textit{calculated} coordinates are never clipped but in rendering only the remainder after the comma is taken. Of course this then always requires a visual output to observe the effects. This will result in an effect like the classic asteroid game where agents their friends but wont change direction when they seem to clamp around like in the wraparound version.
\end{itemize}

\section{Lazy Evaluation}
can run a simulation for a given number of steps but 

\section{Performance}
Java outperforms Haskell implementation easily with 100.000 Agents - at first not surprising because of in-place updates of friend and enemies and no massive copy-overhead as in haskell. But look WHERE exactly we loose / where the hotspots are in both solutions. 1000.000 seems to be too much even for the Java-implementation.

\section{Numerical Stability}
The agents in the Java-implementation collapsed after a given number of iterations into a single point as during normalization of the direction-vector the length was calculated to be 0. This could be possible if agents come close enough to each other e.g. in the border-worldtype it was highly probable after some iterations when enough agents have assembled at the borders whereas in the Wrapping-WorldType it didn't occur in any run done so far. \\
In the case of a 0-length vector a division by 0  resulting in NaN which \textit{spread} through the network of neighbourhood as every agent calculated its new position it got \textit{infected} by the NaN of a neighbour at some point. The solution was to simply return a 0-vector instead of the normalized which resulted in no movement at all for the current iteration step of the agent. 

\section{Visualization}
Render all
Render cowards only
Render heroes only

\section{Emergent patterns in Border-World}
only with 0.1 heroes

Are the patterns visible both with frozen and non-frozen states?

non-frozen: yes
frozen: completely different patterns

hypothesis: patterns depend on iteration-order, what about random-iteration?

BORDER-WORLD
	non-frozen with random agent-traversal: 				linear patterns emerge
	non-frozen with deterministic agent-traversal: 			linear patterns emerge

	frozen with random agent-traversal: 					collapse to ecliptic point-cloud with size depending on number of agents
	frozen with deterministic agent-traversal: 				linear patterns emerge but bit different from non-frozen state
	in both cases seems to have initial "waves"

	hypothesis satisfied: with random-iteration this changes but only in the case of frozen state

WRAPPING-WORLD
	non-frozen with random agent-traversal: 				linear patterns emerge	
	non-frozen with deterministic agent-traversal: 			linear patterns emerge

	frozen with random agent-traversal: 					collapse to ecliptic point-cloud with size depending on number of agents
	frozen with deterministic agent-traversal: 				linear patterns emerge

INFINITE-WRAPPING-WORLD
	non-frozen with random agent-traversal: 				
	non-frozen with deterministic agent-traversal: 			

	frozen with random agent-traversal: 					
	frozen with deterministic agent-traversal: 				