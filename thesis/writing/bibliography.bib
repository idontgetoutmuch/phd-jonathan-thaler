@article{sutter2005free,
  title={The free lunch is over: A fundamental turn toward concurrency in software},
  author={Sutter, Herb},
  journal={Dr. Dobb’s journal},
  volume={30},
  number={3},
  pages={202--210},
  year={2005}
}

@techreport{axelrod_guide_2006,
	type = {Staff {General} {Research} {Papers} {Archive}},
	title = {A {Guide} for {Newcomers} to {Agent}-{Based} {Modeling} in the {Social} {Sciences}},
	url = {http://econpapers.repec.org/paper/isugenres/12515.htm},
	abstract = {This guide provides pointers to introductory readings, software, and other materials to help newcomers become acquainted with agent-based modeling in the social sciences. Related work can be accessed at: http://www2.econ.iastate.edu/tesfatsi/ace.htm},
	urldate = {2017-05-08},
	institution = {Iowa State University, Department of Economics},
	author = {Axelrod, Robert and Tesfatsion, Leigh},
	month = jan,
	year = {2006},
	keywords = {Agent-based modeling, social sciences},
	file = {RePEc Snapshot:/home/jonathan/Zotero/storage/GKPTG7ED/12515.html:text/html}
}

@book{weiss_multiagent_2013,
	title = {Multiagent {Systems}},
	isbn = {978-0-262-01889-0},
	abstract = {Multiagent systems are made up of multiple interacting intelligent agents -- computational entities to some degree autonomous and able to cooperate, compete, communicate, act flexibly, and exercise control over their behavior within the frame of their objectives. They are the enabling technology for a wide range of advanced applications relying on distributed and parallel processing of data, information, and knowledge relevant in domains ranging from industrial manufacturing to e-commerce to health care. This book offers a state-of-the-art introduction to multiagent systems, covering the field in both breadth and depth, and treating both theory and practice. It is suitable for classroom use or independent study. This second edition has been completely revised, capturing the tremendous developments in multiagent systems since the first edition appeared in 1999. Sixteen of the book's seventeen chapters were written for this edition; all chapters are by leaders in the field, with each author contributing to the broad base of knowledge and experience on which the book rests. The book covers basic concepts of computational agency from the perspective of both individual agents and agent organizations; communication among agents; coordination among agents; distributed cognition; development and engineering of multiagent systems; and background knowledge in logics and game theory. Each chapter includes references, many illustrations and examples, and exercises of varying degrees of difficulty. The chapters and the overall book are designed to be self-contained and understandable without additional material. Supplemental resources are available on the book's Web site. Contributors:Rafael Bordini, Felix Brandt, Amit Chopra, Vincent Conitzer, Virginia Dignum, Ju ̈rgen Dix, Ed Durfee, Edith Elkind, Ulle Endriss, Alessandro Farinelli, Shaheen Fatima, Michael Fisher, Nicholas R. Jennings, Kevin Leyton-Brown, Evangelos Markakis, Lin Padgham, Julian Padget, Iyad Rahwan, Talal Rahwan, Alex Rogers, Jordi Sabater-Mir, Yoav Shoham, Munindar P. Singh, Kagan Tumer, Karl Tuyls, Wiebe van der Hoek, Laurent Vercouter, Meritxell Vinyals, Michael Winikoff, Michael Wooldridge, Shlomo Zilberstein},
	language = {en},
	publisher = {MIT Press},
	author = {Weiss, Gerhard},
	month = mar,
	year = {2013},
	note = {Google-Books-ID: WY36AQAAQBAJ},
	keywords = {Computers / Intelligence (AI) \& Semantics, Technology \& Engineering / Robotics}
}

@incollection{epstein_chapter_2006,
	title = {Chapter 34 {Remarks} on the {Foundations} of {Agent}-{Based} {Generative} {Social} {Science}},
	volume = {2},
	url = {http://www.sciencedirect.com/science/article/pii/S1574002105020344},
	abstract = {This chapter treats a variety of epistemological issues surrounding generative explanation in the social sciences, and discusses the role of agent-based computational models in generative social science.},
	urldate = {2017-05-05},
	booktitle = {Handbook of {Computational} {Economics}},
	publisher = {Elsevier},
	author = {Epstein, Joshua M.},
	editor = {Judd, L. Tesfatsion {and} K. L.},
	year = {2006},
	doi = {10.1016/S1574-0021(05)02034-4},
	keywords = {Agent-based modeling, generative social science, philosophy of social science},
	pages = {1585--1604},
	file = {ScienceDirect Full Text PDF:/home/jonathan/Zotero/storage/TA4A87QT/Epstein - 2006 - Chapter 34 Remarks on the Foundations of Agent-Bas.pdf:application/pdf;ScienceDirect Snapshot:/home/jonathan/Zotero/storage/CT5Z2KXD/S1574002105020344.html:text/html}
}

@incollection{axelrod_advancing_1997,
	title = {Advancing the {Art} of {Simulation} in the {Social} {Sciences}},
	url = {https://link.springer.com/chapter/10.1007/978-3-662-03366-1_2},
	abstract = {Advancing the state of the art of simulation in the social sciences requires appreciating the unique value of simulation as a third way of doing science, in contrast to both induction and deduction. This essay offers advice for doing simulation research, focusing on the programming of a simulation model, analyzing the results and sharing the results with others. Replicating other people’s simulations gets special emphasis, with examples of the procedures and difficulties involved in the process of replication. Finally, suggestions are offered for building of a community of social scientists who do simulation.},
	language = {en},
	urldate = {2017-05-05},
	booktitle = {Simulating {Social} {Phenomena}},
	publisher = {Springer, Berlin, Heidelberg},
	author = {Axelrod, Robert},
	year = {1997},
	doi = {10.1007/978-3-662-03366-1_2},
	pages = {21--40},
	file = {Snapshot:/home/jonathan/Zotero/storage/HRJFZEDQ/978-3-662-03366-1_2.html:text/html}
}

@mastersthesis{evensen_extensible_2010,
	address = {Göteborg},
	title = {An {Extensible} and {Scalable} {Agent}-{Based} {Simulation} of {Barter} {Economics}},
	url = {https://gupea.ub.gu.se/handle/2077/22063},
	abstract = {This thesis project studies a simulation of decentralised bilateral exchange economics, in which prices are private information and trading decisions are left to individual agents. We set to re-engineer the model devised by Herbert Gintis and take his Delphi version as the basis for providing a new, portable barter economics simulation tool in Java. By introducing some extension points for new agent and market behaviours, we provide simple means to implement variations on the original model. In particular, our system could be used to study the emergent properties of heterogeneous agent behaviours. Through the addition of some default visualisation models we provide means for an improved intuitive understanding of the interaction between individual agents. The multi-agent simulation library MASON is used as the underlying simulation platform. The results of running the software with various parameters are compared to the results from the original version to confirm the convergence of the two programs.Cover: Relative private price visualisation for bartering agents.},
	school = {Chalmers University of Technology},
	author = {Evensen, Pelle and Märdin, Mait},
	year = {2010}
}

@book{colell_microeconomic_1995,
	title = {Microeconomic {Theory}},
	abstract = {Individual decision making. Game theory. Market equilibrium and market failure. Welfare economics and incentives.},
	language = {en},
	publisher = {Oxford University Press},
	author = {Colell, Andreu Mas},
	year = {1995},
	note = {Google-Books-ID: dFS2AQAACAAJ}
}

@techreport{axelrod_convergence_1995,
	type = {Working {Paper}},
	title = {The {Convergence} and {Stability} of {Cultures}: {Local} {Convergence} and {Global} {Polarization}},
	shorttitle = {The {Convergence} and {Stability} of {Cultures}},
	url = {http://econpapers.repec.org/paper/wopsafiwp/95-03-028.htm},
	urldate = {2017-05-05},
	institution = {Santa Fe Institute},
	author = {Axelrod, Robert},
	month = mar,
	year = {1995},
	file = {RePEc Snapshot:/home/jonathan/Zotero/storage/FDSQ22W8/95-03-028.html:text/html}
}

@article{axtell_aligning_1996,
	title = {Aligning simulation models: {A} case study and results},
	volume = {1},
	issn = {1381-298X, 1572-9346},
	shorttitle = {Aligning simulation models},
	url = {https://link.springer.com/article/10.1007/BF01299065},
	doi = {10.1007/BF01299065},
	abstract = {This paper develops the concepts and methods of a process we will call “alignment of computational models” or “docking” for short. Alignment is needed to determine whether two models can produce the same results, which in turn is the basis for critical experiments and for tests of whether one model can subsume another. We illustrate our concepts and methods using as a target a model of cultural transmission built by Axelrod. For comparison we use the Sugarscape model developed by Epstein and Axtell.The two models differ in many ways and, to date, have been employed with quite different aims. The Axelrod model has been used principally for intensive experimentation with parameter variation, and includes only one mechanism. In contrast, the Sugarscape model has been used primarily to generate rich “artificial histories”, scenarios that display stylized facts of interest, such as cultural differentiation driven by many different mechansims including resource availability, migration, trade, and combat.The Sugarscape model was modified so as to reproduce the results of the Axelrod cultural model. Among the questions we address are: what does it mean for two models to be equivalent, how can different standards of equivalence be statistically evaluated, and how do subtle differences in model design affect the results? After attaining a “docking” of the two models, the richer set of mechanisms of the Sugarscape model is used to provide two experiments in sensitivity analysis for the cultural rule of Axelrod's model.Our generally positive experience in this enterprise has suggested that it could be beneficial if alignment and equivalence testing were more widely practiced among computational modelers.},
	language = {en},
	number = {2},
	urldate = {2017-05-04},
	journal = {Computational \& Mathematical Organization Theory},
	author = {Axtell, Robert and Axelrod, Robert and Epstein, Joshua M. and Cohen, Michael D.},
	month = feb,
	year = {1996},
	pages = {123--141},
	file = {Snapshot:/home/jonathan/Zotero/storage/JKD9FRC5/BF01299065.html:text/html}
}

@book{epstein_generative_2012,
	title = {Generative {Social} {Science}: {Studies} in {Agent}-{Based} {Computational} {Modeling}},
	isbn = {978-1-4008-4287-2},
	shorttitle = {Generative {Social} {Science}},
	abstract = {Agent-based computational modeling is changing the face of social science. In Generative Social Science, Joshua Epstein argues that this powerful, novel technique permits the social sciences to meet a fundamentally new standard of explanation, in which one "grows" the phenomenon of interest in an artificial society of interacting agents: heterogeneous, boundedly rational actors, represented as mathematical or software objects. After elaborating this notion of generative explanation in a pair of overarching foundational chapters, Epstein illustrates it with examples chosen from such far-flung fields as archaeology, civil conflict, the evolution of norms, epidemiology, retirement economics, spatial games, and organizational adaptation. In elegant chapter preludes, he explains how these widely diverse modeling studies support his sweeping case for generative explanation.  This book represents a powerful consolidation of Epstein's interdisciplinary research activities in the decade since the publication of his and Robert Axtell's landmark volume, Growing Artificial Societies. Beautifully illustrated, Generative Social Science includes a CD that contains animated movies of core model runs, and programs allowing users to easily change assumptions and explore models, making it an invaluable text for courses in modeling at all levels.},
	language = {en},
	publisher = {Princeton University Press},
	author = {Epstein, Joshua M.},
	month = jan,
	year = {2012},
	note = {Google-Books-ID: 6jPiuMbKKJ4C},
	keywords = {Business \& Economics / Economics / Theory, Mathematics / Applied, Social Science / Research}
}

@incollection{axelrod_chapter_2006,
	title = {Chapter 33 {Agent}-based {Modeling} as a {Bridge} {Between} {Disciplines}},
	volume = {2},
	url = {http://www.sciencedirect.com/science/article/pii/S1574002105020332},
	abstract = {Using the author's own experiences, this chapter shows how agent-based modeling (ABM) can address research questions common to many disciplines, facilitate interdisciplinary collaboration, provide a useful multidisciplinary tool when the math is intractable, and reveal unity across disciplines. While ABM can be a hard sell, convergence within the agent-based community can enhance the interdisciplinary value of the methodology.},
	urldate = {2017-05-04},
	booktitle = {Handbook of {Computational} {Economics}},
	publisher = {Elsevier},
	author = {Axelrod, Robert},
	editor = {Judd, L. Tesfatsion {and} K. L.},
	year = {2006},
	doi = {10.1016/S1574-0021(05)02033-2},
	keywords = {Agent-based models, evolutionary biology, interdisciplinary research, prisoner's dilemma},
	pages = {1565--1584},
	file = {ScienceDirect Full Text PDF:/home/jonathan/Zotero/storage/J9MT7SBQ/Axelrod - 2006 - Chapter 33 Agent-based Modeling as a Bridge Betwee.pdf:application/pdf;ScienceDirect Snapshot:/home/jonathan/Zotero/storage/99UWITWZ/S1574002105020332.html:text/html}
}

@article{wadler_how_1997,
	title = {How to {Declare} an {Imperative}},
	volume = {29},
	issn = {0360-0300},
	url = {http://doi.acm.org/10.1145/262009.262011},
	doi = {10.1145/262009.262011},
	abstract = {How can we integrate interaction into a purely declarative language? This tutorial describes a solution to this problem based on a monad. The solution has been implemented in the functional language Haskell and the declarative language Escher. Comparisons are given with other approaches to interaction based on synchronous streams, continuations, linear logic, and side effects.},
	number = {3},
	urldate = {2017-04-24},
	journal = {ACM Comput. Surv.},
	author = {Wadler, Philip},
	month = sep,
	year = {1997},
	keywords = {functional programming, Haskell, monad},
	pages = {240--263},
	file = {ACM Full Text PDF:/home/jonathan/Zotero/storage/TQXPH76F/Wadler - 1997 - How to Declare an Imperative.pdf:application/pdf}
}

@article{schelling_dynamic_1971,
	title = {Dynamic models of segregation},
	volume = {1},
	journal = {Journal of Mathematical Sociology},
	author = {Schelling, Thomas},
	year = {1971},
	keywords = {abm, models}
}

@article{hutton_tutorial_1999,
	title = {A {Tutorial} on the {Universality} and {Expressiveness} of {Fold}},
	volume = {9},
	issn = {0956-7968},
	url = {http://dx.doi.org/10.1017/S0956796899003500},
	doi = {10.1017/S0956796899003500},
	abstract = {In functional programming, fold is a standard operator that encapsulates a simple pattern of recursion for processing lists. This article is a tutorial on two key aspects of the fold operator for lists. First of all, we emphasize the use of the universal property of fold both as a proof principle that avoids the need for inductive proofs, and as a definition principle that guides the transformation of recursive functions into definitions using fold. Secondly, we show that even though the pattern of recursion encapsulated by fold is simple, in a language with tuples and functions as first-class values the fold operator has greater expressive power than might first be expected.},
	number = {4},
	urldate = {2017-03-06},
	journal = {J. Funct. Program.},
	author = {Hutton, Graham},
	month = jul,
	year = {1999},
	pages = {355--372}
}

@inproceedings{gilmer_recursive_2000,
	address = {San Diego, CA, USA},
	series = {{WSC} '00},
	title = {Recursive {Simulation} to {Aid} {Models} of {Decision} {Making}},
	isbn = {978-0-7803-6582-7},
	url = {http://dl.acm.org/citation.cfm?id=510378.510515},
	abstract = {Recursive simulation involves a simulation, or an entity in the simulation, creating another instance of the same simulation, running it and using its results. This is particularly applicable to decisionmaking in a military simulation. Simulation can be used by the simulated command elements to evaluate the implications of the possible choices. The simulation that is already running provides a conveniently available evaluation tool if it can be run recursively. This has been done with the "eaglet" simulation, and data collected that indicates that the quality of decisionmaking by the simulated command elements is improved.},
	urldate = {2017-03-06},
	booktitle = {Proceedings of the 32Nd {Conference} on {Winter} {Simulation}},
	publisher = {Society for Computer Simulation International},
	author = {Gilmer, Jr., John B. and Sullivan, Frederick J.},
	year = {2000},
	pages = {958--963},
	file = {ACM Full Text PDF:/home/jonathan/Zotero/storage/2SBWWNJF/Gilmer and Sullivan - 2000 - Recursive Simulation to Aid Models of Decision Mak.pdf:application/pdf}
}

@book{epstein_growing_1996,
	address = {Washington, DC, USA},
	title = {Growing {Artificial} {Societies}: {Social} {Science} from the {Bottom} {Up}},
	isbn = {978-0-262-55025-3},
	shorttitle = {Growing {Artificial} {Societies}},
	publisher = {The Brookings Institution},
	author = {Epstein, Joshua M. and Axtell, Robert},
	year = {1996}
}

@article{steinhart_theological_2010,
	title = {Theological {Implications} of the {Simulation} {Argument}},
	volume = {10},
	abstract = {Nick Bostrom’s Simulation Argument (SA) has many intriguing theological implications. We work out some of them here. We show how the SA can be used to develop novel versions of the Cosmological and Design Arguments. We then develop some of the affinities between Bostrom’s naturalistic theogony and more traditional theological topics. We look at the resurrection of the body and at theodicy. We conclude with some reflections on the relations between the SA and Neoplatonism (friendly) and between the SA and theism (less friendly).},
	journal = {Ars Disputandi: The Online Journal for Philosophy of Religion},
	author = {Steinhart, Eric},
	year = {2010},
	pages = {23--37}
}

@article{bostrom_are_2003,
	title = {Are {We} {Living} in a {Computer} {Simulation}?},
	volume = {53},
	issn = {1467-9213},
	url = {http://dx.doi.org/10.1111/1467-9213.00309},
	doi = {10.1111/1467-9213.00309},
	number = {211},
	journal = {The Philosophical Quarterly},
	author = {Bostrom, Nick},
	year = {2003},
	pages = {243--255}
}

@book{thompson_type_1991,
	address = {Redwood City, CA, USA},
	title = {Type {Theory} and {Functional} {Programming}},
	isbn = {978-0-201-41667-1},
	publisher = {Addison Wesley Longman Publishing Co., Inc.},
	author = {Thompson, Simon},
	year = {1991}
}

@inproceedings{sculthorpe_safe_2009,
	address = {New York, NY, USA},
	series = {{ICFP} '09},
	title = {Safe {Functional} {Reactive} {Programming} {Through} {Dependent} {Types}},
	isbn = {978-1-60558-332-7},
	url = {http://doi.acm.org/10.1145/1596550.1596558},
	doi = {10.1145/1596550.1596558},
	abstract = {Functional Reactive Programming (FRP) is an approach to reactive programming where systems are structured as networks of functions operating on signals. FRP is based on the synchronous data-flow paradigm and supports both continuous-time and discrete-time signals (hybrid systems). What sets FRP apart from most other languages for similar applications is its support for systems with dynamic structure and for higher-order reactive constructs. Statically guaranteeing correctness properties of programs is an attractive proposition. This is true in particular for typical application domains for reactive programming such as embedded systems. To that end, many existing reactive languages have type systems or other static checks that guarantee domain-specific properties, such as feedback loops always being well-formed. However, they are limited in their capabilities to support dynamism and higher-order data-flow compared with FRP. Thus, the onus of ensuring such properties of FRP programs has so far been on the programmer as established static techniques do not suffice. In this paper, we show how dependent types allow this concern to be addressed. We present an implementation of FRP embedded in the dependently-typed language Agda, leveraging the type system of the host language to craft a domain-specific (dependent) type system for FRP. The implementation constitutes a discrete, operational semantics of FRP, and as it passes the Agda type, coverage, and termination checks, we know the operational semantics is total, which means our type system is safe.},
	urldate = {2018-01-15},
	booktitle = {Proceedings of the 14th {ACM} {SIGPLAN} {International} {Conference} on {Functional} {Programming}},
	publisher = {ACM},
	author = {Sculthorpe, Neil and Nilsson, Henrik},
	year = {2009},
	keywords = {functional programming, dependent types, domain-specific languages, DSELS, FRP, reactive programming, synchronous data-flow},
	pages = {23--34},
	file = {ACM Full Text PDF:/home/jonathan/Zotero/storage/UFUQ95EQ/Sculthorpe and Nilsson - 2009 - Safe Functional Reactive Programming Through Depen.pdf:application/pdf}
}

@book{brady_type-driven_2017,
	title = {Type-{Driven} {Development} with {Idris}},
	isbn = {978-1-61729-302-3},
	abstract = {Summary Type-Driven Development with Idris, written by the creator of Idris, teaches you how to improve the performance and accuracy of your programs by taking advantage of a state-of-the-art type system. This book teaches you with Idris, a language designed to support type-driven development. Purchase of the print book includes a free eBook in PDF, Kindle, and ePub formats from Manning Publications. About the Technology Stop fighting type errors! Type-driven development is an approach to coding that embraces types as the foundation of your code - essentially as built-in documentation your compiler can use to check data relationships and other assumptions. With this approach, you can define specifications early in development and write code that's easy to maintain, test, and extend. Idris is a Haskell-like language with first-class, dependent types that's perfect for learning type-driven programming techniques you can apply in any codebase. About the Book Type-Driven Development with Idris teaches you how to improve the performance and accuracy of your code by taking advantage of a state-of-the-art type system. In this book, you'll learn type-driven development of real-world software, as well as how to handle side effects, interaction, state, and concurrency. By the end, you'll be able to develop robust and verified software in Idris and apply type-driven development methods to other languages. What's Inside  Understanding dependent types Types as first-class language constructs Types as a guide to program construction Expressing relationships between data  About the Reader Written for programmers with knowledge of functional programming concepts. About the Author Edwin Brady leads the design and implementation of the Idris language. Table of Contents PART 1 - INTRODUCTION  Overview Getting started with Idris PART 2 - CORE IDRIS  Interactive development with types User-defined data types Interactive programs: input and output processing Programming with first-class types Interfaces: using constrained generic types Equality: expressing relationships between data Predicates: expressing assumptions and contracts in types Views: extending pattern matching  PART 3 - IDRIS AND THE REAL WORLD  Streams and processes: working with infinite data Writing programs with state State machines: verifying protocols in types Dependent state machines: handling feedback and errors Type-safe concurrent programming},
	language = {en},
	publisher = {Manning Publications Company},
	author = {Brady, Edwin},
	year = {2017},
	note = {Google-Books-ID: eWzEjwEACAAJ},
	keywords = {Computers / Software Development \& Engineering / Quality Assurance \& Testing, Computers / Software Development \& Engineering / Systems Analysis \& Design, Computers / Software Development \& Engineering / Tools}
}

@book{program_homotopy_2013,
	address = {Institute for Advanced Study},
	title = {Homotopy {Type} {Theory}: {Univalent} {Foundations} of {Mathematics}},
	publisher = {https://homotopytypetheory.org/book},
	author = {Program, The Univalent Foundations},
	year = {2013}
}

@article{porter_industrial_1962,
	title = {Industrial {Dynamics}. {Jay} {Forrester}. {M}.{I}.{T}. {Press}, {Cambridge}, {Mass}.; {Wiley}, {New} {York}, 1961. xv + 464 pp. {Illus}. \$18},
	volume = {135},
	copyright = {1962 by the American Association for the Advancement of Science},
	issn = {0036-8075, 1095-9203},
	url = {http://science.sciencemag.org/content/135/3502/426.2},
	doi = {10.1126/science.135.3502.426-a},
	language = {en},
	number = {3502},
	urldate = {2017-11-06},
	journal = {Science},
	author = {Porter, Donald E.},
	month = feb,
	year = {1962},
	pages = {426--427},
	file = {Full Text PDF:/home/jonathan/Zotero/storage/CG25GZ44/Porter - 1962 - Industrial Dynamics. Jay Forrester. M.I.T. Press, .pdf:application/pdf;Snapshot:/home/jonathan/Zotero/storage/F7EP3ERV/426.html:text/html}
}

@article{kermack_contribution_1927,
	title = {A {Contribution} to the {Mathematical} {Theory} of {Epidemics}},
	volume = {115},
	issn = {1364-5021, 1471-2946},
	url = {http://rspa.royalsocietypublishing.org/content/115/772/700},
	doi = {10.1098/rspa.1927.0118},
	language = {en},
	number = {772},
	urldate = {2017-11-06},
	journal = {Proceedings of the Royal Society of London A: Mathematical, Physical and Engineering Sciences},
	author = {Kermack, W. O. and McKendrick, A. G.},
	month = aug,
	year = {1927},
	pages = {700--721},
	file = {Full Text PDF:/home/jonathan/Zotero/storage/57XZARXB/Kermack and McKendrick - 1927 - A Contribution to the Mathematical Theory of Epide.pdf:application/pdf;Snapshot:/home/jonathan/Zotero/storage/PLT8SIX5/700.html:text/html}
}

@inproceedings{borshchev_system_2004,
	address = {Oxford},
	title = {From {System} {Dynamics} and {Discrete} {Event} to {Practical} {Agent} {Based} {Modeling}: {Reasons}, {Techniques}, {Tools}},
	abstract = {This paper may be considered as a practical reference for those who wish to add (now sufficiently matured) Agent Based modeling to their analysis toolkit and may or may not have some System Dynamics or Discrete Event modeling background. We focus on systems that contain large numbers of active objects (people, business units, animals, vehicles, or even things like projects, stocks, products, etc. that have timing, event ordering or other kind of individual behavior associated with them). We compare the three major paradigms in simulation modeling: System Dynamics, Discrete Event and Agent Based. Modeling with respect to how they approach such systems. We show in detail how an Agent Based model can be built from an existing System Dynamics or a Discrete Event model and then show how easily it can be further enhanced to capture much more complicated behavior, dependencies and interactions thus providing for deeper insight in the system being modeled. Commonly understood examples are used throughout the paper; all models are specified in the visual language supported by AnyLogicTM tool. We view and present Agent Based modeling not as a substitution to older modeling paradigms but as a useful add-on that can be efficiently combined with System Dynamics and Discrete Event modeling. Several multi-paradigm model architectures are suggested.},
	author = {Borshchev, Andrei and Filippov, Alexei},
	month = jul,
	year = {2004}
}

@inproceedings{macal_agent-based_2010,
	address = {Baltimore, Maryland},
	series = {{WSC} '10},
	title = {To {Agent}-based {Simulation} from {System} {Dynamics}},
	isbn = {978-1-4244-9864-2},
	url = {http://dl.acm.org/citation.cfm?id=2433508.2433551},
	abstract = {Agent-based simulation (ABS) is a recent modeling technique that is being widely used in modeling complex social systems. Forrester's System Dynamics (SD) is another longstanding technique for modeling social systems. Several classical models of systems, such as the Kermack-McKendrick model of epidemiology, the Lotka-Volterra equations for modeling predator-prey relationships, and the Bass model for innovation diffusion are formulated as systems of differential equations and have corresponding System Dynamics representations as difference equations. The ABS and SD modeling approaches take fundamentally different perspectives when modeling a system, which can be characterized as bottom-up (ABS) versus top-down (SD). Yet many systems can be equivalently modeled by either approach. In this paper, we present a formal specification for SD and ABS models, use the specification to derive equivalent ABS representations, and present an example of an SIR epidemic model having SD and ABS counterparts.},
	urldate = {2017-10-05},
	booktitle = {Proceedings of the {Winter} {Simulation} {Conference}},
	publisher = {Winter Simulation Conference},
	author = {Macal, Charles M.},
	year = {2010},
	pages = {371--382},
	file = {ACM Full Text PDF:/home/jonathan/Zotero/storage/7WFBF4UW/Macal - 2010 - To Agent-based Simulation from System Dynamics.pdf:application/pdf}
}

@inproceedings{perez_back_2017,
	address = {New York, NY, USA},
	series = {Haskell 2017},
	title = {Back to the {Future}: {Time} {Travel} in {FRP}},
	isbn = {978-1-4503-5182-9},
	shorttitle = {Back to the {Future}},
	url = {http://doi.acm.org/10.1145/3122955.3122957},
	doi = {10.1145/3122955.3122957},
	abstract = {Functional Reactive Programming (FRP) allows interactive applications to be modelled in a declarative manner using time-varying values. For practical reasons, however, operational constraints are often imposed, such as having a fixed time domain, time always flowing forward, and limiting the exploration of the past.   In this paper we show how these constraints can be overcome, giving local control over the time domain, the direction of time and the sampling step. We study the behaviour of FRP expressions when time flows backwards, and demonstrate how to synchronize subsystems running asynchronously and at different sampling rates. We have verified the practicality of our approach with two non-trivial games in which time control is central to the gameplay.},
	urldate = {2017-10-02},
	booktitle = {Proceedings of the 10th {ACM} {SIGPLAN} {International} {Symposium} on {Haskell}},
	publisher = {ACM},
	author = {Perez, Ivan},
	year = {2017},
	keywords = {Haskell, functional reactive programming, game programming, monadic streams, stream programming, time},
	pages = {105--116},
	file = {ACM Full Text PDF:/home/jonathan/Zotero/storage/P5342SY7/Perez - 2017 - Back to the Future Time Travel in FRP.pdf:application/pdf}
}

@article{perez_testing_2017,
	title = {Testing and {Debugging} {Functional} {Reactive} {Programming}},
	volume = {1},
	issn = {2475-1421},
	url = {http://doi.acm.org/10.1145/3110246},
	doi = {10.1145/3110246},
	abstract = {Many types of interactive applications, including video games, raise particular challenges when it comes to testing and debugging. Reasons include de-facto lack of reproducibility and difficulties of automatically generating suitable test data. This paper demonstrates that certain variants of Functional Reactive Programming (FRP) implemented in pure functional languages can mitigate such difficulties by offering referential transparency at the level of whole programs. This opens up for a multi-pronged approach for assisting with testing and debugging that works across platforms, including assertions based on temporal logic, recording and replaying of runs (also from deployed code), and automated random testing using QuickCheck. The approach has been validated on real, non-trivial games implemented in the FRP system Yampa through a tool providing a convenient Graphical User Interface that allows the execution of the code under scrutiny to be controlled, moving along the execution time line, and pin-pointing of violations of assertions on PCs as well as mobile platforms.},
	number = {ICFP},
	urldate = {2017-10-02},
	journal = {Proc. ACM Program. Lang.},
	author = {Perez, Ivan and Nilsson, Henrik},
	month = aug,
	year = {2017},
	keywords = {temporal logic, game programming, debugging, Functional Reactive Programming, testing},
	pages = {2:1--2:27},
	file = {ACM Full Text PDF:/home/jonathan/Zotero/storage/28LJK5KF/Perez and Nilsson - 2017 - Testing and Debugging Functional Reactive Programm.pdf:application/pdf;ACM Full Text PDF:/home/jonathan/Zotero/storage/FIG5HKWX/Perez and Nilsson - 2017 - Testing and Debugging Functional Reactive Programm.pdf:application/pdf}
}

@book{allen_haskell_2016,
	title = {Haskell {Programming} from {First} {Principles}},
	isbn = {978-1-945388-03-3},
	abstract = {Haskell Programming makes Haskell as clear, painless, and practical as it can be, whether you're a beginner or an experienced hacker. Learning Haskell from the ground up is easier and works better. With our exercise-driven approach, you'll build on previous chapters such that by the time you reach the notorious Monad, it'll seem trivial.},
	language = {en},
	publisher = {Allen and Moronuki Publishing},
	author = {Allen, Christopher and Moronuki, Julie},
	month = jul,
	year = {2016},
	note = {Google-Books-ID: 5FaXDAEACAAJ}
}

@book{maclennan_functional_1990,
	title = {Functional {Programming}: {Practice} and {Theory}},
	isbn = {978-0-201-13744-6},
	shorttitle = {Functional {Programming}},
	abstract = {This book is more than an introduction to programming in functional languages; it introduces functional programming as a new programming paradigm. Its focus is on functional programming methodology--what it is, and how it can be used to good effect. In particular, the book shows how this methodology can be used effectively in deriving, analyzing, and proving the correctness of programs. In as much as this book emphasizes general methodology over any particular language, the author has chosen standard mathematical notation for his examples.},
	language = {en},
	publisher = {Addison-Wesley},
	author = {MacLennan, Bruce J.},
	month = jan,
	year = {1990},
	note = {Google-Books-ID: JqhQAAAAMAAJ},
	keywords = {Computers / Programming / Algorithms, Computers / Programming Languages / General}
}

@inproceedings{paterson_new_2001,
	address = {New York, NY, USA},
	series = {{ICFP} '01},
	title = {A {New} {Notation} for {Arrows}},
	isbn = {978-1-58113-415-5},
	url = {http://doi.acm.org/10.1145/507635.507664},
	doi = {10.1145/507635.507664},
	abstract = {The categorical notion of monad, used by Moggi to structure denotational descriptions, has proved to be a powerful tool for structuring combinator libraries. Moreover, the monadic programming style provides a convenient syntax for many kinds of computation, so that each library defines a new sublanguage. Recently, several workers have proposed a generalization of monads, called variously "arrows" or Freyd-categories. The extra generality promises to increase the power, expressiveness and efficiency of the embedded approach, but does not mesh as well with the native abstraction and application. Definitions are typically given in a point-free style, which is useful for proving general properties, but can be awkward for programming specific instances. In this paper we define a simple extension to the functional language Haskell that makes these new notions of computation more convenient to use. Our language is similar to the monadic style, and has similar reasoning properties. Moreover, it is extensible, in the sense that new combining forms can be defined as expressions in the host language.},
	booktitle = {Proceedings of the {Sixth} {ACM} {SIGPLAN} {International} {Conference} on {Functional} {Programming}},
	publisher = {ACM},
	author = {Paterson, Ross},
	year = {2001},
	pages = {229--240},
	file = {ACM Full Text PDF:/home/jonathan/Zotero/storage/KI4REK3D/Paterson - 2001 - A New Notation for Arrows.pdf:application/pdf}
}

@book{okasaki_purely_1999,
	address = {New York, NY, USA},
	title = {Purely {Functional} {Data} {Structures}},
	isbn = {978-0-521-66350-2},
	abstract = {From the Publisher:Most books on data structures assume an imperative language like C or C++. However, data structures for these languages do not always translate well to functional languages such as Standard ML, Haskell, or Scheme. This book describes data structures from the point of view of functional languages, with examples, and presents design techniques so that programmers can develop their own functional data structures. It includes both classical data structures, such as red-black trees and binomial queues, and a host of new data structures developed exclusively for functional languages. All source code is given in Standard ML and Haskell, and most of the programs can easily be adapted to other functional languages. This handy reference for professional programmers working with functional languages can also be used as a tutorial or for self-study.},
	publisher = {Cambridge University Press},
	author = {Okasaki, Chris},
	year = {1999}
}

@book{popper_logic_2002,
	title = {The {Logic} of {Scientific} {Discovery}},
	isbn = {978-0-415-27844-7},
	abstract = {Described by the philosopher A.J. Ayer as a work of 'great originality and power', this book revolutionized contemporary thinking on science and knowledge. Ideas such as the now legendary doctrine of 'falsificationism' electrified the scientific community, influencing even working scientists, as well as post-war philosophy. This astonishing work ranks alongside The Open Society and Its Enemies as one of Popper's most enduring books and contains insights and arguments that demand to be read to this day.},
	language = {en},
	publisher = {Psychology Press},
	author = {Popper, Karl Raimund},
	year = {2002},
	note = {Google-Books-ID: Yq6xeupNStMC},
	keywords = {Philosophy / Logic, Science / Philosophy \& Social Aspects}
}

@article{focardi_is_2015,
	title = {Is economics an empirical science? {If} not, can it become one?},
	volume = {1},
	issn = {2297-4687},
	url = {http://journal.frontiersin.org/article/10.3389/fams.2015.00007},
	doi = {10.3389/fams.2015.00007},
	abstract = {Today’s mainstream economics, embodied in Dynamic Stochastic General Equilibrium (DSGE) models, cannot be considered an empirical science in the modern sense of the term: it is not based on empirical data, is not descriptive of the real-world economy, and has little forecasting power. In this paper, I begin with a review of the weaknesses of neoclassical economic theory and argue for a truly scientific theory based on data, the sine qua non of bringing economics into the realm of an empirical science. But I suggest that, before embarking on this endeavor, we first need to analyze the epistemological problems of economics to understand what research questions we can reasonably ask our theory to address.. I then discuss new approaches which hold the promise of bringing economics closer to being an empirical science. Among the approaches discussed are the study of economies as complex systems, econometrics and econophysics, artificial economics made up of multiple interacting agents as well as attempts being made inside present main stream theory to more closely align the theory with the real world},
	journal = {Frontiers in Applied Mathematics and Statistics},
	author = {Focardi, Sergio},
	year = {2015},
	pages = {7}
}

@incollection{balci_verification_1998,
	title = {Verification, {Validation}, and {Testing}},
	copyright = {Copyright © 1998 John Wiley \& Sons, Inc.},
	isbn = {978-0-470-17244-5},
	url = {http://onlinelibrary.wiley.com/doi/10.1002/9780470172445.ch10/summary},
	abstract = {This chapter contains sections titled:


*
Introduction


*
Life Cycle and a Case Study


*
Verification, Validation, and Testing Principles


*
Verification, Validation, and Testing Techniques


*
Credibility Assessment Stages


*
Concluding Remarks


*
References},
	language = {en},
	urldate = {2017-05-18},
	booktitle = {Handbook of {Simulation}},
	publisher = {John Wiley \& Sons, Inc.},
	author = {Balci, Osman},
	editor = {Banks, Jerry},
	year = {1998},
	doi = {10.1002/9780470172445.ch10},
	keywords = {counterintuitive behavior, military combat systems validation, response-surface methodologies, simulation language compiler, trace-driven simulation methods},
	pages = {335--393},
	file = {Snapshot:/home/jonathan/Zotero/storage/B8BT8SA3/summary.html:text/html}
}

@article{jennings_agent-based_2000,
	title = {On {Agent}-based {Software} {Engineering}},
	volume = {117},
	issn = {0004-3702},
	url = {http://dx.doi.org/10.1016/S0004-3702(99)00107-1},
	doi = {10.1016/S0004-3702(99)00107-1},
	number = {2},
	urldate = {2017-05-18},
	journal = {Artif. Intell.},
	author = {Jennings, Nicholas R.},
	month = mar,
	year = {2000},
	keywords = {agent interactions, agent-based computing, multi-agent systems, social level, Software Engineering},
	pages = {277--296}
}

@book{zeigler_theory_2000,
	title = {Theory of {Modeling} and {Simulation}: {Integrating} {Discrete} {Event} and {Continuous} {Complex} {Dynamic} {Systems}},
	isbn = {978-0-12-778455-7},
	shorttitle = {Theory of {Modeling} and {Simulation}},
	abstract = {The increased computational power and software tools available to engineers have increased the use and dependence on modeling and computer simulation throughout the design process. These tools have given engineers the capability of designing highly complex systems and computer architectures that were previously unthinkable. Every complex design project, from integrated circuits, to aerospace vehicles, to industrial manufacturing processes requires these new methods. This book fulfills the essential need of system and control engineers at all levels in understanding modeling and simulation. This book, written as a true text/reference has become a standard sr./graduate level course in all EE departments worldwide and all professionals in this area are required to update their skills.  The book provides a rigorous mathematical foundation for modeling and computer simulation. It provides a comprehensive framework for modeling and simulation integrating the various simulation approaches. It covers model formulation, simulation model execution, and the model building process with its key activities model abstraction and model simplification, as well as the organization of model libraries. Emphasis of the book is in particular in integrating discrete event and continuous modeling approaches as well as a new approach for discrete event simulation of continuous processes. The book also discusses simulation execution on parallel and distributed machines and concepts for simulation model realization based on the High Level Architecture (HLA) standard of the Department of Defense.    Presents a working foundation necessary for compliance with High Level Architecture (HLA) standards Provides a comprehensive framework for continuous and discrete event modeling and simulation Explores the mathematical foundation of simulation modeling Discusses system morphisms for model abstraction and simplification Presents a new approach to discrete event simulation of continuous processes Includes parallel and distributed simulation of discrete event models Presents a concept to achieve simulator interoperability in the form of the DEVS-Bus},
	language = {en},
	publisher = {Academic Press},
	author = {Zeigler, Bernard P. and Praehofer, Herbert and Kim, Tag Gon},
	month = jan,
	year = {2000},
	note = {Google-Books-ID: REzmYOQmHuQC},
	keywords = {Technology \& Engineering / Engineering (General), Computers / Computer Engineering}
}

@article{galan_errors_2009,
	title = {Errors and {Artefacts} in {Agent}-{Based} {Modelling}},
	volume = {12},
	issn = {1460-7425},
	url = {http://jasss.soc.surrey.ac.uk/12/1/1.html},
	abstract = {The objectives of this paper are to define and classify different types of errors and artefacts that can appear in the process of developing an agent-based model, and to propose activities aimed at avoiding them during the model construction and testing phases. To do this in a structured way, we review the main concepts of the process of developing such a model – establishing a general framework that summarises the process of designing, implementing, and using agent-based models. Within this framework we identify the various stages where different types of errors and artefacts may appear. Finally we propose activities that could be used to detect (and hence eliminate) each type of error or artefact.},
	number = {1},
	journal = {Journal of Artificial Societies and Social Simulation},
	author = {Galán, José Manuel and Izquierdo, Luis R. and Izquierdo, Segismundo S. and Santos, José Ignacio and del Olmo, Ricardo and López-Paredes, Adolfo and Edmonds, Bruce},
	year = {2009},
	keywords = {Replication, Verification, Agent-Based Modelling, Artefact, Error, Modelling Roles},
	pages = {1}
}

@techreport{tesfatsion_agent-based_2017,
	title = {Agent-based  {Computational} {Economics} ({ACE}) - {Growing} {Economies} from the {Bottom} {Up}},
	url = {http://www2.econ.iastate.edu/tesfatsi/ace.htm},
	author = {Tesfatsion, Leigh},
	month = may,
	year = {2017}
}

@techreport{wilhite_economic_2006,
	type = {Handbook of {Computational} {Economics}},
	title = {Economic {Activity} on {Fixed} {Networks}},
	url = {http://econpapers.repec.org/bookchap/eeehecchp/2-20.htm},
	abstract = {A large portion of our economic interactions involves a very small portion of the population. We seem to prefer familiar venues. But the tendency to focus our attention on a few individuals or activities is an attribute that is typically omitted in our characterization of markets. In markets agents seem to interact impersonally and efficiently with countless other faceless agents. This chapter looks into the consequences of including a connection between agents, a tendency to interact with a specific few, in economic decision making. Agents are assumed to occupy the nodes of a network and to interact exclusively with agents to whom they are directly linked. We then study evolution of game strategies and the effectiveness of exchange as the topology of the underlying network is altered. We find that networks matter, that changes in a network's structure can alter the steady-state attributes of an artificial society as well as the dynamics of that system.},
	urldate = {2017-05-15},
	institution = {Elsevier},
	author = {Wilhite, Allen},
	year = {2006},
	pages = {1013--1045},
	file = {RePEc Snapshot:/home/jonathan/Zotero/storage/FBF8WSEF/2-20.html:text/html}
}

@book{easley_networks_2010,
	title = {Networks, {Crowds}, and {Markets}: {Reasoning} {About} a {Highly} {Connected} {World}},
	isbn = {978-0-521-19533-1},
	shorttitle = {Networks, {Crowds}, and {Markets}},
	abstract = {Over the past decade there has been a growing public fascination with the complex connectedness of modern society. This connectedness is found in many incarnations: in the rapid growth of the Internet, in the ease with which global communication takes place, and in the ability of news and information as well as epidemics and financial crises to spread with surprising speed and intensity. These are phenomena that involve networks, incentives, and the aggregate behavior of groups of people; they are based on the links that connect us and the ways in which our decisions can have subtle consequences for others. This introductory undergraduate textbook takes an interdisciplinary look at economics, sociology, computing and information science, and applied mathematics to understand networks and behavior. It describes the emerging field of study that is growing at the interface of these areas, addressing fundamental questions about how the social, economic, and technological worlds are connected.},
	language = {en},
	publisher = {Cambridge University Press},
	author = {Easley, David and Kleinberg, Jon},
	month = jul,
	year = {2010},
	note = {Google-Books-ID: 8xf1nAEACAAJ},
	keywords = {Computers / Programming / Algorithms, Business \& Economics / Consumer Behavior, Business \& Economics / E-Commerce / General, Computers / Networking / General, Computers / Web / General, Social Science / Sociology / General}
}

@book{jackson_social_2008,
	title = {Social and {Economic} {Networks}},
	isbn = {978-0-691-13440-6},
	abstract = {Networks of relationships help determine the careers that people choose, the jobs they obtain, the products they buy, and how they vote. The many aspects of our lives that are governed by social networks make it critical to understand how they impact behavior, which network structures are likely to emerge in a society, and why we organize ourselves as we do. In Social and Economic Networks, Matthew Jackson offers a comprehensive introduction to social and economic networks, drawing on the latest findings in economics, sociology, computer science, physics, and mathematics. He provides empirical background on networks and the regularities that they exhibit, and discusses random graph-based models and strategic models of network formation. He helps readers to understand behavior in networked societies, with a detailed analysis of learning and diffusion in networks, decision making by individuals who are influenced by their social neighbors, game theory and markets on networks, and a host of related subjects. Jackson also describes the varied statistical and modeling techniques used to analyze social networks. Each chapter includes exercises to aid students in their analysis of how networks function.  This book is an indispensable resource for students and researchers in economics, mathematics, physics, sociology, and business.},
	language = {en},
	publisher = {Princeton University Press},
	author = {Jackson, Matthew O.},
	year = {2008},
	note = {Google-Books-ID: IpA9LwEACAAJ},
	keywords = {Social Science / Sociology / General, Business \& Economics / Economics / Microeconomics, Mathematics / Group Theory}
}

@article{blume_introduction_2015,
	series = {Computer {Science} and {Economic} {Theory}},
	title = {Introduction to computer science and economic theory},
	volume = {156},
	issn = {0022-0531},
	url = {http://www.sciencedirect.com/science/article/pii/S0022053114001616},
	doi = {10.1016/j.jet.2014.11.002},
	abstract = {This essay introduces the symposium on computer science and economic theory.},
	urldate = {2016-12-12},
	journal = {Journal of Economic Theory},
	author = {Blume, Lawrence and Easley, David and Kleinberg, Jon and Kleinberg, Robert and Tardos, Eva},
	month = mar,
	year = {2015},
	keywords = {Mechanism design, Algorithmic game theory, Implementation, Learning in games, Networks},
	pages = {1--13},
	file = {ScienceDirect Full Text PDF:/home/jonathan/Zotero/storage/RFPQJ7KX/Blume et al. - 2015 - Introduction to computer science and economic theo.pdf:application/pdf;ScienceDirect Full Text PDF:/home/jonathan/Zotero/storage/H3EK4XCX/Blume et al. - 2015 - Introduction to computer science and economic theo.pdf:application/pdf;ScienceDirect Snapshot:/home/jonathan/Zotero/storage/VBRAMU28/S0022053114001616.html:text/html;ScienceDirect Snapshot:/home/jonathan/Zotero/storage/JS2CWSZB/S0022053114001616.html:text/html}
}

@article{hughes_why_1989,
	title = {Why {Functional} {Programming} {Matters}},
	volume = {32},
	issn = {0010-4620},
	url = {http://dx.doi.org/10.1093/comjnl/32.2.98},
	doi = {10.1093/comjnl/32.2.98},
	number = {2},
	urldate = {2016-11-11},
	journal = {Comput. J.},
	author = {Hughes, J.},
	month = apr,
	year = {1989},
	pages = {98--107}
}

@incollection{hewitt_what_2007,
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {What {Is} {Commitment}? {Physical}, {Organizational}, and {Social} ({Revised})},
	copyright = {©2007 Springer-Verlag Berlin Heidelberg},
	isbn = {978-3-540-74457-3 978-3-540-74459-7},
	shorttitle = {What {Is} {Commitment}?},
	url = {http://link.springer.com/chapter/10.1007/978-3-540-74459-7_19},
	abstract = {This paper uses Participatory Semantics to explicate commitment. Information expresses the fact that a system is in a certain configuration that is correlated to the configuration of another system. Any physical system may contain information about another physical system. For the purposes of this paper, physical commitment is defined to be information pledgedabout physical systems (situated at a particular place and time). This use of the term physical commitment is currently nonstandard. Note that commitment is defined for whole physical system; not just a participant or process. Organizational and social commitments can be analyzed in terms of physical commitments. For example systems that behave as scientific communities can have commitments for monotonicity, concurrency, commutativity, pluralism, skepticism, and provenance. Speech Act Theory has attempted to formalize the semantics of some kinds of expressions for commitments. Participatory Semantics for commitment can overcome some of the lack of expressiveness and generality in Speech Act Theory.},
	language = {en},
	number = {4386},
	urldate = {2016-10-26},
	booktitle = {Coordination, {Organizations}, {Institutions}, and {Norms} in {Agent} {Systems} {II}},
	publisher = {Springer Berlin Heidelberg},
	author = {Hewitt, Carl},
	editor = {Noriega, Pablo and Vázquez-Salceda, Javier and Boella, Guido and Boissier, Olivier and Dignum, Virginia and Fornara, Nicoletta and Matson, Eric},
	year = {2007},
	doi = {10.1007/978-3-540-74459-7_19},
	keywords = {Software Engineering, Artificial Intelligence (incl. Robotics), Computer Communication Networks, Logics and Meanings of Programs, Programming Techniques, Software Engineering/Programming and Operating Systems},
	pages = {293--307},
	annote = {DOI: 10.1007/978-3-540-74459-7\_19},
	file = {Full Text PDF:/home/jonathan/Zotero/storage/6QVEJKUN/Hewitt - 2007 - What Is Commitment Physical, Organizational, and .pdf:application/pdf;Full Text PDF:/home/jonathan/Zotero/storage/WW478ECG/Hewitt - 2007 - What Is Commitment Physical, Organizational, and .pdf:application/pdf;Snapshot:/home/jonathan/Zotero/storage/FWUQ8MR7/10.html:text/html;Snapshot:/home/jonathan/Zotero/storage/BXQAFWI9/10.html:text/html}
}

@inproceedings{di_stefano_using_2005,
	address = {Washington, DC, USA},
	series = {{IAT} '05},
	title = {Using the {Erlang} {Language} for {Multi}-{Agent} {Systems} {Implementation}},
	isbn = {978-0-7695-2416-0},
	url = {http://dx.doi.org/10.1109/IAT.2005.141},
	doi = {10.1109/IAT.2005.141},
	abstract = {Even if Java is widely used for agent development, some agent platforms employ ad-hoc programming languages, so the question that arises is: Is there a language that fits the model of an autonomous software agent better than Java? This paper deals with such an issue by deriving an abstract model for agents and proposing some parameters to evaluate programming languages for agent development. As a result, the paper introduces Erlang, a functional language that presents some interesting characteristics for the engineering of agent-based applications. An Erlang-based platform, called eXAT and developed by the authors, is then presented. Finally, a comparison with a Java-based approach explains why, in the authorsý opinion, this language cannot be considered a good choice for the implementation of agent systems.},
	urldate = {2016-10-31},
	booktitle = {Proceedings of the {IEEE}/{WIC}/{ACM} {International} {Conference} on {Intelligent} {Agent} {Technology}},
	publisher = {IEEE Computer Society},
	author = {Di Stefano, Antonella and Santoro, Corrado},
	year = {2005},
	pages = {679--685}
}

@book{bowles_understanding_2005,
	address = {New York},
	edition = {3 edition},
	title = {Understanding {Capitalism}: {Competition}, {Command}, and {Change}},
	isbn = {978-0-19-513865-8},
	shorttitle = {Understanding {Capitalism}},
	abstract = {Understanding Capitalism: Competition, Command, and Change, Third Edition, is an introduction to economics that explains how capitalism works, why it sometimes does not work as well as we would like it to, and how over time it not only changes but also revolutionizes the world around us. The "three-dimensional approach" of the text focuses on competition in markets; command in firms, governments, and international relations; and change as a permanent feature of a capitalist economy driven by technical innovation and conflict over the distribution of income.The book covers the standard topics of supply and demand, market competition, imperfect competition, aggregate demand, inflation, and unemployment. It emphasizes the extraordinary dynamism and material productivity of the capitalist economy; the psychological foundations of human behavior; the logic and limitations of Adam Smith's invisible hand; technical change and the new information-based economy; global economic integration and its impact on national economies; the impact of economic activity on the environment; and inequality both within and among nations. In addition, it provides a critical evaluation of the tenets of neoclassical economics, a clear introduction to contract theory, and material drawn from new research in behavioral, institutional, and information economics.Understanding Capitalism, Third Edition, is ideal for undergraduate courses in economics and political economy. An Instructor's Manual is available to adopters.FEATURES OF THE THIRD EDITION·Offers a new chapter on the behavioral foundations of economics, showing that the selfishness of the "economic man" leaves out the important role of other social motives and how individual tastes and values evolve in response to experiences·Includes a new chapter that examines how economic success (and poverty) are passed on from parents to children and also looks at the increasing inequality of income and wealth along lines of race and gender·Presents a completely revised and expanded treatment of the revolutionary changes that have been associated with capitalism over the past three centuries·Provides boxed treatments of issues that can serve as the basis of classroom discussions·Defines important terms in the margins throughout the text·Contains a section entitled "Sources of Economic Information" that helps readers locate relevant outside data, both in print and online},
	language = {English},
	publisher = {Oxford University Press},
	author = {Bowles, Samuel and Edwards, Richard and Roosevelt, Frank},
	month = mar,
	year = {2005}
}

@inproceedings{schneider_towards_2012,
	address = {New York, NY, USA},
	series = {{IHI} '12},
	title = {Towards {Frabjous}: {A} {Two}-level {System} for {Functional} {Reactive} {Agent}-based {Epidemic} {Simulation}},
	isbn = {978-1-4503-0781-9},
	shorttitle = {Towards {Frabjous}},
	url = {http://doi.acm.org/10.1145/2110363.2110458},
	doi = {10.1145/2110363.2110458},
	abstract = {Agent-based infection-transmission models, which simulate an infection moving through a population, are being employed more frequently by health policy-makers. However, these models present several obstacles to widespread adoption. They are complex entities and impose a high development and maintenance cost. Current tools can be opaque, requiring multidisciplinary collaboration between a modeler and an expert programmer, and another round of translation when communicating with domain experts. In this paper, we describe the use of functional reactive programming (FRP), a programming paradigm created by imbuing a functional programming language with an intrinsic sense of time, to represent agent-based models in a concise and transparent way. We document the conversion of several agent-based models developed in the popular hybrid modeling tool AnyLogic to a representation in FRP. We also introduce Frabjous, a programming framework and domain-specific language for computational modeling. Frabjous generates human-readable and modifiable FRP code from a model specification, allowing modelers to have two transparent representations in which to program: a high-level model specification, and a full functional programming language with an agent-based modeling framework.},
	urldate = {2016-10-31},
	booktitle = {Proceedings of the 2Nd {ACM} {SIGHIT} {International} {Health} {Informatics} {Symposium}},
	publisher = {ACM},
	author = {Schneider, Oliver and Dutchyn, Christopher and Osgood, Nathaniel},
	year = {2012},
	keywords = {agent-based simulation, simulation, functional programming, agent- based modeling, domain-specific language, dynamic model, functional reactive},
	pages = {785--790},
	file = {ACM Full Text PDF:/home/jonathan/Zotero/storage/UWGCNZ3M/Schneider et al. - 2012 - Towards Frabjous A Two-level System for Functiona.pdf:application/pdf;ACM Full Text PDF:/home/jonathan/Zotero/storage/JVIFRA7J/Schneider et al. - 2012 - Towards Frabjous A Two-level System for Functiona.pdf:application/pdf}
}

@techreport{botta_time_2010,
	type = {Documents de travail du {Centre} d'{Economie} de la {Sorbonne}},
	title = {Time in discrete agent-based models of socio-economic systems},
	url = {https://ideas.repec.org/p/mse/cesdoc/10076.html},
	abstract = {We formulate the problem of computing time in discrete dynamical agent-based models in the context of socio-economic modeling. For such formulation, we outline a simple solution. This requires minimal extensions of the original untimed model. The proposed solution relies on the notion of agent-specific schedules of action and on two modeling assumptions. These are fulfilled by most models of pratical interest. For models for which stronger assumptions can be made, we discuss alternative formulations},
	number = {10076},
	urldate = {2017-01-18},
	institution = {Université Panthéon-Sorbonne (Paris 1), Centre d'Economie de la Sorbonne},
	author = {Botta, Nicola and Mandel, Antoine and Ionescu, Cezar},
	year = {2010},
	keywords = {Agent-based models, time},
	file = {RePEc Snapshot:/home/jonathan/Zotero/storage/3IPCNES2/10076.html:text/html;RePEc Snapshot:/home/jonathan/Zotero/storage/7HI553S6/10076.html:text/html}
}

@inproceedings{courtney_yampa_2003,
	address = {New York, NY, USA},
	series = {Haskell '03},
	title = {The {Yampa} {Arcade}},
	isbn = {978-1-58113-758-3},
	url = {http://doi.acm.org/10.1145/871895.871897},
	doi = {10.1145/871895.871897},
	abstract = {Simulated worlds are a common (and highly lucrative) application domain that stretches from detailed simulation of physical systems to elaborate video game fantasies. We believe that Functional Reactive Programming (FRP) provides just the right level of functionality to develop simulated worlds in a concise, clear and modular way. We demonstrate the use of FRP in this domain by presenting an implementation of the classic "Space Invaders" game in Yampa, our most recent Haskell-embedded incarnation of FRP.},
	urldate = {2016-11-04},
	booktitle = {Proceedings of the 2003 {ACM} {SIGPLAN} {Workshop} on {Haskell}},
	publisher = {ACM},
	author = {Courtney, Antony and Nilsson, Henrik and Peterson, John},
	year = {2003},
	keywords = {functional programming, Haskell, FRP, hybrid modeling, modeling languages, synchronous dataflow languages},
	pages = {7--18},
	file = {ACM Full Text PDF:/home/jonathan/Zotero/storage/QHA4MHSZ/Courtney et al. - 2003 - The Yampa Arcade.pdf:application/pdf;ACM Full Text PDF:/home/jonathan/Zotero/storage/BSF62EH9/Courtney et al. - 2003 - The Yampa Arcade.pdf:application/pdf}
}

@inproceedings{sweeney_next_2006,
	address = {New York, NY, USA},
	series = {{POPL} '06},
	title = {The {Next} {Mainstream} {Programming} {Language}: {A} {Game} {Developer}'s {Perspective}},
	isbn = {978-1-59593-027-9},
	shorttitle = {The {Next} {Mainstream} {Programming} {Language}},
	url = {http://doi.acm.org/10.1145/1111037.1111061},
	doi = {10.1145/1111037.1111061},
	abstract = {Game developers have long been early adopters of new technologies. This is so because we are largely unburdened by legacy code: With each new hardware generation, we are free to rethink our software assumptions and develop new products using new tools and even new programming languages. As a result, games are fertile ground for applying academic advances in these areas.And never has our industry been in need of such advances as it is now! The scale and scope of game development has increased more than ten-fold over the past ten years, yet the underlying limitations of the mainstream C/C++/Java/C\# language family remain largely unaddressed.The talk begins with a high-level presentation of the game developer's world: the kinds of algorithms we employ on modern CPUs and GPUs, the difficulties of componentization and concurrency, and the challenges of writing very complex software with real-time performance requirements.The talk then outlines the ways that future programming languages could help us write better code, providing examples derived from experience writing games and software frameworks that support games. The major areas covered are abstraction facilities -- how we can use them to develop more extensible frameworks and components; practical opportunities for employing stronger typing to reduce run-time failures; and the need for pervasive concurrency support, both implicit and explicit, to effectively exploit the several forms of parallelism present in games and graphics.},
	urldate = {2016-11-11},
	booktitle = {Conference {Record} of the 33rd {ACM} {SIGPLAN}-{SIGACT} {Symposium} on {Principles} of {Programming} {Languages}},
	publisher = {ACM},
	author = {Sweeney, Tim},
	year = {2006},
	pages = {269--269},
	file = {ACM Full Text PDF:/home/jonathan/Zotero/storage/BA9QE54A/Sweeney - 2006 - The Next Mainstream Programming Language A Game D.pdf:application/pdf;ACM Full Text PDF:/home/jonathan/Zotero/storage/P7VUC96F/Sweeney - 2006 - The Next Mainstream Programming Language A Game D.pdf:application/pdf}
}

@article{gintis_emergence_2006,
	title = {The {Emergence} of a {Price} {System} from {Decentralized} {Bilateral} {Exchange}},
	volume = {6},
	issn = {1534-5971},
	url = {https://www.degruyter.com/view/j/bejte.2006.6.1/bejte.2006.6.1.1302/bejte.2006.6.1.1302.xml},
	doi = {10.2202/1534-5971.1302},
	abstract = {This paper analyzes the dynamics of completely decentralized bilateral exchange. In such a framework, neither money nor prices as public information exist. Rather, prices represent an agent's barter strategy, and hence are private information. We call these private prices. Agents formulate trade offers and accept or reject offers from other traders, on the basis of their private prices. Private prices are updated by low-scoring agents periodically imitating the strategies of higher-scoring agents. We show that a system of quasi-public prices emerges in the medium run, and these quasi-public prices converge to stationary distributions that are approximately competitive equilibria of the underlying Walrasian model in the long run. We thus provide, for the first time, a general, decentralized disequilibrium adjustment mechanism that renders market equilibrium dynamically stable in a highly simplified production and exchange economy.},
	number = {1},
	urldate = {2016-09-30},
	journal = {Contributions in Theoretical Economics},
	author = {Gintis, Herbert},
	year = {2006},
	pages = {1--15}
}

@techreport{de_jong_suitability_2014,
	title = {Suitability of {Haskell} for {Multi}-{Agent} {Systems}},
	institution = {University of Twente},
	author = {De Jong, Tanja},
	year = {2014}
}

@techreport{sulzmann_specifying_2007,
	title = {Specifying and {Controlling} {Agents} in {Haskell}},
	author = {Sulzmann, Martin and Lam, Edmund},
	year = {2007}
}

@techreport{grief_semantics_1975,
	address = {Cambridge, MA, USA},
	title = {{SEMANTICS} {OF} {COMMUNICATING} {PARALLEL} {PROCESSES}},
	abstract = {The thesis of this dissertation is that an understanding of the ordering constraints that are introduced among events of parallel process is essential to the understanding of synchronization and that therefore any language for specifying synchronization of parallel process should be based on a theory of such orderings. While it is possible to write specifications for systems of communicating parallel processes by reference to the time ordering of some global clock external to the system, such specifications cannot be as useful as ones which are in terms of orderings derivable within the system. Specifications should place constraints on intended behavior of the computer system itself rather than on the possible observations of the system''s behaviors from some global viewpoint which may in fact be totally unrealizable. The dissertation is a development of a specification language. It is based on a model of computation in which an individual process is represented by a totally ordered set of events. Synchronization properties of systems of independent processes are guarantees that in fact the set of events in the system can be ordered by a partial order which properly contains the union of the processes'' total orders. This system ordering can be caused by the presence in a system of side-effect primitives or of synchronization primitives. Thus this model applies equally well both to busy waiting synchronization based on coordinated use of storage cells by independent processes and to non-busy waiting synchronization such as that induced by semaphores and structured synchronization primitives. In addition to applying to a range of types of synchronization, the specification language is also used to define a programming language. The meaning of a program is the specification of the behavior of the system into which that program is compiled. Specifications can be written for synchronization problems and for their implementations in terms of various primitives.},
	institution = {Massachusetts Institute of Technology},
	author = {Grief, I. and Greif, Irene},
	year = {1975}
}

@inproceedings{hughes_programming_2005,
	address = {Berlin, Heidelberg},
	series = {{AFP}'04},
	title = {Programming with {Arrows}},
	isbn = {978-3-540-28540-3},
	url = {http://dx.doi.org/10.1007/11546382_2},
	doi = {10.1007/11546382_2},
	abstract = {Consider this simple Haskell definition, of a function which counts the number of occurrences of a given word w in a string: count w = length . filter (==w) . words This is an example of “point-free” programming style, where we build a function by composing others, and make heavy use of higher-order functions such as filter. Point-free programming is rightly popular: used appropriately, it makes for concise and readable definitions, which are well suited to equational reasoning in the style of Bird and Meertens [2]. It’s also a natural way to assemble programs from components, and closely related to connecting programs via pipes in the UNIX shell.},
	urldate = {2016-11-04},
	booktitle = {Proceedings of the 5th {International} {Conference} on {Advanced} {Functional} {Programming}},
	publisher = {Springer-Verlag},
	author = {Hughes, John},
	year = {2005},
	pages = {73--129}
}

@inproceedings{varela_modelling_2004,
	address = {New York, NY, USA},
	series = {{ERLANG} '04},
	title = {On {Modelling} {Agent} {Systems} with {Erlang}},
	isbn = {978-1-58113-918-1},
	url = {http://doi.acm.org/10.1145/1022471.1022481},
	doi = {10.1145/1022471.1022481},
	abstract = {Multi-agent systems are a kind of concurrent distributed systems. In this work, some guidelines on how to create multi-agent systems using Erlang are presented. The modelled system supports cooperation among agents by plan exchange, reconfiguration and has a certain fault-tolerance. The distributed and concurrent functional programming Erlang, together with OTP platform, allows the creation of high-availability and fault-tolerant concurrent and distributed systems, and it seems to be an interesting framework for implementing multi-agent systems.},
	urldate = {2016-10-31},
	booktitle = {Proceedings of the 2004 {ACM} {SIGPLAN} {Workshop} on {Erlang}},
	publisher = {ACM},
	author = {Varela, Carlos and Abalde, Carlos and Castro, Laura and Gulías, Jose},
	year = {2004},
	keywords = {functional programming, multi-agent systems, distributed systems},
	pages = {65--70},
	file = {ACM Full Text PDF:/home/jonathan/Zotero/storage/VJ6K5HSU/Varela et al. - 2004 - On Modelling Agent Systems with Erlang.pdf:application/pdf;ACM Full Text PDF:/home/jonathan/Zotero/storage/WFAZNWNA/Varela et al. - 2004 - On Modelling Agent Systems with Erlang.pdf:application/pdf}
}

@inproceedings{wadler_monads_1995,
	address = {London, UK, UK},
	title = {Monads for {Functional} {Programming}},
	isbn = {978-3-540-59451-2},
	url = {http://dl.acm.org/citation.cfm?id=647698.734146},
	urldate = {2016-11-16},
	booktitle = {Advanced {Functional} {Programming}, {First} {International} {Spring} {School} on {Advanced} {Functional} {Programming} {Techniques}-{Tutorial} {Text}},
	publisher = {Springer-Verlag},
	author = {Wadler, Philip},
	year = {1995},
	pages = {24--52}
}

@article{hughes_generalising_2000,
	title = {Generalising {Monads} to {Arrows}},
	volume = {37},
	issn = {0167-6423},
	url = {http://dx.doi.org/10.1016/S0167-6423(99)00023-4},
	doi = {10.1016/S0167-6423(99)00023-4},
	number = {1-3},
	urldate = {2016-11-16},
	journal = {Sci. Comput. Program.},
	author = {Hughes, John},
	month = may,
	year = {2000},
	pages = {67--111}
}

@inproceedings{nilsson_functional_2002,
	address = {New York, NY, USA},
	series = {Haskell '02},
	title = {Functional {Reactive} {Programming}, {Continued}},
	isbn = {978-1-58113-605-0},
	url = {http://doi.acm.org/10.1145/581690.581695},
	doi = {10.1145/581690.581695},
	abstract = {Functional Reactive Programming (FRP) extends a host programming language with a notion of time flow. Arrowized FRP (AFRP) is a version of FRP embedded in Haskell based on the arrow combinators. AFRP is a powerful synchronous dataflow programming language with hybrid modeling capabilities, combining advanced synchronous dataflow features with the higher-order lazy functional abstractions of Haskell. In this paper, we describe the AFRP programming style and our Haskell-based implementation. Of particular interest are the AFRP combinators that support dynamic collections and continuation-based switching. We show how these combinators can be used to express systems with an evolving structure that are difficult to model in more traditional dataflow languages.},
	urldate = {2016-11-04},
	booktitle = {Proceedings of the 2002 {ACM} {SIGPLAN} {Workshop} on {Haskell}},
	publisher = {ACM},
	author = {Nilsson, Henrik and Courtney, Antony and Peterson, John},
	year = {2002},
	keywords = {functional programming, Haskell, domain-specific languages, FRP, hybrid modeling, synchronous dataflow languages},
	pages = {51--64},
	file = {ACM Full Text PDF:/home/jonathan/Zotero/storage/S8JVEM69/Nilsson et al. - 2002 - Functional Reactive Programming, Continued.pdf:application/pdf;ACM Full Text PDF:/home/jonathan/Zotero/storage/PN5DAWIV/Nilsson et al. - 2002 - Functional Reactive Programming, Continued.pdf:application/pdf}
}

@techreport{jankovic_functional_2007,
	title = {Functional {Programming} and {Discrete} {Simulation}},
	author = {Jankovic, Peter and Such, Ondrej},
	year = {2007}
}

@inproceedings{henderson_functional_1982,
	address = {New York, NY, USA},
	series = {{LFP} '82},
	title = {Functional {Geometry}},
	isbn = {978-0-89791-082-8},
	url = {http://doi.acm.org/10.1145/800068.802148},
	doi = {10.1145/800068.802148},
	abstract = {A method of describing pictures is introduced. The equations, which describe the appearance of a picture, also form a purely functional program which can be used to compute the set of lines necessary to plot the picture on a graphical device. The method is illustrated by using it to describe the structure of one of the woodcuts of Maurits Escher.},
	urldate = {2016-12-09},
	booktitle = {Proceedings of the 1982 {ACM} {Symposium} on {LISP} and {Functional} {Programming}},
	publisher = {ACM},
	author = {Henderson, Peter},
	year = {1982},
	pages = {179--187},
	file = {ACM Full Text PDF:/home/jonathan/Zotero/storage/GMXBBVK6/Henderson - 1982 - Functional Geometry.pdf:application/pdf;ACM Full Text PDF:/home/jonathan/Zotero/storage/3HMA3EWS/Henderson - 1982 - Functional Geometry.pdf:application/pdf}
}

@techreport{clinger_foundations_1981,
	address = {Cambridge, MA, USA},
	title = {Foundations of {Actor} {Semantics}},
	abstract = {The actor message-passing model of concurrent computation has inspired new ideas in the areas of knowledge-based systems, programming languages and their semantics, and computer systems architecture. This thesis extends and unifies the work of Carl Hewitt, Irene Greif, Henry Baker, and Giuseppe Attardi, who developed the mathematical content of the model. The ordering laws postulated by Hewitt and Baker can be proved using a notion of global time. The most general ordering laws are equivalent to an axiom of realizability in global time. Since nondeterministic concurrency is more fundamental than deterministic sequential computation, there may be no need to take fixed points in the underlying domain of a power domain. Power domains built from incomplete domains can solve the problem of providing a fixed point semantics for a class of nondeterministic programming languages in which a fair merge can be written. The locality laws postulated by Hewitt and Baker may be proved for the semantics of an actor-based language. Altering the semantics slightly can falsify the locality laws. The locality laws thus constrain what counts as an actor semantics.},
	institution = {Massachusetts Institute of Technology},
	author = {Clinger, William D},
	year = {1981}
}

@techreport{di_stefano_exat:_2007,
	title = {{eXAT}: an {Experimental} {Tool} for {Programming} {Multi}-{Agent} {Systems} in {Erlang}},
	author = {Di Stefano, Antonella and Santoro, Corrado},
	year = {2007}
}

@book{gamma_design_1994,
	edition = {1 edition},
	title = {Design {Patterns}: {Elements} of {Reusable} {Object}-{Oriented} {Software}},
	shorttitle = {Design {Patterns}},
	abstract = {Capturing a wealth of experience about the design of object-oriented software, four top-notch designers present a catalog of simple and succinct solutions to commonly occurring design problems. Previously undocumented, these 23 patterns allow designers to create more flexible, elegant, and ultimately reusable designs without having to rediscover the design solutions themselves. The authors begin by describing what patterns are and how they can help you design object-oriented software. They then go on to systematically name, explain, evaluate, and catalog recurring designs in object-oriented systems. With Design Patterns as your guide, you will learn how these important patterns fit into the software development process, and how you can leverage them to solve your own design problems most efficiently. Each pattern describes the circumstances in which it is applicable, when it can be applied in view of other design constraints, and the consequences and trade-offs of using the pattern within a larger design. All patterns are compiled from real systems and are based on real-world examples. Each pattern also includes code that demonstrates how it may be implemented in object-oriented programming languages like C++ or Smalltalk.},
	language = {English},
	publisher = {Addison-Wesley Professional},
	author = {Gamma, Erich and Helm, Richard and Johnson, Ralph and Vlissides, John and Booch, Grady},
	month = oct,
	year = {1994}
}

@inproceedings{ionescu_dependently-typed_2012,
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Dependently-{Typed} {Programming} in {Scientific} {Computing}},
	copyright = {©2013 Springer-Verlag Berlin Heidelberg},
	isbn = {978-3-642-41581-4 978-3-642-41582-1},
	url = {http://link.springer.com/chapter/10.1007/978-3-642-41582-1_9},
	abstract = {Computer simulations are essential in virtually every scientific discipline, even more so in those such as economics or climate change where the ability to make laboratory experiments is limited. Therefore, it is important to ensure that the models are implemented correctly, that they can be re-implemented and that the results can be reproduced. Typically, though, the models are described by a mixture of prose and mathematics which is insufficient for these purposes. We argue that using dependent types allows us to gradually reduce the gap between the mathematical description and the implementation, and we give examples from economic modelling. We discuss the consequences that our incremental approach has on programming style and the requirements it imposes on the dependently-typed programming languages used.},
	language = {en},
	urldate = {2016-12-12},
	booktitle = {Implementation and {Application} of {Functional} {Languages}},
	publisher = {Springer Berlin Heidelberg},
	author = {Ionescu, Cezar and Jansson, Patrik},
	editor = {Hinze, Ralf},
	month = aug,
	year = {2012},
	doi = {10.1007/978-3-642-41582-1_9},
	keywords = {Software Engineering, Logics and Meanings of Programs, Programming Techniques, Information Systems Applications (incl. Internet), Compilers, Interpreters, Programming Languages, Programming Languages, Compilers, Interpreters, Mathematical Logic and Formal Languages},
	pages = {140--156},
	annote = {DOI: 10.1007/978-3-642-41582-1\_9},
	file = {Snapshot:/home/jonathan/Zotero/storage/N66ADBRB/978-3-642-41582-1_9.html:text/html;Snapshot:/home/jonathan/Zotero/storage/X3NH7SQF/978-3-642-41582-1_9.html:text/html}
}

@techreport{glasserman_contagion_2015,
	address = {Rochester, NY},
	type = {{SSRN} {Scholarly} {Paper}},
	title = {Contagion in {Financial} {Networks}},
	url = {https://papers.ssrn.com/abstract=2681392},
	abstract = {This paper surveys the rapidly growing literature about interconnectedness and financial stability. The paper focuses on insights in the literature on the relationship between network structure and the vulnerability of the financial system to contagion.},
	number = {ID 2681392},
	urldate = {2016-12-12},
	institution = {Social Science Research Network},
	author = {Glasserman, Paul and Young, Peyton},
	month = oct,
	year = {2015},
	keywords = {SSRN, Contagion in Financial Networks, Paul  Glasserman, Paul Glasserman, Peyton  Young, Peyton Young},
	file = {Snapshot:/home/jonathan/Zotero/storage/ZT94UFPZ/papers.html:text/html;Snapshot:/home/jonathan/Zotero/storage/PIK862B8/papers.html:text/html}
}

@inproceedings{moggi_computational_1989,
	address = {Piscataway, NJ, USA},
	title = {Computational {Lambda}-calculus and {Monads}},
	isbn = {978-0-8186-1954-0},
	url = {http://dl.acm.org/citation.cfm?id=77350.77353},
	urldate = {2016-11-16},
	booktitle = {Proceedings of the {Fourth} {Annual} {Symposium} on {Logic} in {Computer} {Science}},
	publisher = {IEEE Press},
	author = {Moggi, E.},
	year = {1989},
	pages = {14--23}
}

@book{kirman_complex_2010,
	address = {London ; New York, NY},
	title = {Complex {Economics}: {Individual} and {Collective} {Rationality}},
	isbn = {978-0-415-56855-5},
	shorttitle = {Complex {Economics}},
	abstract = {The economic crisis is also a crisis for economic theory. Most analyses of the evolution of the crisis invoke three themes, contagion, networks and trust, yet none of these play a major role in standard macroeconomic models. What is needed is a theory in which these aspects are central. The direct interaction between individuals, firms and banks does not simply produce imperfections in the functioning of the economy but is the very basis of the functioning of a modern economy. This book suggests a way of analysing the economy which takes this point of view.  The economy should be considered as a complex adaptive system in which the agents constantly react to, influence and are influenced by, the other individuals in the economy. In such systems which are familiar from statistical physics and biology for example, the behaviour of the aggregate cannot be deduced from the behaviour of the average, or "representative" individual. Just as the organised activity of an ants’ nest cannot be understood from the behaviour of a "representative ant" so macroeconomic phenomena should not be assimilated to those associated with the "representative agent". This book provides examples where this can clearly be seen. The examples range from Schelling’s model of segregation, to contributions to public goods, the evolution of buyer seller relations in fish markets, to financial models based on the foraging behaviour of ants.   The message of the book is that coordination rather than efficiency is the central problem in economics. How do the myriads of individual choices and decisions come to be coordinated? How does the economy or a market, "self organise" and how does this sometimes result in major upheavals, or to use the phrase from physics, "phase transitions"? The sort of system described in this book is not in equilibrium in the standard sense, it is constantly changing and moving from state to state and its very structure is always being modified. The economy is not a ship sailing on a well-defined trajectory which occasionally gets knocked off course. It is more like the slime described in the book "emergence", constantly reorganising itself so as to slide collectively in directions which are neither understood nor necessarily desired by its components.},
	language = {English},
	publisher = {Routledge},
	author = {Kirman, Alan},
	month = jul,
	year = {2010}
}

@inproceedings{hewitt_universal_1973,
	address = {San Francisco, CA, USA},
	series = {{IJCAI}'73},
	title = {A {Universal} {Modular} {ACTOR} {Formalism} for {Artificial} {Intelligence}},
	url = {http://dl.acm.org/citation.cfm?id=1624775.1624804},
	urldate = {2016-10-25},
	booktitle = {Proceedings of the 3rd {International} {Joint} {Conference} on {Artificial} {Intelligence}},
	publisher = {Morgan Kaufmann Publishers Inc.},
	author = {Hewitt, Carl and Bishop, Peter and Steiger, Richard},
	year = {1973},
	pages = {235--245}
}

@incollection{hudak_arrows_2003,
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Arrows, {Robots}, and {Functional} {Reactive} {Programming}},
	copyright = {©2003 Springer-Verlag Berlin Heidelberg},
	isbn = {978-3-540-40132-2 978-3-540-44833-4},
	url = {http://link.springer.com/chapter/10.1007/978-3-540-44833-4_6},
	abstract = {Functional reactive programming},
	language = {en},
	number = {2638},
	urldate = {2016-11-04},
	booktitle = {Advanced {Functional} {Programming}},
	publisher = {Springer Berlin Heidelberg},
	author = {Hudak, Paul and Courtney, Antony and Nilsson, Henrik and Peterson, John},
	editor = {Jeuring, Johan and Jones, Simon L. Peyton},
	year = {2003},
	doi = {10.1007/978-3-540-44833-4_6},
	keywords = {Software Engineering, Logics and Meanings of Programs, Programming Techniques, Compilers, Interpreters, Programming Languages, Programming Languages, Compilers, Interpreters},
	pages = {159--187},
	annote = {DOI: 10.1007/978-3-540-44833-4\_6},
	file = {Snapshot:/home/jonathan/Zotero/storage/2VRFNQVC/10.html:text/html;Snapshot:/home/jonathan/Zotero/storage/WW5CGBKS/10.html:text/html}
}

@book{wooldridge_introduction_2009,
	edition = {2nd},
	title = {An {Introduction} to {MultiAgent} {Systems}},
	isbn = {978-0-470-51946-2},
	abstract = {The study of multi-agent systems (MAS) focuses on systems in which many intelligent agents interact with each other. These agents are considered to be autonomous entities such as software programs or robots. Their interactions can either be cooperative (for example as in an ant colony) or selfish (as in a free market economy). This book assumes only basic knowledge of algorithms and discrete maths, both of which are taught as standard in the first or second year of computer science degree programmes. A basic knowledge of artificial intelligence would useful to help understand some of the issues, but is not essential. The books main aims are: To introduce the student to the concept of agents and multi-agent systems, and the main applications for which they are appropriate To introduce the main issues surrounding the design of intelligent agents To introduce the main issues surrounding the design of a multi-agent society To introduce a number of typical applications for agent technology},
	publisher = {Wiley Publishing},
	author = {Wooldridge, Michael},
	year = {2009}
}

@book{wilensky_introduction_2015,
	title = {An {Introduction} to {Agent}-{Based} {Modeling}: {Modeling} {Natural}, {Social}, and {Engineered} {Complex} {Systems} with {NETLogo}},
	isbn = {978-0-262-73189-8},
	url = {https://www.amazon.co.uk/Introduction-Agent-Based-Modeling-Natural-Engineered/dp/0262731894},
	urldate = {2016-12-14},
	publisher = {MIT Press},
	author = {Wilensky, Uri and Rand, William},
	year = {2015}
}

@article{gode_allocative_1993,
	title = {Allocative {Efficiency} of {Markets} with {Zero}-{Intelligence} {Traders}: {Market} as a {Partial} {Substitute} for {Individual} {Rationality}},
	volume = {101},
	issn = {0022-3808},
	shorttitle = {Allocative {Efficiency} of {Markets} with {Zero}-{Intelligence} {Traders}},
	url = {http://www.jstor.org/stable/2138676},
	abstract = {We report market experiments in which human traders are replaced by "zero-intelligence" programs that submit random bids and offers. Imposing a budget constraint (i.e., not permitting traders to sell below their costs or buy above their values) is sufficient to raise the allocative efficiency of these auctions close to 100 percent. Allocative efficiency of a double auction derives largely from its structure, independent of traders' motivation, intelligence, or learning. Adam Smith's invisible hand may be more powerful than some may have thought; it can generate aggregate rationality not only from individual rationality but also from individual irrationality.},
	number = {1},
	urldate = {2016-09-30},
	journal = {Journal of Political Economy},
	author = {Gode, Dhananjay K. and Sunder, Shyam},
	year = {1993},
	pages = {119--137}
}

@book{sher_agent-based_2013,
	title = {Agent-{Based} {Modeling} {Using} {Erlang} {Eliminating} {The} {Conceptual} {Gap} {Between} {The} {Programming} {Language} \& {ABM}},
	abstract = {Abstract: There is a conceptual gap between real world systems and their models created using differential equations. Numerous systems, such as traffic flow, financial markets, neural networks... are all naturally composed of agents interacting with each other and the environment, from which the behavior of such systems emerges. The more complex the interactions and agents, the more difficult, and even impossible, it becomes to model them using averages and standard mathematical approaches like sets of differential equations. A more direct approach to modeling such complex systems is by modeling the agents themselves, and letting them interact with each other and the environment, with the system's behavior then emerging naturally. This approach is called Agent Based Modeling (ABM), and the conceptual gap between real world phenomena produced by interacting agents and their respective ABMs is lower than the models created using sets of differential equations. The removal of this conceptual gap through the use of ABMs allows us to tackle larger and more complex problems and explore emergent behavior more easily. Unfortunately, ABMs and the programming languages used to create them do not have a 1-to-1 mapping, and thus, producing a conceptual gap between the two. This paper attempts to present and make a claim that we can eliminate this conceptual gap by using an actor model based concurrency oriented programming language called Erlang. In this paper we discuss how Erlang fits into ABM and Multi-Agent Simulation systems, and what features it possesses that make it such a perfect},
	author = {Sher, Gene I.},
	year = {2013},
	file = {Citeseer - Full Text PDF:/home/jonathan/Zotero/storage/IDV4DJRX/Sher - Agent-Based Modeling Using Erlang Eliminating The .pdf:application/pdf;Citeseer - Full Text PDF:/home/jonathan/Zotero/storage/NIJAES5Q/Sher - Agent-Based Modeling Using Erlang Eliminating The .pdf:application/pdf;Citeseer - Snapshot:/home/jonathan/Zotero/storage/E2JXSGV7/summary.html:text/html;Citeseer - Snapshot:/home/jonathan/Zotero/storage/GHIJM8EA/summary.html:text/html}
}

@article{ballot_agent-based_2015,
	title = {Agent-based modeling and economic theory: where do we stand?},
	volume = {10},
	issn = {1860-711X},
	shorttitle = {Agent-based modeling and economic theory},
	url = {http://econpapers.repec.org/article/sprjeicoo/v_3a10_3ay_3a2015_3ai_3a2_3ap_3a199-220.htm},
	abstract = {This paper provides a survey of the development and contributions of agent-based modeling to economic analysis, without any claim to be exhaustive. Our perspective is particularly shaped by the papers presented at the 17th Wehia conference, a selection of which are published in this special issue. The paper shows how agent-based models have developed, and how they have improved our understanding not only of macroeconomic disequilibria but also of the possibilities of the emergence of equilibrium in such realistic systems. It also reviews the progress made in our understanding of real markets, and lists some of the improvements needed to establish these models as alternative tools to the present orthodox models. Copyright Springer-Verlag Berlin Heidelberg 2015},
	number = {2},
	urldate = {2016-10-31},
	journal = {Journal of Economic Interaction and Coordination},
	author = {Ballot, Gérard and Mandel, Antoine and Vignes, Annick},
	year = {2015},
	keywords = {Agent-based modeling, B5, C8, Economic thought, Heterogeneity},
	pages = {199--220},
	file = {RePEc Snapshot:/home/jonathan/Zotero/storage/AQIE9XB9/v_3a10_3ay_3a2015_3ai_3a2_3ap_3a199-220.html:text/html;RePEc Snapshot:/home/jonathan/Zotero/storage/B7ZP8XKC/v_3a10_3ay_3a2015_3ai_3a2_3ap_3a199-220.html:text/html}
}

@techreport{richiardi_agent-based_2007,
	type = {{LABORatorio} {R}. {Revelli} {Working} {Papers} {Series}},
	title = {Agent-based {Computational} {Economics}. {A} {Short} {Introduction}},
	url = {http://econpapers.repec.org/paper/ccawplabo/69.htm},
	number = {69},
	urldate = {2016-10-31},
	institution = {LABORatorio R. Revelli, Centre for Employment Studies},
	author = {Richiardi, Matteo},
	year = {2007},
	file = {RePEc PDF:/home/jonathan/Zotero/storage/F2INS8MN/Richiardi - 2007 - Agent-based Computational Economics. A Short Intro.pdf:application/pdf;RePEc PDF:/home/jonathan/Zotero/storage/BMHCQZZC/Richiardi - 2007 - Agent-based Computational Economics. A Short Intro.pdf:application/pdf;RePEc Snapshot:/home/jonathan/Zotero/storage/2267APQ8/69.html:text/html;RePEc Snapshot:/home/jonathan/Zotero/storage/NVMX9FNC/69.html:text/html}
}

@techreport{tesfatsion_agent-based_2006,
	type = {Handbook of {Computational} {Economics}},
	title = {Agent-{Based} {Computational} {Economics}: {A} {Constructive} {Approach} to {Economic} {Theory}},
	shorttitle = {Agent-{Based} {Computational} {Economics}},
	url = {http://econpapers.repec.org/bookchap/eeehecchp/2-16.htm},
	abstract = {Economies are complicated systems encompassing micro behaviors, interaction patterns, and global regularities. Whether partial or general in scope, studies of economic systems must consider how to handle difficult real-world aspects such as asymmetric information, imperfect competition, strategic interaction, collective learning, and the possibility of multiple equilibria. Recent advances in analytical and computational tools are permitting new approaches to the quantitative study of these aspects. One such approach is Agent-based Computational Economics (ACE), the computational study of economic processes modeled as dynamic systems of interacting agents. This chapter explores the potential advantages and disadvantages of ACE for the study of economic systems. General points are concretely illustrated using an ACE model of a two-sector decentralized market economy. Six issues are highlighted: Constructive understanding of production, pricing, and trade processes; the essential primacy of survival; strategic rivalry and market power; behavioral uncertainty and learning; the role of conventions and organizations; and the complex interactions among structural attributes, institutional arrangements, and behavioral dispositions.},
	urldate = {2016-10-31},
	institution = {Elsevier},
	author = {Tesfatsion, Leigh},
	year = {2006},
	pages = {831--880},
	file = {RePEc Snapshot:/home/jonathan/Zotero/storage/DHCPVABB/2-16.html:text/html;RePEc Snapshot:/home/jonathan/Zotero/storage/ETA4NG3S/2-16.html:text/html}
}

@article{botta_functional_2011,
	title = {A functional framework for agent-based models of exchange},
	volume = {218},
	issn = {0096-3003},
	url = {http://www.sciencedirect.com/science/article/pii/S0096300311010915},
	doi = {10.1016/j.amc.2011.08.051},
	abstract = {We propose a functional framework for studying agent-based dynamical models of exchange. The framework consists of a notation and of a number of elementary definitions. We argue that – in comparison to narrative descriptions – the framework has a number of advantages: (1) it allows one to express precisely the relationships between the classical notion of general equilibrium and agent-based models of exchange; (2) it supports computational descriptions of models of exchange which can be unambiguously implemented; (3) it assists the numerical investigation of such models by providing a specific set of elementary notions and computational primitives. These can be used to deduce model properties and to setup “crucial” numerical experiments for validating model implementations. In a companion paper, we apply the framework to specify and study a model of exchange in which multiple equilibrium prices coexist and prices evolve according to a simple trading scheme and to a generic genetic rule.},
	number = {8},
	urldate = {2016-09-30},
	journal = {Applied Mathematics and Computation},
	author = {Botta, N. and Mandel, A. and Ionescu, C. and Hofmann, M. and Lincke, D. and Schupp, S. and Jaeger, C.},
	month = dec,
	year = {2011},
	keywords = {Agent-based methods, Barter economies, Functional specifications, General equilibrium, Price dynamics},
	pages = {4025--4040},
	file = {ScienceDirect Full Text PDF:/home/jonathan/Zotero/storage/XBR8T9WN/Botta et al. - 2011 - A functional framework for agent-based models of e.pdf:application/pdf;ScienceDirect Full Text PDF:/home/jonathan/Zotero/storage/DAB4AVMK/Botta et al. - 2011 - A functional framework for agent-based models of e.pdf:application/pdf;ScienceDirect Snapshot:/home/jonathan/Zotero/storage/K4DQT3U4/S0096300311010915.html:text/html;ScienceDirect Snapshot:/home/jonathan/Zotero/storage/G5IGQAKV/S0096300311010915.html:text/html}
}

@book{agha_actors:_1986,
	address = {Cambridge, MA, USA},
	title = {Actors: {A} {Model} of {Concurrent} {Computation} in {Distributed} {Systems}},
	isbn = {978-0-262-01092-4},
	shorttitle = {Actors},
	publisher = {MIT Press},
	author = {Agha, Gul},
	year = {1986}
}

@article{hewitt_actor_2010,
	title = {Actor {Model} of {Computation}: {Scalable} {Robust} {Information} {Systems}},
	shorttitle = {Actor {Model} of {Computation}},
	url = {http://arxiv.org/abs/1008.1459},
	abstract = {The Actor model is a mathematical theory that treats "Actors" as the universal primitives of concurrent digital computation. The model has been used both as a framework for a theoretical understanding of concurrency, and as the theoretical basis for several practical implementations of concurrent systems. Unlike previous models of computation, the Actor model was inspired by physical laws. It was also influenced by the programming languages Lisp, Simula 67 and Smalltalk-72, as well as ideas for Petri Nets, capability-based systems and packet switching. The advent of massive concurrency through client-cloud computing and many-core computer architectures has galvanized interest in the Actor model. Actor technology will see significant application for integrating all kinds of digital information for individuals, groups, and organizations so their information usefully links together. Information integration needs to make use of the following information system principles: * Persistence. Information is collected and indexed. * Concurrency: Work proceeds interactively and concurrently, overlapping in time. * Quasi-commutativity: Information can be used regardless of whether it initiates new work or become relevant to ongoing work. * Sponsorship: Sponsors provide resources for computation, i.e., processing, storage, and communications. * Pluralism: Information is heterogeneous, overlapping and often inconsistent. * Provenance: The provenance of information is carefully tracked and recorded The Actor Model is intended to provide a foundation for inconsistency robust information integration},
	urldate = {2016-10-26},
	journal = {arXiv:1008.1459 [cs]},
	author = {Hewitt, Carl},
	month = aug,
	year = {2010},
	note = {arXiv: 1008.1459},
	keywords = {Computer Science - Programming Languages, and Cluster Computing, Computer Science - Distributed, Computer Science - Distributed, Parallel, and Cluster Computing, Parallel},
	annote = {arXiv: 1008.1459},
	annote = {Comment: Relationship to Internet of Things. arXiv admin note: text overlap with arXiv:0812.4852, arXiv:0901.4934},
	file = {arXiv\:1008.1459 PDF:/home/jonathan/Zotero/storage/KMJ2WJ6Z/Hewitt - 2010 - Actor Model of Computation Scalable Robust Inform.pdf:application/pdf;arXiv\:1008.1459 PDF:/home/jonathan/Zotero/storage/9X3FI6JI/Hewitt - 2010 - Actor Model of Computation Scalable Robust Inform.pdf:application/pdf;arXiv.org Snapshot:/home/jonathan/Zotero/storage/FIH4IZDU/1008.html:text/html;arXiv.org Snapshot:/home/jonathan/Zotero/storage/7I6F6KIZ/1008.html:text/html}
}

@misc{sorokin_aivika_2015,
	title = {Aivika 3: {C}reating a {S}imulation {L}ibrary based on {F}unctional {P}rogramming},
	url = {https://pdfs.semanticscholar.org/8dbd/cd2f4423dad78a37e6896496f7c6f95f929d.pdf},
	howpublished = {\url{https://pdfs.semanticscholar.org/8dbd/cd2f4423dad78a37e6896496f7c6f95f929d.pdf}},
	language = {English},
	author = {Sorokin, David},
	year = {2015},
	note = {Last Access October 11, 2019}
}

@article{farmer_economy_2009,
	title = {The economy needs agent-based modelling},
	volume = {460},
	copyright = {© 2009 Nature Publishing Group},
	issn = {0028-0836},
	url = {https://www.nature.com/nature/journal/v460/n7256/full/460685a.html},
	doi = {10.1038/460685a},
	abstract = {The leaders of the world are flying the economy by the seat of their pants, say J. Doyne Farmer and Duncan Foley. There is, however, a better way to help guide financial policies.},
	language = {en},
	number = {7256},
	urldate = {2017-05-15},
	journal = {Nature},
	author = {Farmer, J. Doyne and Foley, Duncan},
	month = aug,
	year = {2009},
	pages = {685--686},
	file = {Full Text PDF:/home/jonathan/Zotero/storage/WAFTQRMI/Farmer and Foley - 2009 - The economy needs agent-based modelling.pdf:application/pdf;Snapshot:/home/jonathan/Zotero/storage/T7XE3KBE/460685a.html:text/html}
}

@book{marlow_parallel_2013,
	title = {Parallel and {Concurrent} {Programming} in {Haskell}},
	isbn = {978-1-4493-3593-9},
	abstract = {If you have a working knowledge of Haskell, this hands-on book shows you how to use the language\{u2019\}s many APIs and frameworks for writing both parallel and concurrent programs. You\{u2019\}ll learn how parallelism exploits multicore processors to speed up computation-heavy programs, and how concurrency enables you to write programs with threads for multiple interactions. Author Simon Marlow walks you through the process with lots of code examples that you can run, experiment with, and extend. Divided into separate sections on Parallel and Concurrent Haskell, this book also includes exercises to help you become familiar with the concepts presented: Express parallelism in Haskell with the Eval monad and Evaluation Strategies Parallelize ordinary Haskell code with the Par monad Build parallel array-based computations, using the Repa library Use the Accelerate library to run computations directly on the GPU Work with basic interfaces for writing concurrent code Build trees of threads for larger and more complex programs Learn how to build high-speed concurrent network servers Write distributed programs that run on multiple machines in a network.},
	language = {en},
	publisher = {O'Reilly},
	author = {Marlow, Simon},
	year = {2013},
	note = {Google-Books-ID: k0W6AQAACAAJ}
}

@book{gregory_game_2018,
	title = {Game {Engine} {Architecture}, {Third} {Edition}},
	isbn = {978-1-138-03545-4},
	abstract = {Covers theory and practice of game engine software development, bringing together a wide range of concepts and techniques actually used by real game studios like Electronic Arts and Naughty Dog. The examples are often grounded in specific technologies, but the discussion extends way beyond any particular engine or API. The references and citations make it a great jumping off point for those who wish to dig deeper into any particular aspect of the game development process. New to this edition: update the section on game console HW, extend the rendering chapter, include a section on 2D GUI, new chapter on multiplayer networking, more coverage of the Unity game engine.},
	language = {en},
	publisher = {Taylor \& Francis},
	author = {Gregory, Jason},
	month = mar,
	year = {2018}
}

@book{osullivan_real_2008,
	edition = {1st},
	title = {Real {World} {Haskell}},
	isbn = {978-0-596-51498-3},
	abstract = {This easy-to-use, fast-moving tutorial introduces you to functional programming with Haskell. You'll learn how to use Haskell in a variety of practical ways, from short scripts to large and demanding applications. Real World Haskell takes you through the basics of functional programming at a brisk pace, and then helps you increase your understanding of Haskell in real-world issues like I/O, performance, dealing with data, concurrency, and more as you move through each chapter. With this book, you will: Understand the differences between procedural and functional programming Learn the features of Haskell, and how to use it to develop useful programs Interact with filesystems, databases, and network services Write solid code with automated tests, code coverage, and error handling Harness the power of multicore systems via concurrent and parallel programming You'll find plenty of hands-on exercises, along with examples of real Haskell programs that you can modify, compile, and run. Whether or not you've used a functional language before, if you want to understand why Haskell is coming into its own as a practical language in so many major organizations, Real World Haskell is the best place to start.},
	publisher = {O'Reilly Media, Inc.},
	author = {O'Sullivan, Bryan and Goerzen, John and Stewart, Don},
	year = {2008}
}

@article{claessen_testing_2002,
	title = {Testing {Monadic} {Code} with {QuickCheck}},
	volume = {37},
	issn = {0362-1340},
	url = {http://doi.acm.org/10.1145/636517.636527},
	doi = {10.1145/636517.636527},
	abstract = {QuickCheck is a previously published random testing tool for Haskell programs. In this paper we show how to use it for testing monadic code, and in particular imperative code written using the ST monad. QuickCheck tests a program against a specification: we show that QuickCheck's specification language is sufficiently powerful to represent common forms of specifications: algebraic, model-based (both functional and relational), and pre-/post-conditional. Moreover, all these forms of specification can be used directly for testing. We define a new language of monadic properties, and make a link between program testing and the notion of observational equivalence.},
	number = {12},
	urldate = {2017-05-11},
	journal = {SIGPLAN Not.},
	author = {Claessen, Koen and Hughes, John},
	month = dec,
	year = {2002},
	pages = {47--59},
	file = {ACM Full Text PDF:/home/jonathan/Zotero/storage/3SMCN5GK/Claessen and Hughes - 2002 - Testing Monadic Code with QuickCheck.pdf:application/pdf}
}

@book{hutton_programming_2016,
	title = {Programming in {Haskell}},
	isbn = {978-1-316-87597-1},
	abstract = {Haskell is a purely functional language that allows programmers to rapidly develop clear, concise, and correct software. The language has grown in popularity in recent years, both in teaching and in industry. This book is based on the author's experience of teaching Haskell for more than twenty years. All concepts are explained from first principles and no programming experience is required, making this book accessible to a broad spectrum of readers. While Part I focuses on basic concepts, Part II introduces the reader to more advanced topics. This new edition has been extensively updated and expanded to include recent and more advanced features of Haskell, new examples and exercises, selected solutions, and freely downloadable lecture slides and example code. The presentation is clean and simple, while also being fully compliant with the latest version of the language, including recent changes concerning applicative, monadic, foldable, and traversable types.},
	language = {en},
	publisher = {Cambridge University Press},
	author = {Hutton, Graham},
	month = aug,
	year = {2016},
	note = {Google-Books-ID: 1xHPDAAAQBAJ},
	keywords = {Computers / Programming Languages / General, Mathematics / Discrete Mathematics, Mathematics / Numerical Analysis}
}

@book{michaelson_introduction_2011,
	title = {An {Introduction} to {Functional} {Programming} {Through} {Lambda} {Calculus}},
	isbn = {978-0-486-47883-8},
	abstract = {Functional programming is rooted in lambda calculus, which constitutes the world\&\#39;s smallest programming language. This well-respected text offers an accessible introduction to functional programming concepts and techniques for students of mathematics and computer science. The treatment is as nontechnical as possible, and it assumes no prior knowledge of mathematics or functional programming. Cogent examples illuminate the central ideas, and numerous exercises appear throughout the text, offering reinforcement of key concepts. All problems feature complete solutions.},
	language = {en},
	publisher = {Courier Corporation},
	author = {Michaelson, Greg},
	year = {2011},
	note = {Google-Books-ID: gKvwPtvsSjsC},
	keywords = {Computers / Programming Languages / General, Computers / Programming / Object Oriented, Mathematics / General}
}

@inproceedings{hudak_history_2007,
	address = {New York, NY, USA},
	series = {{HOPL} {III}},
	title = {A {History} of {Haskell}: {Being} {Lazy} with {Class}},
	isbn = {978-1-59593-766-7},
	shorttitle = {A {History} of {Haskell}},
	url = {http://doi.acm.org/10.1145/1238844.1238856},
	doi = {10.1145/1238844.1238856},
	abstract = {This paper describes the history of Haskell, including its genesis and principles, technical contributions, implementations and tools, and applications and impact.},
	urldate = {2017-05-10},
	booktitle = {Proceedings of the {Third} {ACM} {SIGPLAN} {Conference} on {History} of {Programming} {Languages}},
	publisher = {ACM},
	author = {Hudak, Paul and Hughes, John and Peyton Jones, Simon and Wadler, Philip},
	year = {2007},
	pages = {12--1--12--55},
	file = {ACM Full Text PDF:/home/jonathan/Zotero/storage/GJQ4BK8V/Hudak et al. - 2007 - A History of Haskell Being Lazy with Class.pdf:application/pdf}
}

@inproceedings{wadler_essence_1992,
	address = {New York, NY, USA},
	series = {{POPL} '92},
	title = {The {Essence} of {Functional} {Programming}},
	isbn = {978-0-89791-453-6},
	url = {http://doi.acm.org/10.1145/143165.143169},
	doi = {10.1145/143165.143169},
	abstract = {This paper explores the use monads to structure functional
programs. No prior knowledge of monads or category theory is
required.

Monads increase the ease with which programs may be modified.
They can mimic the effect of impure features such as exceptions,
state, and continuations; and also provide effects not easily
achieved with such features. The types of a program reflect which
effects occur.

The first section is an extended example of the use of monads. A
simple interpreter is modified to support various extra features:
error messages, state, output, and non-deterministic choice. The
second section describes the relation between monads and the
continuation-passing style. The third section sketches how monads
are used in a compiler for Haskell that is written in Haskell.},
	urldate = {2017-05-10},
	booktitle = {Proceedings of the 19th {ACM} {SIGPLAN}-{SIGACT} {Symposium} on {Principles} of {Programming} {Languages}},
	publisher = {ACM},
	author = {Wadler, Philip},
	year = {1992},
	pages = {1--14},
	file = {ACM Full Text PDF:/home/jonathan/Zotero/storage/6CUXH85P/Wadler - 1992 - The Essence of Functional Programming.pdf:application/pdf}
}

@book{milner_communicating_1999,
	title = {Communicating and {Mobile} {Systems}: {The} {Pi} {Calculus}},
	isbn = {978-0-521-64320-7},
	shorttitle = {Communicating and {Mobile} {Systems}},
	abstract = {Communication is a fundamental and integral part of computing, whether between different computers on a network, or between components within a single computer. In this book Robin Milner introduces a new way of modelling communication that reflects its position. He treats computers and their programs as themselves built from communicating parts, rather than adding communication as an extra level of activity. Everything is introduced by means of examples, such as mobile phones, job schedualers, vending machines, data structures, and the objects of object-oriented programming. But the aim of the book is to develop a theory, the pi-calculus, in which these things can be treated rigorously. The pi-calculus differs from other models of communicating behaviour mainly in its treatment of mobility. The movement of a piece of data inside a computer program is treated exactly the same as the transfer of a message--or indeed an entire computer program--across the internet. One can also describe networks which reconfigure themselves. The calculus is very simple but powerful; its most prominent ingredient is the notion of a name. Its theory has two important ingredients: the concept of behavioural (or observational) equivalence, and the use of a new theory of types to classify patterns of interactive behaviour. The internet, and its communication protocols, fall within the scope of the theory just as much as computer programs, data structures, algorithms and programming languages. This book is the first textbook on the subject; it has been long-awaited by professionals and will be welcome by them, and their students.},
	language = {en},
	publisher = {Cambridge University Press},
	author = {Milner, Robin},
	month = may,
	year = {1999},
	note = {Google-Books-ID: k2tfQgAACAAJ},
	keywords = {Computers / Networking / General}
}

@book{hoare_communicating_1985,
	title = {Communicating {Sequential} {Processes}},
	isbn = {978-0-13-153289-2},
	abstract = {This book introduces a new mathematical approach to the study of concurrency and communication. Most suitable application of this new field is to the specification, design and implementation of computer systems which continuously act and interact with their environment.},
	language = {en},
	publisher = {Prentice-Hall},
	author = {Hoare, C. A. R.},
	year = {1985},
	note = {Google-Books-ID: tpZLQgAACAAJ},
	keywords = {Computers / General}
}

@article{armstrong_erlang_2010,
	title = {Erlang},
	volume = {53},
	issn = {0001-0782},
	url = {http://doi.acm.org/10.1145/1810891.1810910},
	doi = {10.1145/1810891.1810910},
	abstract = {The same component isolation that made it effective for large distributed telecom systems makes it effective for multicore CPUs and networked applications.},
	number = {9},
	urldate = {2017-05-09},
	journal = {Commun. ACM},
	author = {Armstrong, Joe},
	month = sep,
	year = {2010},
	pages = {68--75},
	file = {ACM Full Text PDF:/home/jonathan/Zotero/storage/R95QPAN3/Armstrong - 2010 - Erlang.pdf:application/pdf}
}

@techreport{hudak_haskell_1994,
	address = {New Haven, CT},
	type = {Research {Report}},
	title = {Haskell vs. {Ada} vs. {C}++ vs. {Awk} vs. ... {An} {Experiment} in {Software} {Prototyping} {Productivity}},
	number = {YALEU/DCS/RR-1049},
	institution = {Department of Computer Science, Yale University},
	author = {Hudak, Paul and Jones, Mark},
	month = oct,
	year = {1994}
}

@article{siebers_introduction_2008,
	title = {Introduction to {Multi}-{Agent} {Simulation}},
	url = {http://arxiv.org/abs/0803.3905},
	abstract = {When designing systems that are complex, dynamic and stochastic in nature, simulation is generally recognised as one of the best design support technologies, and a valuable aid in the strategic and tactical decision making process. A simulation model consists of a set of rules that define how a system changes over time, given its current state. Unlike analytical models, a simulation model is not solved but is run and the changes of system states can be observed at any point in time. This provides an insight into system dynamics rather than just predicting the output of a system based on specific inputs. Simulation is not a decision making tool but a decision support tool, allowing better informed decisions to be made. Due to the complexity of the real world, a simulation model can only be an approximation of the target system. The essence of the art of simulation modelling is abstraction and simplification. Only those characteristics that are important for the study and analysis of the target system should be included in the simulation model.},
	urldate = {2017-05-09},
	journal = {arXiv:0803.3905 [cs]},
	author = {Siebers, Peer-Olaf and Aickelin, Uwe},
	month = mar,
	year = {2008},
	note = {arXiv: 0803.3905},
	keywords = {Computer Science - Multiagent Systems, Computer Science - Neural and Evolutionary Computing},
	file = {arXiv\:0803.3905 PDF:/home/jonathan/Zotero/storage/G9V5DQB5/Siebers and Aickelin - 2008 - Introduction to Multi-Agent Simulation.pdf:application/pdf;arXiv.org Snapshot:/home/jonathan/Zotero/storage/N3JA3GJA/0803.html:text/html}
}

@article{lamport_time_1978,
	title = {Time, {Clocks}, and the {Ordering} of {Events} in a {Distributed} {System}},
	volume = {21},
	issn = {0001-0782},
	url = {http://doi.acm.org/10.1145/359545.359563},
	doi = {10.1145/359545.359563},
	abstract = {The concept of one event happening before another in a distributed system is examined, and is shown to define a partial ordering of the events. A distributed algorithm is given for synchronizing a system of logical clocks which can be used to totally order the events. The use of the total ordering is illustrated with a method for solving synchronization problems. The algorithm is then specialized for synchronizing physical clocks, and a bound is derived on how far out of synchrony the clocks can become.},
	number = {7},
	urldate = {2019-04-25},
	journal = {Commun. ACM},
	author = {Lamport, Leslie},
	month = jul,
	year = {1978},
	keywords = {distributed systems, clock synchronization, computer networks, multiprocess systems},
	pages = {558--565}
}

@article{thaler_specification_2019,
	title = {Specification {Testing} of {Agent}-{Based} {Simulation} using {Property}-{Based} {Testing}},
	volume = {Under Review},
	language = {English},
	number = {Under Review},
	journal = {Autonomous Agents and Multi-Agent Systems},
	author = {Thaler, Jonathan and Siebers, Peer-Olaf},
	month = aug,
	year = {2019},
	pages = {15}
}

@inproceedings{asta_investigation_2014,
	title = {An investigation on test driven discrete event simulation},
	url = {http://eprints.nottingham.ac.uk/28211/},
	abstract = {This paper deals with the application of modern software development tools on simulation development. Recently, Agile Software Development (ASD) methods enjoy an increasing popularity. eXtreme Programming (XP) techniques, one of the techniques which belong to the ASD group of methods is a software development method which improves software quality and responsiveness of software projects through introducing short development cycles and a Test Driven Development (TDD) philosophy throughout the development. In this paper, we particularly pay attention to the application of the TDD by approaching simulation development from a test-first perspective. This study consists of a feasibility study of applying the TDD technique in simulation development in its various levels, say, acceptance and unit testing. Moreover, a simulation case study of a surgical ward has been considered, designed and implemented using the AnyLogic simulation toolkit. Our study differs from the mainstream in many ways. It addresses the feasibility of Test-Driven Simulation Development in Visual Interactive Modelling and Simulation (VIMS) environments as well as providing an insight into how the test-first concept can further help with the choice of components and acceptance testing.},
	booktitle = {Operational {Research} {Society} {Simulation} {Workshop} 2014 ({SW}14)},
	author = {Asta, Shahriar and Özcan, Ender and Siebers, Peer-Olaf},
	month = apr,
	year = {2014}
}

@misc{de_vries_quickcheckstatemachine,
	title = {An in-depth look at quickcheck-state-machine},
	url = {http://www.well-typed.com/blog/2019/01/qsm-in-depth/},
	howpublished = {\url{http://www.well-typed.com/blog/2019/01/qsm-in-depth/}},
	language = {English},
	author = {De Vries, E.},
	month = Jan,
	year = {2019},
	note = {Last Access October 11, 2019}
}

@article{bernardy_linear_2017,
	title = {Linear {Haskell}: practical linearity in a higher-order polymorphic language},
	volume = {2},
	issn = {24751421},
	shorttitle = {Linear {Haskell}},
	url = {http://arxiv.org/abs/1710.09756},
	doi = {10.1145/3158093},
	abstract = {Linear type systems have a long and storied history, but not a clear path forward to integrate with existing languages such as OCaml or Haskell. In this paper, we study a linear type system designed with two crucial properties in mind: backwards-compatibility and code reuse across linear and non-linear users of a library. Only then can the benefits of linear types permeate conventional functional programming. Rather than bifurcate types into linear and non-linear counterparts, we instead attach linearity to function arrows. Linear functions can receive inputs from linearly-bound values, but can also operate over unrestricted, regular values. To demonstrate the efficacy of our linear type system - both how easy it can be integrated in an existing language implementation and how streamlined it makes it to write programs with linear types - we implemented our type system in GHC, the leading Haskell compiler, and demonstrate two kinds of applications of linear types: mutable data with pure interfaces; and enforcing protocols in I/O-performing functions.},
	number = {POPL},
	urldate = {2019-01-17},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Bernardy, Jean-Philippe and Boespflug, Mathieu and Newton, Ryan R. and Jones, Simon Peyton and Spiwack, Arnaud},
	month = dec,
	year = {2017},
	note = {arXiv: 1710.09756},
	keywords = {Computer Science - Programming Languages},
	pages = {1--29},
	file = {arXiv\:1710.09756 PDF:/home/jonathan/Zotero/storage/6334NGQZ/Bernardy et al. - 2017 - Linear Haskell practical linearity in a higher-or.pdf:application/pdf;arXiv.org Snapshot:/home/jonathan/Zotero/storage/ZAHXMBHM/1710.html:text/html}
}

@misc{weaver_replicating_2009,
	title = {Replicating {S}ugarscape in {N}et{L}ogo},
	url = {https://www2.le.ac.uk/departments/interdisciplinary-science/research/replicating-sugarscape},
	howpublished = {\url{https://www2.le.ac.uk/departments/interdisciplinary-science/research/replicating-sugarscape}},
	abstract = {Sugarscape is a model artificially intelligent agent-based social simulation following some or all rules presented by Joshua M. Epstein \& Robert Axtell in their book Growing Artificial Societies.

The simulation was translated into the Netlogo language by Iain Weaver as a summer internship project and is available from the Netlogo library on the Netlogo web site.},
	language = {English},
	urldate = {2018-10-15},
	journal = {Replicating Sugarscape in NetLogo},
	author = {Weaver, Iain},
	month = oct,
	year = {2009},
	note = {Last Access October 11, 2019}
}

@book{beck_test_2002,
	address = {Boston},
	edition = {01 edition},
	title = {Test {Driven} {Development}: {By} {Example}},
	isbn = {978-0-321-14653-3},
	shorttitle = {Test {Driven} {Development}},
	abstract = {Quite simply, test-driven development is meant to eliminate fear in application development. While some fear is healthy (often viewed as a conscience that tells programmers to "be careful!"), the author believes that byproducts of fear include tentative, grumpy, and uncommunicative programmers who are unable to absorb constructive criticism. When programming teams buy into TDD, they immediately see positive results. They eliminate the fear involved in their jobs, and are better equipped to tackle the difficult challenges that face them. TDD eliminates tentative traits, it teaches programmers to communicate, and it encourages team members to seek out criticism However, even the author admits that grumpiness must be worked out individually! In short, the premise behind TDD is that code should be continually tested and refactored. Kent Beck teaches programmers by example, so they can painlessly and dramatically increase the quality of their work.},
	language = {English},
	publisher = {Addison-Wesley Professional},
	author = {Beck, Kent},
	month = nov,
	year = {2002}
}

@inproceedings{uustalu_essence_2006,
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {The {Essence} of {Dataflow} {Programming}},
	isbn = {978-3-540-46845-5},
	abstract = {We propose a novel, comonadic approach to dataflow (stream-based) computation. This is based on the observation that both general and causal stream functions can be characterized as coKleisli arrows of comonads and on the intuition that comonads in general must be a good means to structure context-dependent computation. In particular, we develop a generic comonadic interpreter of languages for context-dependent computation and instantiate it for stream-based computation. We also discuss distributive laws of a comonad over a monad as a means to structure combinations of effectful and context-dependent computation. We apply the latter to analyse clocked dataflow (partial stream based) computation.},
	language = {en},
	booktitle = {Central {European} {Functional} {Programming} {School}},
	publisher = {Springer Berlin Heidelberg},
	author = {Uustalu, Tarmo and Vene, Varmo},
	editor = {Horváth, Zoltán},
	year = {2006},
	keywords = {Functional Programming, Input Stream, Stream Function, Type Constructor, Unit Anticipation},
	pages = {135--167},
	file = {Springer Full Text PDF:/home/jonathan/Zotero/storage/HH22EQWI/Uustalu and Vene - 2006 - The Essence of Dataflow Programming.pdf:application/pdf}
}

@incollection{vendrov_frabjous_2014,
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Frabjous {A} {Declarative} {Domain}-{Specific} {Language} for {Agent}-{Based} {Modeling}},
	copyright = {©2014 Springer International Publishing Switzerland},
	isbn = {978-3-319-05578-7 978-3-319-05579-4},
	shorttitle = {Frabjous},
	url = {http://link.springer.com/chapter/10.1007/978-3-319-05579-4_47},
	abstract = {Agent-based modeling (ABM) is a powerful tool for the study of complex systems; but agent-based models are notoriously difficult to create, modify, and reason about, especially in contrast to system dynamics models. We argue that these difficulties are strongly related to the choice of specification language, and that they can be mitigated by using functional reactive programming (FRP), a paradigm for describing dynamic systems. We describe Frabjous, a new language for agent-based modeling based on FRP, and discuss its software engineering benefits and their broader implications for language choice in ABM.},
	language = {en},
	number = {8393},
	urldate = {2016-10-31},
	booktitle = {Social {Computing}, {Behavioral}-{Cultural} {Modeling} and {Prediction}},
	publisher = {Springer International Publishing},
	author = {Vendrov, Ivan and Dutchyn, Christopher and Osgood, Nathaniel D.},
	editor = {Kennedy, William G. and Agarwal, Nitin and Yang, Shanchieh Jay},
	month = apr,
	year = {2014},
	doi = {10.1007/978-3-319-05579-4_47},
	keywords = {agent-based simulation, simulation, Agent-based modeling, functional programming, Computer Communication Networks, Information Systems Applications (incl. Internet), domain-specific language, dynamic model, functional reactive, Management of Computing and Information Systems, Computer Appl. in Social and Behavioral Sciences, Computers and Society, Data Mining and Knowledge Discovery},
	pages = {385--392},
	annote = {DOI: 10.1007/978-3-319-05579-4\_47},
	file = {Snapshot:/home/jonathan/Zotero/storage/6ZSU4JKC/10.html:text/html;Snapshot:/home/jonathan/Zotero/storage/QNAUCNTW/10.html:text/html}
}

@article{figueredo_comparing_2014,
	title = {Comparing {Stochastic} {Differential} {Equations} and {Agent}-{Based} {Modelling} and {Simulation} for {Early}-{Stage} {Cancer}},
	volume = {9},
	issn = {1932-6203},
	url = {https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0095150},
	doi = {10.1371/journal.pone.0095150},
	abstract = {There is great potential to be explored regarding the use of agent-based modelling and simulation as an alternative paradigm to investigate early-stage cancer interactions with the immune system. It does not suffer from some limitations of ordinary differential equation models, such as the lack of stochasticity, representation of individual behaviours rather than aggregates and individual memory. In this paper we investigate the potential contribution of agent-based modelling and simulation when contrasted with stochastic versions of ODE models using early-stage cancer examples. We seek answers to the following questions: (1) Does this new stochastic formulation produce similar results to the agent-based version? (2) Can these methods be used interchangeably? (3) Do agent-based models outcomes reveal any benefit when compared to the Gillespie results? To answer these research questions we investigate three well-established mathematical models describing interactions between tumour cells and immune elements. These case studies were re-conceptualised under an agent-based perspective and also converted to the Gillespie algorithm formulation. Our interest in this work, therefore, is to establish a methodological discussion regarding the usability of different simulation approaches, rather than provide further biological insights into the investigated case studies. Our results show that it is possible to obtain equivalent models that implement the same mechanisms; however, the incapacity of the Gillespie algorithm to retain individual memory of past events affects the similarity of some results. Furthermore, the emergent behaviour of ABMS produces extra patters of behaviour in the system, which was not obtained by the Gillespie algorithm.},
	language = {en},
	number = {4},
	urldate = {2018-10-01},
	journal = {PLOS ONE},
	author = {Figueredo, Grazziela P. and Siebers, Peer-Olaf and Owen, Markus R. and Reps, Jenna and Aickelin, Uwe},
	month = apr,
	year = {2014},
	keywords = {Agent-based modeling, Algorithms, Apoptosis, Cancer treatment, Cell death, Cytokines, Mathematical models, Simulation and modeling},
	pages = {e95150},
	file = {Full Text PDF:/home/jonathan/Zotero/storage/GKR2NKDJ/Figueredo et al. - 2014 - Comparing Stochastic Differential Equations and Ag.pdf:application/pdf;Snapshot:/home/jonathan/Zotero/storage/BA4AAJBH/article.html:text/html}
}

@inproceedings{claessen_quickcheck_2000,
	address = {New York, NY, USA},
	series = {{ICFP} '00},
	title = {{QuickCheck} - {A} {Lightweight} {Tool} for {Random} {Testing} of {Haskell} {Programs}},
	isbn = {978-1-58113-202-1},
	shorttitle = {{QuickCheck}},
	url = {http://doi.acm.org/10.1145/351240.351266},
	doi = {10.1145/351240.351266},
	abstract = {Quick Check is a tool which aids the Haskell programmer in formulating and testing properties of programs. Properties are described as Haskell functions, and can be automatically tested on random input, but it is also possible to define custom test data generators. We present a number of case studies, in which the tool was successfully used, and also point out some pitfalls to avoid. Random testing is especially suitable for functional programs because properties can be stated at a fine grain. When a function is built from separately tested components, then random testing suffices to obtain good coverage of the definition under test.},
	urldate = {2016-11-16},
	booktitle = {Proceedings of the {Fifth} {ACM} {SIGPLAN} {International} {Conference} on {Functional} {Programming}},
	publisher = {ACM},
	author = {Claessen, Koen and Hughes, John},
	year = {2000},
	pages = {268--279},
	file = {ACM Full Text PDF:/home/jonathan/Zotero/storage/JZJFVIQK/Claessen and Hughes - 2000 - QuickCheck A Lightweight Tool for Random Testing .pdf:application/pdf;ACM Full Text PDF:/home/jonathan/Zotero/storage/CKGG42NQ/Claessen and Hughes - 2000 - QuickCheck A Lightweight Tool for Random Testing .pdf:application/pdf}
}

@article{gurcan_generic_2013,
	title = {A generic testing framework for agent-based simulation models},
	volume = {7},
	issn = {1747-7786},
	url = {https://doi.org/10.1057/jos.2012.26},
	doi = {10.1057/jos.2012.26},
	abstract = {Agent-based modelling and simulation (ABMS) had an increasing attention during the last decade. However, the weak validation and verification of agent-based simulation models makes ABMS hard to trust. There is no comprehensive tool set for verification and validation of agent-based simulation models, which demonstrates that inaccuracies exist and/or reveals the existing errors in the model. Moreover, on the practical side, many ABMS frameworks are in use. In this sense, we designed and developed a generic testing framework for agent-based simulation models to conduct validation and verification of models. This paper presents our testing framework in detail and demonstrates its effectiveness by showing its applicability on a realistic agent-based simulation case study.},
	language = {en},
	number = {3},
	urldate = {2018-09-27},
	journal = {Journal of Simulation},
	author = {Gurcan, O. and Dikenelli, O. and Bernon, C.},
	month = aug,
	year = {2013},
	keywords = {agent-based modelling and simulation, model testing, verification and validation},
	pages = {183--201}
}

@book{burnstein_practical_2010,
	edition = {1st},
	title = {Practical {Software} {Testing}: {A} {Process}-{Oriented} {Approach}},
	isbn = {978-1-4419-2885-6},
	shorttitle = {Practical {Software} {Testing}},
	abstract = {Based on the needs of the educational community, and the software professional, this book takes a unique approach to teaching software testing. It introduces testing concepts that are managerial, technical, and process oriented, using the Testing Maturity Model (TMM) as a guiding framework. The TMM levels and goals support a structured presentation of fundamental and advanced test-related concepts to the reader. In this context, the interrelationships between theoretical, technical, and managerial concepts become more apparent. In addition, relationships between the testing process, maturity goals, and such key players as managers, testers and client groups are introduced. Topics and features:- Process/engineering-oriented text- Promotes the growth and value of software testing as a profession- Introduces both technical and managerial aspects of testing in a clear and precise style- Uses the TMM framework to introduce testing concepts in a systemmatic, evolutionary way to faciliate understanding- Describes the role of testing tools and measurements, and how to integrate them into the testing process Graduate students and industry professionals will benefit from the book, which is designed for a graduate course in software testing, software quality assurance, or software validation and verification Moreover, the number of universities with graduate courses that cover this material will grow, given the evoluation in software development as an engineering discipline and the creation of degree programs in software engineering.},
	publisher = {Springer Publishing Company, Incorporated},
	author = {Burnstein, Ilene},
	year = {2010}
}

@book{mcmillan_symbolic_1993,
	address = {Norwell, MA, USA},
	title = {Symbolic {Model} {Checking}},
	isbn = {978-0-7923-9380-1},
	publisher = {Kluwer Academic Publishers},
	author = {McMillan, Kenneth L.},
	year = {1993}
}

@article{onggo_test-driven_2016,
	title = {Test-driven simulation modelling: {A} case study using agent-based maritime search-operation simulation},
	volume = {254},
	shorttitle = {Test-driven simulation modelling},
	doi = {10.1016/j.ejor.2016.03.050},
	abstract = {Model verification and validation (V\&V) is one of the most important activities in simulation modelling. Model validation is especially challenging for Agent-Based Simulation (ABS). Techniques that can help to improve V\&V in simulation modelling are needed. This paper proposes a V\&V technique called TestDriven Simulation Modelling (TDSM) which applies techniques from Test-Driven Development in software engineering to simulation modelling. The main principle in TDSM is that a unit test for a simulation model has to be specified before the simulation model is implemented. Hence, TDSM explicitly embeds V\&V in simulation modelling. We use a case study in maritime search operations to demonstrate how TDSM can be used in practice. Maritime search operations (and search operations in general) are one of the classic applications of Operational Research (OR). Hence, we can use analytical models from the vast search theory literature for unit tests in TDSM. The results show that TDSM is a useful technique in the verification and validation of simulation models, especially ABS models. This paper also shows that ABS can offer an alternative modelling approach in the analysis of maritime search operations. © 2016 Elsevier B.V. All rights reserved.},
	journal = {European Journal of Operational Research},
	author = {Onggo, Bhakti S. S. and Karatas, Mumtaz},
	year = {2016},
	keywords = {Agent-based model, Simulation, Software engineering, Test-driven development, Unit testing, Verification and validation},
	pages = {517--531}
}

@inproceedings{hughes_quickcheck_2007,
	address = {Berlin, Heidelberg},
	series = {{PADL}'07},
	title = {{QuickCheck} {Testing} for {Fun} and {Profit}},
	isbn = {978-3-540-69608-7},
	url = {http://dx.doi.org/10.1007/978-3-540-69611-7\_1},
	doi = {10.1007/978-3-540-69611-7\_1},
	abstract = {One of the nice things about purely functional languages is that functions often satisfy simple properties, and enjoy simple algebraic relationships. Indeed, if the functions of an API satisfy elegant laws, that in itself is a sign of a good design—the laws not only indicate conceptual simplicity, but are useful in practice for simplifying programs that use the API, by equational reasoning or otherwise.},
	urldate = {2018-09-24},
	booktitle = {Proceedings of the 9th {International} {Conference} on {Practical} {Aspects} of {Declarative} {Languages}},
	publisher = {Springer-Verlag},
	author = {Hughes, John},
	year = {2007},
	pages = {1--32}
}

@inproceedings{runciman_smallcheck_2008,
	address = {New York, NY, USA},
	series = {Haskell '08},
	title = {Smallcheck and {Lazy} {Smallcheck}: {Automatic} {Exhaustive} {Testing} for {Small} {Values}},
	isbn = {978-1-60558-064-7},
	shorttitle = {Smallcheck and {Lazy} {Smallcheck}},
	url = {http://doi.acm.org/10.1145/1411286.1411292},
	doi = {10.1145/1411286.1411292},
	abstract = {This paper describes two Haskell libraries for property-based testing. Following the lead of QuickCheck, these testing libraries SmallCheck and Lazy SmallCheck also use type-based generators to obtain test-sets of finite values for which properties are checked, and report any counter-examples found. But instead of using a sample of randomly generated values they test properties for all values up to some limiting depth, progressively increasing this limit. The paper explains the design and implementation of both libraries and evaluates them in comparison with each other and with QuickCheck.},
	urldate = {2018-09-18},
	booktitle = {Proceedings of the {First} {ACM} {SIGPLAN} {Symposium} on {Haskell}},
	publisher = {ACM},
	author = {Runciman, Colin and Naylor, Matthew and Lindblad, Fredrik},
	year = {2008},
	keywords = {embedded language, exhaustive search, lazy evaluation, property-based testing, type classes},
	pages = {37--48},
	file = {ACM Full Text PDF:/home/jonathan/Zotero/storage/GI69KFTB/Runciman et al. - 2008 - Smallcheck and Lazy Smallcheck Automatic Exhausti.pdf:application/pdf}
}

@article{north_complex_2013,
	title = {Complex adaptive systems modeling with {Repast} {Simphony}},
	volume = {1},
	issn = {2194-3206},
	url = {https://doi.org/10.1186/2194-3206-1-3},
	doi = {10.1186/2194-3206-1-3},
	abstract = {This paper is to describe development of the features and functions of Repast Simphony, the widely used, free, and open source agent-based modeling environment that builds on the Repast 3 library. Repast Simphony was designed from the ground up with a focus on well-factored abstractions. The resulting code has a modular architecture that allows individual components such as networks, logging, and time scheduling to be replaced as needed. The Repast family of agent-based modeling software has collectively been under continuous development for more than 10 years.},
	number = {1},
	urldate = {2018-08-02},
	journal = {Complex Adaptive Systems Modeling},
	author = {North, Michael J. and Collier, Nicholson T. and Ozik, Jonathan and Tatara, Eric R. and Macal, Charles M. and Bragen, Mark and Sydelko, Pam},
	month = mar,
	year = {2013},
	pages = {3},
	file = {Full Text PDF:/home/jonathan/Zotero/storage/JHYNHZPM/North et al. - 2013 - Complex adaptive systems modeling with Repast Simp.pdf:application/pdf;Snapshot:/home/jonathan/Zotero/storage/5CDV3776/2194-3206-1-3.html:text/html}
}

@inproceedings{shavit_software_1995,
	address = {New York, NY, USA},
	series = {{PODC} '95},
	title = {Software {Transactional} {Memory}},
	isbn = {978-0-89791-710-0},
	url = {http://doi.acm.org/10.1145/224964.224987},
	doi = {10.1145/224964.224987},
	urldate = {2018-08-01},
	booktitle = {Proceedings of the {Fourteenth} {Annual} {ACM} {Symposium} on {Principles} of {Distributed} {Computing}},
	publisher = {ACM},
	author = {Shavit, Nir and Touitou, Dan},
	year = {1995},
	pages = {204--213},
	file = {ACM Full Text PDF:/home/jonathan/Zotero/storage/MU422693/Shavit and Touitou - 1995 - Software Transactional Memory.pdf:application/pdf}
}

@article{lysenko_framework_2008,
	title = {A {Framework} for {Megascale} {Agent} {Based} {Model} {Simulations} on {Graphics} {Processing} {Units}},
	volume = {11},
	issn = {1460-7425},
	url = {http://jasss.soc.surrey.ac.uk/11/4/10.html},
	abstract = {Agent-based modeling is a technique for modeling dynamic systems from the bottom up. Individual elements of the system are represented computationally as agents. The system-level behaviors emerge from the micro-level interactions of the agents. Contemporary state-of-the-art agent-based modeling toolkits are essentially discrete-event simulators designed to execute serially on the Central Processing Unit (CPU). They simulate Agent-Based Models (ABMs) by executing agent actions one at a time. In addition to imposing an un-natural execution order, these toolkits have limited scalability. In this article, we investigate data-parallel computer architectures such as Graphics Processing Units (GPUs) to simulate large scale ABMs. We have developed a series of efficient, data parallel algorithms for handling environment updates, various agent interactions, agent death and replication, and gathering statistics. We present three fundamental innovations that provide unprecedented scalability. The first is a novel stochastic memory allocator which enables parallel agent replication in O(1) average time. The second is a technique for resolving precedence constraints for agent actions in parallel. The third is a method that uses specialized graphics hardware, to gather and process statistical measures. These techniques have been implemented on a modern day GPU resulting in a substantial performance increase. We believe that our system is the first ever completely GPU based agent simulation framework. Although GPUs are the focus of our current implementations, our techniques can easily be adapted to other data-parallel architectures. We have benchmarked our framework against contemporary toolkits using two popular ABMs, namely, SugarScape and StupidModel.},
	number = {4},
	journal = {Journal of Artificial Societies and Social Simulation},
	author = {Lysenko, Mikola and D'Souza, Roshan M.},
	year = {2008},
	keywords = {Agent Based Modeling, Data Parallel Algorithms, GPGPU, Stochastic},
	pages = {10}
}

@inproceedings{heindl_modeling_2009,
	address = {ICST, Brussels, Belgium, Belgium},
	series = {Simutools '09},
	title = {Modeling {Software} {Transactional} {Memory} with {AnyLogic}},
	isbn = {978-963-9799-45-5},
	url = {http://dx.doi.org/10.4108/ICST.SIMUTOOLS2009.5581},
	doi = {10.4108/ICST.SIMUTOOLS2009.5581},
	abstract = {A flexible simulation model is presented to study different variants of software transactional memory (STM), like pessimistic STM or optimistic STM either with inplace memory updates or write buffering. The dynamic behavior of transactions is encoded in timed statecharts as provided by the simulation tool AnyLogic in its implementation of real-time UML. Their graphical representation helps to convey the key design issues of the simulation model within this publication. Statistically significant numeric results for varying parameters, like number of threads, number of transactional operations, number of transactional data objects, are obtained efficiently as part of a Parameter Variation Experiment.},
	urldate = {2018-07-10},
	booktitle = {Proceedings of the 2Nd {International} {Conference} on {Simulation} {Tools} and {Techniques}},
	publisher = {ICST (Institute for Computer Sciences, Social-Informatics and Telecommunications Engineering)},
	author = {Heindl, Armin and Pokam, Gilles},
	year = {2009},
	pages = {10:1--10:10},
	file = {ACM Full Text PDF:/home/jonathan/Zotero/storage/HCQL5I6K/Heindl and Pokam - 2009 - Modeling Software Transactional Memory with AnyLog.pdf:application/pdf}
}

@inproceedings{winograd-cort_wormholes:_2012,
	address = {New York, NY, USA},
	series = {Haskell '12},
	title = {Wormholes: {Introducing} {Effects} to {FRP}},
	isbn = {978-1-4503-1574-6},
	shorttitle = {Wormholes},
	url = {http://doi.acm.org/10.1145/2364506.2364519},
	doi = {10.1145/2364506.2364519},
	abstract = {Functional reactive programming (FRP) is a useful model for programming real-time and reactive systems in which one defines a signal function to process a stream of input values into a stream of output values. However, performing side effects (e.g. memory mutation or input/output) in this model is tricky and typically unsafe. In previous work, Winograd-Cort et al. [2012] introduced resource types and wormholes to address this problem. This paper better motivates, expands upon, and formalizes the notion of a wormhole to fully unlock its potential. We show, for example, that wormholes can be used to define the concept of causality. This in turn allows us to provide behaviors such as looping, a core component of most languages, without building it directly into the language. We also improve upon our previous design by making wormholes less verbose and easier to use. To formalize the notion of a wormhole, we define an extension to the simply typed lambda calculus, complete with typing rules and operational semantics. In addition, we present a new form of semantic transition that we call a temporal transition to specify how an FRP program behaves over time and to allow us to better reason about causality. As our model is designed for a Haskell implementation, the semantics are lazy. Finally, with the language defined, we prove that our wormholes indeed allow side effects to be performed safely in an FRP framework.},
	urldate = {2018-07-10},
	booktitle = {Proceedings of the 2012 {Haskell} {Symposium}},
	publisher = {ACM},
	author = {Winograd-Cort, Daniel and Hudak, Paul},
	year = {2012},
	keywords = {functional reactive programming, arrows, causality, resource types, side effects, stream processing},
	pages = {91--104},
	file = {ACM Full Text PDF:/home/jonathan/Zotero/storage/G3KNFV3S/Winograd-Cort and Hudak - 2012 - Wormholes Introducing Effects to FRP.pdf:application/pdf}
}

@inproceedings{fujimoto_parallel_2017,
	title = {Parallel discrete event simulation: {The} making of a field},
	shorttitle = {Parallel discrete event simulation},
	doi = {10.1109/WSC.2017.8247793},
	abstract = {Originating in the 1970's, the parallel discrete event simulation (PDES) field grew from a group of researchers focused on determining how to execute a discrete event simulation program on a parallel computer while still obtaining the same results as a sequential execution. Over the decades that followed the field expanded, grew, and flourishes to this day. This paper describes the origins and development of the field in the words of many who were deeply involved. Unlike other published work focusing on technical issues, the emphasis here is on historical aspects that are not recorded elsewhere, providing a unique characterization of how the field was created and developed.},
	booktitle = {2017 {Winter} {Simulation} {Conference} ({WSC})},
	author = {Fujimoto, R. M. and Bagrodia, R. and Bryant, R. E. and Chandy, K. M. and Jefferson, D. and Misra, J. and Nicol, D. and Unger, B.},
	month = dec,
	year = {2017},
	keywords = {discrete event simulation, PDES, parallel computer, parallel discrete event simulation field, parallel processing, sequential execution},
	pages = {262--291},
	file = {IEEE Xplore Abstract Record:/home/jonathan/Zotero/storage/YQS6L7KN/8247793.html:text/html;IEEE Xplore Full Text PDF:/home/jonathan/Zotero/storage/Q5WP3E4I/Fujimoto et al. - 2017 - Parallel discrete event simulation The making of .pdf:application/pdf}
}

@article{fujimoto_parallel_1990,
	title = {Parallel {Discrete} {Event} {Simulation}},
	volume = {33},
	issn = {0001-0782},
	url = {http://doi.acm.org/10.1145/84537.84545},
	doi = {10.1145/84537.84545},
	abstract = {Parallel discrete event simulation (PDES), sometimes called distributed simulation, refers to the execution of a single discrete event simulation program on a parallel computer. PDES has attracted a considerable amount of interest in recent years. From a pragmatic standpoint, this interest arises from the fact that large simulations in engineering, computer science, economics, and military applications, to mention a few, consume enormous amounts of time on sequential machines. From an academic point of view, parallel simulation is interesting because it represents a problem domain that often contains substantial amounts of parallelism (e.g., see [59]), yet paradoxically, is surprisingly difficult to parallelize in practice. A sufficiently general solution to the PDES problem may lead to new insights in parallel computation as a whole. Historically, the irregular, data-dependent nature of PDES programs has identified it as an application where vectorization techniques using supercomputer hardware provide little benefit [14].A discrete event simulation model assumes the system being simulated only changes state at discrete points in simulated time. The simulation model jumps from one state to another upon the occurrence of an event. For example, a simulator of a store-and-forward communication network might include state variables to indicate the length of message queues, the status of communication links (busy or idle), etc. Typical events might include arrival of a message at some node in the network, forwarding a message to another network node, component failures, etc.We are especially concerned with the simulation of asynchronous systems where events are not synchronized by a global clock, but rather, occur at irregular time intervals. For these systems, few simulator events occur at any single point in simulated time; therefore parallelization techniques based on lock-step execution using a global simulation clock perform poorly or require assumptions in the timing model that may compromise the fidelity of the simulation. Concurrent execution of events at different points in simulated time is required, but as we shall soon see, this introduces interesting synchronization problems that are at the heart of the PDES problem.This article deals with the execution of a simulation program on a parallel computer by decomposing the simulation application into a set of concurrently executing processes. For completeness, we conclude this section by mentioning other approaches to exploiting parallelism in simulation problems.Comfort and Shepard et al. have proposed using dedicated functional units to implement specific sequential simulation functions, (e.g., event list manipulation and random number generation [20, 23, 47]). This method can provide only a limited amount of speedup, however. Zhang, Zeigler, and Concepcion use the hierarchical decomposition of the simulation model to allow an event consisting of several subevents to be processed concurrently [21, 98]. A third alternative is to execute independent, sequential simulation programs on different processors [11, 39]. This replicated trials approach is useful if the simulation is largely stochastic and one is performing long simulation runs to reduce variance, or if one is attempting to simulate a specific simulation problem across a large number of different parameter settings. However, one drawback with this approach is that each processor must contain sufficient memory to hold the entire simulation. Furthermore, this approach is less suitable in a design environment where results of one experiment are used to determine the experiment that should be performed next because one must wait for a sequential execution to be completed before results are obtained.},
	number = {10},
	urldate = {2018-07-10},
	journal = {Commun. ACM},
	author = {Fujimoto, Richard M.},
	month = oct,
	year = {1990},
	pages = {30--53},
	file = {ACM Full Text PDF:/home/jonathan/Zotero/storage/9MK3WDWJ/Fujimoto - 1990 - Parallel Discrete Event Simulation.pdf:application/pdf}
}

@inproceedings{collier_test-driven_2013,
	title = {Test-driven agent-based simulation development},
	doi = {10.1109/WSC.2013.6721538},
	abstract = {Developing a useful agent-based model and simulation typically involves acquiring knowledge of the model's domain, developing the model itself, and then translating the model into software. This process can be complex and is an iterative one where changes in domain knowledge and model requirements or specifications can cause changes in the software that in turn may require additional modeling and domain knowledge. Test-driven development is a software development technique that can help ameliorate this complexity by evolving a loosely coupled flexible design, driven by the creation of many small, automated unit tests. When the focus shifts to writing small tests that exercise the simulations behavior, the larger problem of translating a conceptual model into working code is decomposed into a series of much smaller, more manageable and highly focused translations. This paper explores the application of this technique to agent-based simulation development with examples from Repast Simphony, ReLogo and Repast HPC.},
	booktitle = {2013 {Winter} {Simulations} {Conference} ({WSC})},
	author = {Collier, N. and Ozik, J.},
	month = dec,
	year = {2013},
	keywords = {simulation, software agents, Testing, agent-based model, Buildings, Context, Diseases, domain knowledge, Employment, formal specification, knowledge acquisition, model requirements, model specifications, Schedules, Software, software development, test-driven agent-based simulation},
	pages = {1551--1559},
	file = {IEEE Xplore Abstract Record:/home/jonathan/Zotero/storage/C9W7NRJQ/6721538.html:text/html;IEEE Xplore Full Text PDF:/home/jonathan/Zotero/storage/A3PGS2JD/Collier and Ozik - 2013 - Test-driven agent-based simulation development.pdf:application/pdf}
}

@inproceedings{discolo_lock_2006,
	address = {Berlin, Heidelberg},
	series = {{FLOPS}'06},
	title = {Lock {Free} {Data} {Structures} {Using} {STM} in {Haskell}},
	isbn = {3-540-33438-6 978-3-540-33438-5},
	url = {http://dx.doi.org/10.1007/11737414_6},
	doi = {10.1007/11737414_6},
	booktitle = {Proceedings of the 8th {International} {Conference} on {Functional} and {Logic} {Programming}},
	publisher = {Springer-Verlag},
	author = {Discolo, Anthony and Harris, Tim and Marlow, Simon and Jones, Simon Peyton and Singh, Satnam},
	year = {2006},
	pages = {65--80}
}

@inproceedings{perfumo_limits_2008,
	address = {New York, NY, USA},
	series = {{CF} '08},
	title = {The {Limits} of {Software} {Transactional} {Memory} ({STM}): {Dissecting} {Haskell} {STM} {Applications} on a {Many}-core {Environment}},
	isbn = {978-1-60558-077-7},
	url = {http://doi.acm.org/10.1145/1366230.1366241},
	doi = {10.1145/1366230.1366241},
	abstract = {In this paper, we present a Haskell Transactional Memory benchmark to provide a comprehensive application suite for the use of Software Transactional Memory (STM) researchers. We develop a framework to profile the execution of the benchmark applications and to collect detailed runtime data on their transactional behavior, running them on a 128-core multiprocessor. Using a composite of the collected raw data, we propose new transactional performance metrics. We analyze key statistics related to scalability, atomic sections, transactional events, overall transactional overhead and the relative hardware performance, accordingly drawing conclusions on the results. Our findings advance our comprehension on the STM runtime and the characteristics of different applications under the transactional management of the pure, functional programming language, Haskell.},
	booktitle = {Proceedings of the 5th {Conference} on {Computing} {Frontiers}},
	publisher = {ACM},
	author = {Perfumo, Cristian and Sönmez, Nehir and Stipic, Srdjan and Unsal, Osman and Cristal, Adrián and Harris, Tim and Valero, Mateo},
	year = {2008},
	keywords = {haskell, instrumentation, transactional memory},
	pages = {67--78}
}

@book{lipovaca_learn_2011,
	title = {Learn {You} a {Haskell} for {Great} {Good}!: {A} {Beginner}'s {Guide}},
	isbn = {978-1-59327-295-1},
	shorttitle = {Learn {You} a {Haskell} for {Great} {Good}!},
	abstract = {It's all in the name: Learn You a Haskell for Great Good! is a hilarious, illustrated guide to this complex functional language. Packed with the author's original artwork, pop culture references, and most importantly, useful example code, this book teaches functional fundamentals in a way you never thought possible.You'll start with the kid stuff: basic syntax, recursion, types and type classes. Then once you've got the basics down, the real black belt master-class begins: you'll learn to use applicative functors, monads, zippers, and all the other mythical Haskell constructs you've only read about in storybooks.As you work your way through the author's imaginative (and occasionally insane) examples, you'll learn to:–Laugh in the face of side effects as you wield purely functional programming techniques–Use the magic of Haskell's "laziness" to play with infinite sets of data–Organize your programs by creating your own types, type classes, and modules–Use Haskell's elegant input/output system to share the genius of your programs with the outside worldShort of eating the author's brain, you will not find a better way to learn this powerful language than reading Learn You a Haskell for Great Good!},
	language = {en},
	publisher = {No Starch Press},
	author = {Lipovaca, Miran},
	month = apr,
	year = {2011},
	note = {Google-Books-ID: QesxXj\_ecD0C},
	keywords = {Computers / Programming Languages / General, Computers / Programming / General, Computers / Programming / Open Source}
}

@article{odell_objects_2002,
	title = {Objects and {Agents} {Compared}},
	volume = {1},
	abstract = {Just how different - or the same - are objects and agents? Some developers consider agents to be objects, except with more bells and whistles. Then, there are those who see agents and objects as different even though they share many things in common. Both approaches, however, envision using objects and agents together in the development of software systems. In other words, objects and agents are two distinct notions - each having its own particular place in software development. The important point here is that the agent-based way of thinking brings a useful and important perspective for system development, which is different from - while similar to - the object-oriented way. This paper discusses some of the differences and similarities between agents and objects and lets you decide which viewpoint you want to choose.},
	number = {1},
	journal = {Journal of Object Technology},
	author = {Odell, James},
	month = may,
	year = {2002},
	pages = {41--53}
}

@inproceedings{jones_tackling_2002,
	title = {Tackling the {Awkward} {Squad}: monadic input/output, concurrency, exceptions, and foreign-language calls in {Haskell}},
	shorttitle = {Tackling the {Awkward} {Squad}},
	abstract = {Functional programming may be beautiful, but to write real applications we must grapple  with awkward real-world issues: input/output, robustness, concurrency, and interfacing to  programs written in other languages.},
	booktitle = {Engineering theories of software construction},
	publisher = {Press},
	author = {Jones, Simon Peyton},
	year = {2002},
	pages = {47--96},
	file = {Citeseer - Full Text PDF:/home/jonathan/Zotero/storage/B5QDDLSJ/Jones - 2002 - Tackling the Awkward Squad monadic inputoutput, .pdf:application/pdf;Citeseer - Snapshot:/home/jonathan/Zotero/storage/7WBAI3LK/summary.html:text/html}
}

@article{church_unsolvable_1936,
	title = {An {Unsolvable} {Problem} of {Elementary} {Number} {Theory}},
	volume = {58},
	issn = {00029327},
	url = {http://dx.doi.org/10.2307/2371045},
	doi = {10.2307/2371045},
	number = {2},
	journal = {American Journal of Mathematics},
	author = {Church, Alonzo},
	month = apr,
	year = {1936},
	keywords = {elementary\_number\_theory mathematics},
	pages = {345--363}
}

@article{turing_computable_1937,
	title = {On {Computable} {Numbers}, with an {Application} to the {Entscheidungsproblem}},
	volume = {s2-42},
	url = {http://dx.doi.org/10.1112/plms/s2-42.1.230},
	doi = {10.1112/plms/s2-42.1.230},
	number = {1},
	journal = {Proceedings of the London Mathematical Society},
	author = {Turing, A. M.},
	year = {1937},
	pages = {230--265}
}

@inproceedings{harris_composable_2005,
	address = {New York, NY, USA},
	series = {{PPoPP} '05},
	title = {Composable {Memory} {Transactions}},
	isbn = {978-1-59593-080-4},
	url = {http://doi.acm.org/10.1145/1065944.1065952},
	doi = {10.1145/1065944.1065952},
	abstract = {Writing concurrent programs is notoriously difficult, and is of increasing practical importance. A particular source of concern is that even correctly-implemented concurrency abstractions cannot be composed together to form larger abstractions. In this paper we present a new concurrency model, based on transactional memory, that offers far richer composition. All the usual benefits of transactional memory are present (e.g. freedom from deadlock), but in addition we describe new modular forms of blocking and choice that have been inaccessible in earlier work.},
	urldate = {2018-06-21},
	booktitle = {Proceedings of the {Tenth} {ACM} {SIGPLAN} {Symposium} on {Principles} and {Practice} of {Parallel} {Programming}},
	publisher = {ACM},
	author = {Harris, Tim and Marlow, Simon and Peyton-Jones, Simon and Herlihy, Maurice},
	year = {2005},
	keywords = {locks, non-blocking algorithms, transactions},
	pages = {48--60},
	file = {ACM Full Text PDF:/home/jonathan/Zotero/storage/B7AD466N/Harris et al. - 2005 - Composable Memory Transactions.pdf:application/pdf}
}

@book{pierce_programming_2018,
	series = {Software {Foundations} series, volume 2},
	title = {Programming {Language} {Foundations}},
	publisher = {Electronic textbook},
	author = {Pierce, Benjamin C. and Amorim, Arthur Azevedo de and Casinghino, Chris and Gaboardi, Marco and Greenberg, Michael and Hriţcu, Cǎtǎlin and Sjöberg, Vilhelm and Tolmach, Andrew and Yorgey, Brent},
	month = may,
	year = {2018},
	annote = {Version 5.5. {\textbackslash}URLhttp://www.cis.upenn.edu/ bcpierce/sf}
}

@book{stump_verified_2016,
	address = {New York, NY, USA},
	title = {Verified {Functional} {Programming} in {Agda}},
	isbn = {978-1-970001-27-3},
	abstract = {Agda is an advanced programming language based on Type Theory. Agda's type system is expressive enough to support full functional verification of programs, in two styles. In external verification, we write pure functional programs and then write proofs of properties about them. The proofs are separate external artifacts, typically using structural induction. In internal verification, we specify properties of programs through rich types for the programs themselves. This often necessitates including proofs inside code, to show the type checker that the specified properties hold. The power to prove properties of programs in these two styles is a profound addition to the practice of programming, giving programmers the power to guarantee the absence of bugs, and thus improve the quality of software more than previously possible. Verified Functional Programming in Agda is the first book to provide a systematic exposition of external and internal verification in Agda, suitable for undergraduate students of Computer Science. No familiarity with functional programming or computer-checked proofs is presupposed.  The book begins with an introduction to functional programming through familiar examples like booleans, natural numbers, and lists, and techniques for external verification. Internal verification is considered through the examples of vectors, binary search trees, and Braun trees. More advanced material on type-level computation, explicit reasoning about termination, and normalization by evaluation is also included. The book also includes a medium-sized case study on Huffman encoding and decoding.},
	publisher = {Association for Computing Machinery and Morgan \& Claypool},
	author = {Stump, Aaron},
	year = {2016}
}

@article{polhill_ghost_2005,
	title = {The {Ghost} in the {Model} (and {Other} {Effects} of {Floating} {Point} {Arithmetic})},
	volume = {8},
	issn = {1460-7425},
	url = {http://jasss.soc.surrey.ac.uk/8/1/5.html},
	abstract = {This paper will explore the effects of errors in floating point arithmetic in two published agent-based models: the first a model of land use change (Polhill et al. 2001; Gotts et al. 2003), the second a model of the stock market (LeBaron et al. 1999). The first example demonstrates how branching statements with floating point operands of comparison operators create a high degree of nonlinearity, leading in this case to the creation of 'ghost' agents – visible to some parts of the program but not to others. A potential solution to this problem is proposed. The second example shows how mathematical descriptions of models in the literature are insufficient to enable exact replication of work since mathematically equivalent implementations in terms of real number arithmetic are not equivalent in terms of floating point arithmetic.},
	number = {1},
	journal = {Journal of Artificial Societies and Social Simulation},
	author = {Polhill, J. Gary and Izquierdo, Luis R. and Gotts, Nicholas M.},
	year = {2005},
	keywords = {Replication, Agent Based Modelling, Floating Point Arithmetic, Interval Arithmetic},
	pages = {1}
}

@incollection{ormerod_validation_2006,
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Validation and {Verification} of {Agent}-{Based} {Models} in the {Social} {Sciences}},
	isbn = {978-3-642-01108-5 978-3-642-01109-2},
	url = {https://link.springer.com/chapter/10.1007/978-3-642-01109-2_10},
	abstract = {This paper considers some of the difficulties in establishing verificaction and validation of agent based models. The fact that most ABMs are solved by simulation rather than analytically blurs the distinction between validation and verification. We suggest that a clear description of the phenomena to be explained by the model and testing for the simplest possible realistic agent rules of behaviour are key to the successful validation of ABMs and will provide the strongest base for enabling model comparison and acceptance. In particular, the empirical evidence that in general agents act intuitively rather than rationally is now strong. This implies that models which assign high levels of cognition to their agents require particularly strong justification if they are to be considered valid.},
	language = {en},
	urldate = {2018-06-07},
	booktitle = {Epistemological {Aspects} of {Computer} {Simulation} in the {Social} {Sciences}},
	publisher = {Springer, Berlin, Heidelberg},
	author = {Ormerod, Paul and Rosewell, Bridget},
	month = oct,
	year = {2006},
	doi = {10.1007/978-3-642-01109-2_10},
	pages = {130--140},
	file = {Snapshot:/home/jonathan/Zotero/storage/WCM352LP/978-3-642-01109-2_10.html:text/html}
}

@book{robinson_simulation:_2014,
	title = {Simulation: {The} {Practice} of {Model} {Development} and {Use}},
	isbn = {978-1-137-32802-1},
	shorttitle = {Simulation},
	abstract = {The new edition of this successful textbook provides a comprehensive introduction to simulation, foregrounding the topic as an applied problem-solving tool. Guiding readers through the key stages in a simulation project in terms of both the technical requirements and the project management issues surrounding it, the book will enable students to develop appropriate valid conceptual models, perform simulation experiments, analyse the results and draw insightful conclusions. The author’s engaging style and authoritative knowledge of the subject make the book as accessible as it is essential, drawing on case studies and complementary online content to encourage a critical engagement with the topic.This is an ideal textbook for those studying on upper level undergraduate and postgraduate degree courses in Business and Management and MBA programmes, and is a core text for those specialising in operations management. In addition, it is an important text for students taking Simulation modules on Engineering, Computer Science or Mathematics degree programmes.},
	language = {en},
	publisher = {Macmillan Education UK},
	author = {Robinson, Stewart},
	month = sep,
	year = {2014},
	note = {Google-Books-ID: Dtn0oAEACAAJ},
	keywords = {Business \& Economics / General, Business \& Economics / Business Mathematics}
}

@article{halbwachs_synchronous_1991,
	title = {The synchronous data flow programming language {LUSTRE}},
	volume = {79},
	issn = {0018-9219},
	doi = {10.1109/5.97300},
	abstract = {The authors describe LUSTRE, a data flow synchronous language designed for programming reactive systems-such as automatic control and monitoring systems-as well as for describing hardware. The data flow aspect of LUSTRE makes it very close to usual description tools in these domains (block-diagrams, networks of operators, dynamical sample-systems, etc.), and its synchronous interpretation makes it well suited for handling time in programs. Moreover, this synchronous interpretation allows it to be compiled into an efficient sequential program. The LUSTRE formalism is very similar to temporal logics. This allows the language to be used for both writing programs and expressing program properties, which results in an original program verification methodology},
	number = {9},
	journal = {Proceedings of the IEEE},
	author = {Halbwachs, N. and Caspi, P. and Raymond, P. and Pilaud, D.},
	month = sep,
	year = {1991},
	keywords = {temporal logic, Protocols, Aerospace control, Automatic programming, Computer languages, Computerized monitoring, Delay, description tools, Design methodology, Frequency synchronization, Hardware design languages, LUSTRE, parallel languages, program verification, program verification methodology, reactive systems, Real time systems, sequential program, synchronous data flow programming language, temporal logics},
	pages = {1305--1320},
	file = {IEEE Xplore Abstract Record:/home/jonathan/Zotero/storage/UC5SBSWC/97300.html:text/html;IEEE Xplore Full Text PDF:/home/jonathan/Zotero/storage/54N6NC2L/Halbwachs et al. - 1991 - The synchronous data flow programming language LUS.pdf:application/pdf}
}

@inproceedings{dahl_birth_2002,
	title = {The birth of object orientation: the simula languages},
	shorttitle = {The birth of object orientation},
	abstract = {Abstract. The development of the programming languages Simula I and Simula 67 is briefly described. An attempt is made also to explain the cultural impact of the languages, in particular the object oriented aspects. 1},
	booktitle = {Software {Pioneers}: {Contributions} to {Software} {Engineering}, {Programming}, {Software} {Engineering} and {Operating} {Systems} {Series}},
	publisher = {Springer},
	author = {Dahl, Ole-johan},
	year = {2002},
	pages = {79--90},
	file = {Citeseer - Full Text PDF:/home/jonathan/Zotero/storage/VR7T8X22/Dahl - 2002 - The birth of object orientation the simula langua.pdf:application/pdf;Citeseer - Snapshot:/home/jonathan/Zotero/storage/XYPRXRLI/summary.html:text/html}
}

@inproceedings{altenkirch_why_2005,
	title = {Why dependent types matter},
	abstract = {We exhibit the rationale behind the design of Epigram, a dependently typed programming language and interactive program development system, using refinements of a well known program—merge sort—as a running example. We discuss its relationship with other proposals to introduce aspects of dependent types into functional programming languages and sketch some topics for further work in this area. 1.},
	booktitle = {http://www.e-pig.org/downloads/ydtm.pdf},
	author = {Altenkirch, Thorsten and Mcbride, Conor and Mckinna, James},
	year = {2005},
	file = {ACM Full Text PDF:/home/jonathan/Zotero/storage/MY3884P4/McKinna - 2006 - Why Dependent Types Matter.pdf:application/pdf;Citeseer - Full Text PDF:/home/jonathan/Zotero/storage/ZFVYLQBT/Altenkirch et al. - 2005 - Why dependent types matter.pdf:application/pdf;Citeseer - Snapshot:/home/jonathan/Zotero/storage/NWC5YIDG/summary.html:text/html}
}

@techreport{brady_state_2016,
	title = {State {Machines} {All} {The} {Way} {Down} - {An} {Architecture} for {Dependently} {Typed} {Applications}},
	url = {https://www.idris-lang.org/drafts/sms.pdf},
	abstract = {A useful pattern in dependently typed programming is to de ne a state transition system, for example the states and
operations in a network protocol, as an indexed monad. We index each operation by its input and output states, thus
guaranteeing that operations satisfy pre- and post-conditions, by typechecking. However, what if we want to write a program
using several systems at once? What if we want to defne a high level state transition system, such as a network application
protocol, in terms of lower level states, such as network sockets and mutable variables?
In this paper, we present an architecture for dependently typed applications based on a hierarchy of state transition systems,
implemented in a generic data type ST. This is based on a monad indexed by contexts of resources, allowing us to reason
about multiple state transition systems in the type of a function. Using ST, we show: how to implement a state transition
system as a dependent type, with type level guarantees on its operations; how to account for operations which could fail;
how to combine state transition systems into a larger system; and, how to implement larger systems as a hierarchy of state
transition systems. We illustrate the system by implementing a number of examples, including a graphics API, POSIX network
sockets, asynchronous programming with threads, and a high level network application protocol.},
	urldate = {2018-04-24},
	author = {Brady, Edwin},
	year = {2016}
}

@inproceedings{fowler_dependent_2014,
	address = {New York, NY, USA},
	series = {{IFL} '13},
	title = {Dependent {Types} for {Safe} and {Secure} {Web} {Programming}},
	isbn = {978-1-4503-2988-0},
	url = {http://doi.acm.org/10.1145/2620678.2620683},
	doi = {10.1145/2620678.2620683},
	abstract = {Dependently-typed languages allow precise types to be used during development, facilitating static reasoning about program behaviour. However, with the use of more specific types comes the disadvantage that it becomes increasingly difficult to write programs that are accepted by a type checker, meaning additional proofs may have to be specified manually. Embedded domain-specific languages (EDSLs) can help address this problem by introducing a layer of abstraction over more precise underlying types, allowing domain-specific code to be written in a verified high-level language without imposing additional proof obligations on an application developer. In this paper, we apply this technique to web programming. Using the dependently typed programming language Idris, we show how to use EDSLs to enforce resource usage protocols associated with common web operations such as CGI, database access and session handling. We also introduce an EDSL which uses dependent types to facilitate the creation and handling of web forms, reducing the scope for programmer error and possible security implications.},
	urldate = {2018-04-24},
	booktitle = {Proceedings of the 25th {Symposium} on {Implementation} and {Application} of {Functional} {Languages}},
	publisher = {ACM},
	author = {Fowler, Simon and Brady, Edwin},
	year = {2014},
	keywords = {Verification, Dependent Types, Web Applications},
	pages = {49:49--49:60},
	file = {ACM Full Text PDF:/home/jonathan/Zotero/storage/8PSYAPNR/Fowler and Brady - 2014 - Dependent Types for Safe and Secure Web Programmin.pdf:application/pdf}
}

@inproceedings{altenkirch_pi_2010,
	address = {Berlin, Heidelberg},
	series = {{FLOPS}'10},
	title = {Pi {Sigma}: {Dependent} {Types} {Without} the {Sugar}},
	isbn = {978-3-642-12250-7},
	shorttitle = {\${\textbackslash}{Pi}\$\${\textbackslash}{Sigma}\$},
	url = {http://dx.doi.org/10.1007/978-3-642-12251-4_5},
	doi = {10.1007/978-3-642-12251-4_5},
	abstract = {The recent success of languages like Agda and Coq demonstrates the potential of using dependent types for programming. These systems rely on many high-level features like datatype definitions, pattern matching and implicit arguments to facilitate the use of the languages. However, these features complicate the metatheoretical study and are a potential source of bugs. To address these issues we introduce ΠΣ, a dependently typed core language. It is small enough for metatheoretical study and the type checker is small enough to be formally verified. In this language there is only one mechanism for recursion—used for types, functions and infinite objects—and an explicit mechanism to control unfolding, based on lifted types. Furthermore structural equality is used consistently for values and types; this is achieved by a new notion of α-equality for recursive definitions. We show, by translating several high-level constructions, that ΠΣ is suitable as a core language for dependently typed programming.},
	urldate = {2018-01-11},
	booktitle = {Proceedings of the 10th {International} {Conference} on {Functional} and {Logic} {Programming}},
	publisher = {Springer-Verlag},
	author = {Altenkirch, Thorsten and Danielsson, Nils Anders and Loeh, Andres and Oury, Nicolas},
	year = {2010},
	pages = {40--55}
}

@inproceedings{perez_functional_2016,
	address = {New York, NY, USA},
	series = {Haskell 2016},
	title = {Functional {Reactive} {Programming}, {Refactored}},
	isbn = {978-1-4503-4434-0},
	url = {http://doi.acm.org/10.1145/2976002.2976010},
	doi = {10.1145/2976002.2976010},
	abstract = {Functional Reactive Programming (FRP) has come to mean many things. Yet, scratch the surface of the multitude of realisations, and there is great commonality between them. This paper investigates this commonality, turning it into a mathematically coherent and practical FRP realisation that allows us to express the functionality of many existing FRP systems and beyond by providing a minimal FRP core parameterised on a monad. We give proofs for our theoretical claims and we have verified the practical side by benchmarking a set of existing, non-trivial Yampa applications running on top of our new system with very good results.},
	urldate = {2016-12-19},
	booktitle = {Proceedings of the 9th {International} {Symposium} on {Haskell}},
	publisher = {ACM},
	author = {Perez, Ivan and Baerenz, Manuel and Nilsson, Henrik},
	year = {2016},
	keywords = {Haskell, monadic streams, stream programming, Functional Reactive Programming, reactive program- ming},
	pages = {33--44},
	file = {ACM Full Text PDF:/home/jonathan/Zotero/storage/CU7HCWAC/Perez et al. - 2016 - Functional Reactive Programming, Refactored.pdf:application/pdf;ACM Full Text PDF:/home/jonathan/Zotero/storage/P6DGWVUG/Perez et al. - 2016 - Functional Reactive Programming, Refactored.pdf:application/pdf;ACM Full Text PDF:/home/jonathan/Zotero/storage/IIQ3I92S/Perez et al. - 2016 - Functional Reactive Programming, Refactored.pdf:application/pdf}
}

@phdthesis{bezirgiannis_improving_2013,
	title = {Improving {Performance} of {Simulation} {Software} {Using} {Haskells} {Concurrency} \& {Parallelism}},
	school = {Utrecht University - Dept. of Information and Computing Sciences},
	author = {Bezirgiannis, Nikolaos},
	year = {2013}
}

@inproceedings{meyer_event-driven_2014,
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Event-{Driven} {Multi}-agent {Simulation}},
	isbn = {978-3-319-14626-3 978-3-319-14627-0},
	url = {https://link.springer.com/chapter/10.1007/978-3-319-14627-0_1},
	doi = {10.1007/978-3-319-14627-0_1},
	abstract = {Most agent-based models today apply a time-driven approach, i.e. simulation time is advanced in equidistant steps. This time advance method is considerably easier to implement than the more flexible and efficient event-driven approach.Applying the event-driven approach requires that (a) the durations for agent and environment actions are determined before they terminate, (b) each agent is able to instantly react to changes in its environment, and (c) the update of the state of the environment can be kept efficient despite updating agents asynchronously.The simulation toolkit famos fulfils these requirements, extending an existing discrete-event simulator. The toolkit also supports a flexible representation of space and the movement of agents in that space. These are areas where existing toolkits for agent-based modelling show shortcomings, despite the fact that a majority of multi-agent models explicitly model space and allow for mobile agents.},
	language = {en},
	urldate = {2018-02-13},
	booktitle = {Multi-{Agent}-{Based} {Simulation} {XV}},
	publisher = {Springer, Cham},
	author = {Meyer, Ruth},
	month = may,
	year = {2014},
	pages = {3--16},
	file = {Snapshot:/home/jonathan/Zotero/storage/RGMQKZE9/978-3-319-14627-0_1.html:text/html}
}

@book{north_managing_2007,
	title = {Managing {Business} {Complexity}: {Discovering} {Strategic} {Solutions} with {Agent}-{Based} {Modeling} and {Simulation}},
	isbn = {978-0-19-517211-9},
	shorttitle = {Managing {Business} {Complexity}},
	abstract = {Agent-based modeling and simulation (ABMS), a way to simulate a large number of choices by individual actors, is one of the most exciting practical developments in business modeling since the invention of relational databases. It represents a new way to understand data and generate information that has never been available before--a way for businesses to view the future and to understand and anticipate the likely effects of their decisions on their markets and industries. It thus promises to have far-reaching effects on the way that businesses in many areas use computers to support practical decision-making.Managing Business Complexity is the first complete business-oriented agent-based modeling and simulation resource. It has three purposes: first, to teach readers how to think about ABMS, that is, about agents and their interactions; second, to teach readers how to explain the features and advantages of ABMS to other people and third, to teach readers how to actually implement ABMS by building agent-based simulations. It is intended to be a complete ABMS resource, accessible to readers who haven't had any previous experience in building agent-based simulations, or any other kinds of models, for that matter. It is also a collection of ABMS business applications resources, all assembled in one place for the first time. In short, Managing Business Complexity addresses who needs ABMS and why, where and when ABMS can be applied to the everyday business problems that surround us, and how specifically to build these powerful agent-based models.},
	language = {en},
	publisher = {Oxford University Press, USA},
	author = {North, Michael J. and Macal, Charles M.},
	month = mar,
	year = {2007},
	note = {Google-Books-ID: gRATDAAAQBAJ},
	keywords = {Business \& Economics / Decision-Making \& Problem Solving, Business \& Economics / Management Science}
}

@article{macal_everything_2016,
	title = {Everything you need to know about agent-based modelling and simulation},
	volume = {10},
	issn = {1747-7778, 1747-7786},
	url = {https://link.springer.com/article/10.1057/jos.2016.7},
	doi = {10.1057/jos.2016.7},
	abstract = {This paper addresses the background and current state of the field of agent-based modelling and simulation (ABMS). It revisits the issue of ABMS represents as a new development, considering the extremes of being an overhyped fad, doomed to disappear, or a revolutionary development, shifting fundamental paradigms of how research is conducted. This paper identifies key ABMS resources, publications, and communities. It also proposes several complementary definitions for ABMS, based on practice, intended to establish a common vocabulary for understanding ABMS, which seems to be lacking. It concludes by suggesting research challenges for ABMS to advance and realize its potential in the coming years.},
	language = {en},
	number = {2},
	urldate = {2018-02-09},
	journal = {Journal of Simulation},
	author = {Macal, C. M.},
	month = may,
	year = {2016},
	pages = {144--156},
	file = {Snapshot:/home/jonathan/Zotero/storage/TI6F7ZIL/jos.2016.html:text/html}
}

@inproceedings{brady_programming_2013,
	address = {New York, NY, USA},
	series = {{ICFP} '13},
	title = {Programming and {Reasoning} with {Algebraic} {Effects} and {Dependent} {Types}},
	isbn = {978-1-4503-2326-0},
	url = {http://doi.acm.org/10.1145/2500365.2500581},
	doi = {10.1145/2500365.2500581},
	abstract = {One often cited benefit of pure functional programming is that pure code is easier to test and reason about, both formally and informally. However, real programs have side-effects including state management, exceptions and interactions with the outside world. Haskell solves this problem using monads to capture details of possibly side-effecting computations --- it provides monads for capturing state, I/O, exceptions, non-determinism, libraries for practical purposes such as CGI and parsing, and many others, as well as monad transformers for combining multiple effects. Unfortunately, useful as monads are, they do not compose very well. Monad transformers can quickly become unwieldy when there are lots of effects to manage, leading to a temptation in larger programs to combine everything into one coarse-grained state and exception monad. In this paper I describe an alternative approach based on handling algebraic effects, implemented in the IDRIS programming language. I show how to describe side effecting computations, how to write programs which compose multiple fine-grained effects, and how, using dependent types, we can use this approach to reason about states in effectful programs.},
	urldate = {2018-02-02},
	booktitle = {Proceedings of the 18th {ACM} {SIGPLAN} {International} {Conference} on {Functional} {Programming}},
	publisher = {ACM},
	author = {Brady, Edwin},
	year = {2013},
	keywords = {dependent types, algebraic effects},
	pages = {133--144},
	file = {ACM Full Text PDF:/home/jonathan/Zotero/storage/R5HBK998/Brady - 2013 - Programming and Reasoning with Algebraic Effects a.pdf:application/pdf}
}

@article{brady_idris_2013,
	title = {Idris, a general-purpose dependently typed programming language: {Design} and implementation},
	volume = {23},
	issn = {1469-7653},
	url = {http://journals.cambridge.org/article_S095679681300018X},
	doi = {10.1017/S095679681300018X},
	number = {05},
	journal = {Journal of Functional Programming},
	author = {Brady, Edwin},
	year = {2013},
	pages = {552--593}
}

@phdthesis{perez_extensible_2017,
	address = {Nottingham},
	type = {Doctoral {Thesis}},
	title = {Extensible and {Robust} {Functional} {Reactive} {Programming}},
	language = {English},
	school = {University Of Nottingham},
	author = {Perez, Ivan},
	month = oct,
	year = {2017}
}

@book{payne_social_2019,
	series = {Springer {Proceedings} in {Complexity}},
	title = {Social {Simulation} for a {Digital} {Society}: {Applications} and {Innovations} in {Computational} {Social} {Science}},
	isbn = {978-3-030-30297-9},
	shorttitle = {Social {Simulation} for a {Digital} {Society}},
	url = {https://www.springer.com/gp/book/9783030302979},
	abstract = {“Social Simulation for a Digital Society” provides a cross-section of state-of-the-art research in social simulation and computational social science. With the availability of big data and faster computing power, the social sciences are undergoing a tremendous transformation. Research in computational social sciences has received considerable attention in the last few years, with advances in a wide range of methodologies and applications. Areas of application of computational methods range from the study of opinion and information dynamics in social networks, the formal modeling of resource use, the study of social conflict and cooperation to the development of cognitive models for social simulation and many more. This volume is based on the Social Simulation Conference of 2017 in Dublin and includes applications from across the social sciences, providing the reader with a demonstration of the highly versatile research in social simulation, with a particular focus on public policy relevance in a digital society. Chapters in the book include contributions to the methodology of simulation-based research, theoretical and philosophical considerations, as well as applied work. This book will appeal to students and researchers in the field.},
	language = {en},
	urldate = {2019-10-12},
	publisher = {Springer International Publishing},
	editor = {Payne, Diane and Elkink, Jos and Friel, Nial and Grund, Thomas and Hochstrasser, Tamara and Lucas, Pablo and Ottewill, Adrian},
	year = {2019},
	file = {Snapshot:/home/jonathan/Zotero/storage/A9NX4EP2/9783030302979.html:text/html}
}

@misc{diehl_wishknewhaskell,
	title = {What {I} {W}ish {I} {K}new {W}hen {L}earning {H}askell},
	url = {http://dev.stephendiehl.com/hask/},
	howpublished = {\url{http://dev.stephendiehl.com/hask/}},
	language = {English},
	author = {Diehl, S.},
	month = Mar,
	year = {2016},
	note = {Last Access October 11, 2019}
}

@inproceedings{hanenberg_experiment_2010,
	address = {New York, NY, USA},
	series = {{OOPSLA} '10},
	title = {An {Experiment} {About} {Static} and {Dynamic} {Type} {Systems}: {Doubts} {About} the {Positive} {Impact} of {Static} {Type} {Systems} on {Development} {Time}},
	isbn = {978-1-4503-0203-6},
	shorttitle = {An {Experiment} {About} {Static} and {Dynamic} {Type} {Systems}},
	url = {http://doi.acm.org/10.1145/1869459.1869462},
	doi = {10.1145/1869459.1869462},
	abstract = {Although static type systems are an essential part in teach-ing and research in software engineering and computer science, there is hardly any knowledge about what the impact of static type systems on the development time or the resulting quality for a piece of software is. On the one hand there are authors that state that static type systems decrease an application's complexity and hence its development time (which means that the quality must be improved since developers have more time left in their projects). On the other hand there are authors that argue that static type systems increase development time (and hence decrease the code quality) since they restrict developers to express themselves in a desired way. This paper presents an empirical study with 49 subjects that studies the impact of a static type system for the development of a parser over 27 hours working time. In the experiments the existence of the static type system has neither a positive nor a negative impact on an application's development time (under the conditions of the experiment).},
	urldate = {2019-05-03},
	booktitle = {Proceedings of the {ACM} {International} {Conference} on {Object} {Oriented} {Programming} {Systems} {Languages} and {Applications}},
	publisher = {ACM},
	author = {Hanenberg, Stefan},
	year = {2010},
	note = {event-place: Reno/Tahoe, Nevada, USA},
	keywords = {programming languages, dynamically typed languages, empirical study, type systems},
	pages = {22--35}
}

@inproceedings{thaler_art_2017,
	address = {Dublin, Ireland},
	series = {Springer {Proceedings} in {Complexity}},
	title = {The {Art} {Of} {Iterating}: {Update}-{Strategies} in {Agent}-{Based}},
	isbn = {978-3-030-30297-9},
	shorttitle = {Social {Simulation} for a {Digital} {Society}},
	url = {https://www.springer.com/gp/book/9783030302979},
	abstract = {When developing a model for an Agent-Based Simulation (ABS) it is very important to select the update-strategy which reflects the semantics of the model as simulation results can vary vastly across different update-strategies. This awareness, we claim, is still underdeveloped in the majority of the field of ABS. In this paper we propose a new terminology to classify update strategies and then identify different strategies using this terminology. This will allow implementers and researchers in this field to use a general terminology, removing ambiguities when discussing ABS and their models. We will give results of simulating a discrete and a continuous game using our update-strategies and show that in the case of the discrete game only one specific strategy seems to be able to produce its emergent patterns whereas the pattern of the continuous game seems to be robust under varying update-strategies.},
	language = {en},
	author = {Thaler, Jonathan and Siebers, Peer-Olaf},
	month = sep,
	urldate = {2019-10-12},
	publisher = {Springer International Publishing},
	editor = {Payne, Diane and Elkink, Jos and Friel, Nial and Grund, Thomas and Hochstrasser, Tamara and Lucas, Pablo and Ottewill, Adrian},
	year = {2019},
	file = {Snapshot:/home/jonathan/Zotero/storage/A9NX4EP2/9783030302979.html:text/html}
}

@inproceedings{thaler_pure_2018,
	address = {New York, NY, USA},
	series = {{IFL} 2018},
	title = {Pure {Functional} {Epidemics}: {An} {Agent}-{Based} {Approach}},
	isbn = {978-1-4503-7143-8},
	shorttitle = {Pure {Functional} {Epidemics}},
	url = {http://doi.acm.org/10.1145/3310232.3310372},
	doi = {10.1145/3310232.3310372},
	abstract = {Agent-Based Simulation (ABS) is a methodology in which a system is simulated in a bottom-up approach by modelling the micro interactions of its constituting parts, called agents, out of which the global system behaviour emerges. So far mainly object-oriented techniques and languages have been used in ABS. Using the SIR model of epidemiology, which simulates the spreading of an infectious disease through a population, we demonstrate how to use pure Functional Reactive Programming to implement ABS. With our approach we can guarantee the reproducibility of the simulation at compile time and rule out specific classes of run-time bugs, something that is not possible with traditional object-oriented languages. Also, we found that the representation in a purely functional format is conceptually quite elegant and opens the way to formally reason about ABS.},
	urldate = {2019-05-03},
	booktitle = {Proceedings of the 30th {Symposium} on {Implementation} and {Application} of {Functional} {Languages}},
	publisher = {ACM},
	author = {Thaler, Jonathan and Altenkirch, Thorsten and Siebers, Peer-Olaf},
	year = {2018},
	note = {event-place: Lowell, MA, USA},
	keywords = {Functional Reactive Programming, Agent-Based Simulation, Monadic Stream Functions},
	pages = {1--12},
	file = {Submitted Version:/home/jonathan/Zotero/storage/WL2PCIGX/Thaler et al. - 2018 - Pure Functional Epidemics An Agent-Based Approach.pdf:application/pdf}
}

@incollection{wald_sequential_1992,
	address = {New York, NY},
	series = {Springer {Series} in {Statistics}},
	title = {Sequential {Tests} of {Statistical} {Hypotheses}},
	isbn = {978-1-4612-0919-5},
	url = {https://doi.org/10.1007/978-1-4612-0919-5\_18},
	abstract = {By a sequential test of a statistical hypothesis is meant any statistical test procedure which gives a specific rule, at any stage of the experiment (at the n-th trial for each integral value of n), for making one of the following three decisions: (1) to accept the hypothesis being tested (null hypothesis), (2) to reject the null hypothesis, (3) to continue the experiment by making an additional observation. Thus, such a test procedure is carried out sequentially. On the basis of the first trial, one of the three decisions mentioned above is made. If the first or the second decision is made, the process is terminated. If the third decision is made, a second trial is performed. Again on the basis of the first two trials one of the three decisions is made and if the third decision is reached a third trial is performed, etc. This process is continued until either the first or the second decision is made.},
	language = {en},
	urldate = {2019-05-03},
	booktitle = {Breakthroughs in {Statistics}: {Foundations} and {Basic} {Theory}},
	publisher = {Springer New York},
	author = {Wald, A.},
	editor = {Kotz, Samuel and Johnson, Norman L.},
	year = {1992},
	doi = {10.1007/978-1-4612-0919-5\_18},
	keywords = {Moment Generate Function, Powerful Test, Sequential Probability Ratio Test, Sequential Test, Statistical Hypothesis},
	pages = {256--298}
}

@incollection{kiselyov_typed_2012,
	address = {Berlin, Heidelberg},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Typed {Tagless} {Final} {Interpreters}},
	isbn = {978-3-642-32202-0},
	url = {https://doi.org/10.1007/978-3-642-32202-0_3},
	abstract = {The so-called ‘typed tagless final’ approach of [6] has collected and polished a number of techniques for representing typed higher-order languages in a typed metalanguage, along with type-preserving interpretation, compilation and partial evaluation. The approach is an alternative to the traditional, or ‘initial’ encoding of an object language as a (generalized) algebraic data type. Both approaches permit multiple interpretations of an expression, to evaluate it, pretty-print, etc. The final encoding represents all and only typed object terms without resorting to generalized algebraic data types, dependent or other fancy types. The final encoding lets us add new language forms and interpretations without breaking the existing terms and interpreters.These lecture notes introduce the final approach slowly and in detail, highlighting extensibility, the solution to the expression problem, and the seemingly impossible pattern-matching. We develop the approach further, to type-safe cast, run-time-type representation, Dynamics, and type reconstruction. We finish with telling examples of type-directed partial evaluation and encodings of type-and-effect systems and linear lambda-calculus.},
	language = {en},
	urldate = {2019-05-08},
	booktitle = {Generic and {Indexed} {Programming}: {International} {Spring} {School}, {SSGIP} 2010, {Oxford}, {UK}, {March} 22-26, 2010, {Revised} {Lectures}},
	publisher = {Springer Berlin Heidelberg},
	author = {Kiselyov, Oleg},
	editor = {Gibbons, Jeremy},
	year = {2012},
	doi = {10.1007/978-3-642-32202-0_3},
	keywords = {Denotational Semantic, Expression Problem, Object Term, Sample Term, Type Checker},
	pages = {130--174},
	file = {Springer Full Text PDF:/home/jonathan/Zotero/storage/JXZ9NCQX/Kiselyov - 2012 - Typed Tagless Final Interpreters.pdf:application/pdf}
}

@article{rivas_notions_2014,
	title = {Notions of {Computation} as {Monoids}},
	url = {http://arxiv.org/abs/1406.4823},
	abstract = {There are different notions of computation, the most popular being monads, applicative functors, and arrows. In this article we show that these three notions can be seen as monoids in a monoidal category. We demonstrate that at this level of abstraction one can obtain useful results which can be instantiated to the different notions of computation. In particular, we show how free constructions and Cayley representations for monoids translate into useful constructions for monads, applicative functors, and arrows. Moreover, the uniform presentation of all three notions helps in the analysis of the relation between them.},
	urldate = {2019-05-08},
	journal = {arXiv:1406.4823 [cs, math]},
	author = {Rivas, Exequiel and Jaskelioff, Mauro},
	month = may,
	year = {2014},
	note = {arXiv: 1406.4823},
	keywords = {Mathematics - Category Theory, Computer Science - Programming Languages, Computer Science - Logic in Computer Science},
	file = {arXiv\:1406.4823 PDF:/home/jonathan/Zotero/storage/PQG7QFPU/Rivas and Jaskelioff - 2014 - Notions of Computation as Monoids.pdf:application/pdf}
}

@inproceedings{marlow_monad_2011,
	address = {New York, NY, USA},
	series = {Haskell '11},
	title = {A {Monad} for {Deterministic} {Parallelism}},
	isbn = {978-1-4503-0860-1},
	url = {http://doi.acm.org/10.1145/2034675.2034685},
	doi = {10.1145/2034675.2034685},
	abstract = {We present a new programming model for deterministic parallel computation in a pure functional language. The model is monadic and has explicit granularity, but allows dynamic construction of dataflow networks that are scheduled at runtime, while remaining deterministic and pure. The implementation is based on monadic concurrency, which has until now only been used to simulate concurrency in functional languages, rather than to provide parallelism. We present the API with its semantics, and argue that parallel execution is deterministic. Furthermore, we present a complete work-stealing scheduler implemented as a Haskell library, and we show that it performs at least as well as the existing parallel programming models in Haskell.},
	urldate = {2019-05-12},
	booktitle = {Proceedings of the 4th {ACM} {Symposium} on {Haskell}},
	publisher = {ACM},
	author = {Marlow, Simon and Newton, Ryan and Peyton Jones, Simon},
	year = {2011},
	note = {event-place: Tokyo, Japan},
	keywords = {parallel, haskell},
	pages = {71--82}
}

@inproceedings{coutts_stream_2007,
	title = {Stream {Fusion}. {From} {Lists} to {Streams} to {Nothing} at {All}},
	abstract = {This paper presents an automatic deforestation system, stream fusion, based on equational transformations, that fuses a wider range of functions than existing short-cut fusion systems. In particular, stream fusion is able to fuse zips, left folds and functions over nested lists, including list comprehensions. A distinguishing feature of the framework is its simplicity: by transforming list functions to expose their structure, intermediate values are eliminated by general purpose compiler optimisations. We have reimplemented the Haskell standard List library on top of our framework, providing stream fusion for Haskell lists. By allowing a wider range of functions to fuse, we see an increase in the number of occurrences of fusion in typical Haskell programs. We present benchmarks documenting time and space improvements.},
	booktitle = {Icfp’07},
	author = {Coutts, Duncan and Leshchinskiy, Roman and Stewart, Don},
	year = {2007},
	file = {Citeseer - Full Text PDF:/home/jonathan/Zotero/storage/2XVT2RTS/Coutts et al. - 2007 - Stream Fusion. From Lists to Streams to Nothing at.pdf:application/pdf;Citeseer - Snapshot:/home/jonathan/Zotero/storage/F2DUI8T4/summary.html:text/html}
}

@misc{mainland_haskell_2013,
	title = {Haskell Beats C Using Generalized Stream Fusion},
	url = {https://www.semanticscholar.org/paper/Haskell-Beats-C-Using-Generalized-Stream-Fusion-Mainland/0ccaa4e306398ef7225e49b01cc5e0c16c94aac7},
	howpublished = {\url{https://www.semanticscholar.org/paper/Haskell-Beats-C-Using-Generalized-Stream-Fusion-Mainland/0ccaa4e306398ef7225e49b01cc5e0c16c94aac7}},
	language = {English},
	author = {Mainland, Geoffrey},
	year = {2013},
	note = {Last Access October 11, 2019}
}

@misc{stolarek_haskell_2013,
	title = {Haskell as fast as {C}: {A} case study},
	url = {http://lambda.jstolarek.com/2013/04/haskell-as-fast-as-c-a-case-study/},
	howpublished = {\url{http://lambda.jstolarek.com/2013/04/haskell-as-fast-as-c-a-case-study/}},
	language = {English},
	author = {Stolarek, J.},
	month = apr,
	year = {2013},
	note = {Last Access October 11, 2019}
}

@misc{kqr_competing_2017,
	title = {On {C}ompeting with {C} {U}sing {H}askell},
	url = {https://two-wrongs.com/on-competing-with-c-using-haskell},
	howpublished = {\url{https://two-wrongs.com/on-competing-with-c-using-haskell}},
	language = {English},
	author = {kqr, Chris},
	month = jun,
	year = {2017},
	note = {Last Access October 11, 2019}
}

@misc{stewart_haskell_2008,
	title = {Haskell as fast as {C}: working at a high altitude for low level performance},
	url = {https://donsbot.wordpress.com/2008/06/04/haskell-as-fast-as-c-working-at-a-high-altitude-for-low-level-performance/},
	howpublished = {\url{https://donsbot.wordpress.com/2008/06/04/haskell-as-fast-as-c-working-at-a-high-altitude-for-low-level-performance/}},
	author = {Stewart, D.},
	month = apr,
	year = {2008},
	note = {Last Access October 11, 2019}
}


@article{gill_worker/wrapper_2009,
	title = {The {Worker}/{Wrapper} {Transformation}},
	volume = {19},
	issn = {0956-7968},
	url = {http://dx.doi.org/10.1017/S0956796809007175},
	doi = {10.1017/S0956796809007175},
	abstract = {The worker/wrapper transformation is a technique for changing the type of a computation, usually with the aim of improving its performance. It has been used by compiler writers for many years, but the technique is little known in the wider functional programming community, and has never been described precisely. In this article we explain, formalise and explore the generality of the worker/wrapper transformation. We also provide a systematic recipe for its use as an equational reasoning technique for improving the performance of programs, and illustrate the power of this recipe using a range of examples.},
	number = {2},
	urldate = {2019-05-14},
	journal = {J. Funct. Program.},
	author = {Gill, Andy and Hutton, Graham},
	month = mar,
	year = {2009},
	pages = {227--251},
	file = {Submitted Version:/home/jonathan/Zotero/storage/WEQYMKIJ/Gill and Hutton - 2009 - The WorkerWrapper Transformation.pdf:application/pdf}
}

@inproceedings{jones_functional_1995,
	address = {Berlin, Heidelberg},
	title = {Functional {Programming} with {Overloading} and {Higher}-{Order} {Polymorphism}},
	isbn = {978-3-540-59451-2},
	url = {http://dl.acm.org/citation.cfm?id=647698.734150},
	urldate = {2019-05-15},
	booktitle = {Advanced {Functional} {Programming}, {First} {International} {Spring} {School} on {Advanced} {Functional} {Programming} {Techniques}-{Tutorial} {Text}},
	publisher = {Springer-Verlag},
	author = {Jones, Mark P.},
	year = {1995},
	pages = {97--136}
}

@inproceedings{kay_early_1993,
	address = {New York, NY, USA},
	series = {{HOPL}-{II}},
	title = {The {Early} {History} of {Smalltalk}},
	isbn = {978-0-89791-570-0},
	url = {http://doi.acm.org/10.1145/154766.155364},
	doi = {10.1145/154766.155364},
	abstract = {Most ideas come from previous ideas. The sixties, particularly in the ARPA community, gave rise to a host of notions about “human-computer symbiosis” through interactive time-shared computers, graphics screens and pointing devices. Advanced computer languages were invented to simulate complex systems such as oil refineries and semi-intelligent behavior. The soon to follow paradigm shift of modern personal computing, overlapping window interfaces, and object-oriented design came from seeing the work of the sixties as something more than a “better old thing”. That is, more than a better way: to do mainframe computing; for end-users to invoke functionality; to make data structures more abstract. Instead the promise of exponential growth in computing/\$/volume demanded that the sixties be regarded as “almost a new thing” and to find out what the actual “new things” might be. For example, one would compute with a handheld “Dynabook” in a way that would not be possible on a shared mainframe; millions of potential users meant that the user interface would have to become a learning environment along the lines of Montessori and Bruner; and needs for large scope, reduction in complexity, and end-user literacy would require that data and control structures be done away with in favor of a more biological scheme of protected universal cells interacting only through messages that could mimic any desired behavior.
Early Smalltalk was the first complete realization of these new points of view as parented by its many predecessors in hardware, language and user interface design. It became the exemplar of the new computing, in part, because we were actually trying for a qualitative shift in belief structures—a new Kuhnian paradigm in the same spirit as the invention of the printing press—and thus took highly extreme positions which almost forced these new styles to be invented.},
	urldate = {2019-05-16},
	booktitle = {The {Second} {ACM} {SIGPLAN} {Conference} on {History} of {Programming} {Languages}},
	publisher = {ACM},
	author = {Kay, Alan C.},
	year = {1993},
	note = {event-place: Cambridge, Massachusetts, USA},
	pages = {69--95},
	file = {ACM Full Text PDF:/home/jonathan/Zotero/storage/2PU44SDR/Kay - 1993 - The Early History of Smalltalk.pdf:application/pdf}
}

@book{jacobs_introduction_2017,
	title = {Introduction to {Coalgebra}},
	isbn = {978-1-107-17789-5},
	abstract = {The area of coalgebra has emerged within theoretical computer science with a unifying claim: to be the mathematics of computational dynamics. It combines ideas from the theory of dynamical systems and from the theory of state-based computation. Although still in its infancy, it is an active area of research that generates wide interest. Written by one of the founders of the field, this book acts as the first mature and accessible introduction to coalgebra. It provides clear mathematical explanations, with many examples and exercises involving deterministic and non-deterministic automata, transition systems, streams, Markov chains and weighted automata. The theory is expressed in the language of category theory, which provides the right abstraction to make the similarity and duality between algebra and coalgebra explicit, and which the reader is introduced to in a hands-on manner. The book will be useful to mathematicians and (theoretical) computer scientists and will also be of interest to mathematical physicists, biologists and economists.},
	language = {en},
	publisher = {Cambridge University Press},
	author = {Jacobs, Bart},
	year = {2017},
	note = {Google-Books-ID: tApQDQAAQBAJ},
	keywords = {Mathematics / Probability \& Statistics / General, Mathematics / Logic, Mathematics / Group Theory, Mathematics / Discrete Mathematics, Science / Physics / Mathematical \& Computational}
}

@article{jacobs_tutorial_1997,
	title = {A {Tutorial} on ({Co}){Algebras} and ({Co}){Induction}},
	volume = {62},
	abstract = {. Algebraic structures which are generated by a collection of constructors--- like natural numbers (generated by a zero and a successor) or finite lists and trees--- are of well-established importance in computer science. Formally, they are initial algebras. Induction is used both as a definition principle, and as a proof principle for such structures. But there are also important dual "coalgebraic" structures, which do not come equipped with constructor operations but with what are sometimes called "destructor" operations (also called observers, accessors, transition maps, or mutators). Spaces of infinite data (including, for example, infinite lists, and non-well-founded sets) are generally of this kind. In general, dynamical systems with a hidden, black-box state space, to which a user only has limited access via specified (observer or mutator) operations, are coalgebras of various kinds. Such coalgebraic systems are common in computer science. And "coinduction" is the appropriate te...},
	journal = {EATCS Bulletin},
	author = {Jacobs, Bart and Rutten, Jan},
	year = {1997},
	pages = {62--222},
	file = {Citeseer - Full Text PDF:/home/jonathan/Zotero/storage/D6J8V9ZD/Jacobs and Rutten - 1997 - A Tutorial on (Co)Algebras and (Co)Induction.pdf:application/pdf;Citeseer - Snapshot:/home/jonathan/Zotero/storage/K4D8V2YW/summary.html:text/html}
}

@inproceedings{downen_codata_2019,
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Codata in {Action}},
	isbn = {978-3-030-17184-1},
	abstract = {Computer scientists are well-versed in dealing with data structures. The same cannot be said about their dual: codata. Even though codata is pervasive in category theory, universal algebra, and logic, the use of codata for programming has been mainly relegated to representing infinite objects and processes. Our goal is to demonstrate the benefits of codata as a general-purpose programming abstraction independent of any specific language: eager or lazy, statically or dynamically typed, and functional or object-oriented. While codata is not featured in many programming languages today, we show how codata can be easily adopted and implemented by offering simple inter-compilation techniques between data and codata. We believe codata is a common ground between the functional and object-oriented paradigms; ultimately, we hope to utilize the Curry-Howard isomorphism to further bridge the gap.},
	language = {en},
	booktitle = {Programming {Languages} and {Systems}},
	publisher = {Springer International Publishing},
	author = {Downen, Paul and Sullivan, Zachary and Ariola, Zena M. and Peyton Jones, Simon},
	editor = {Caires, Luís},
	year = {2019},
	keywords = {Codata, Curry-Howard, Encodings, Function programming, Lambda-calculi, Object-oriented programming},
	pages = {119--146},
	file = {Springer Full Text PDF:/home/jonathan/Zotero/storage/FZAHX8UL/Downen et al. - 2019 - Codata in Action.pdf:application/pdf}
}

@article{jacobs_coalgebras_2003,
	title = {Coalgebras and {Monads} in the {Semantics} of {Java}},
	volume = {291},
	issn = {0304-3975},
	url = {http://dx.doi.org/10.1016/S0304-3975(02)00366-3},
	doi = {10.1016/S0304-3975(02)00366-3},
	abstract = {This paper describes the basic structures in the denotational and axiomatic semantics of sequential Java, both from a monadic and a coalgebraic perspective. This semantics is an abstraction of the one used for the verification of (sequential) Java programs using proof tools in the LOOP project at the University of Nijmegen. It is shown how the monadic perspective gives rise to the relevant computational structure in Java (composition, extension and repetition), and how the coalgebraic perspective offers an associated program logic (with invariants, bisimulations, and Hoare logics) for reasoning about the computational structure provided by the monad.},
	number = {3},
	urldate = {2019-07-07},
	journal = {Theor. Comput. Sci.},
	author = {Jacobs, Bart and Poll, Erik},
	month = jan,
	year = {2003},
	keywords = {monad, coalgebra, java},
	pages = {329--349}
}

@book{martin-lof_intuitionistic_1972,
	title = {An intuitionistic theory of types},
	abstract = {An earlier, not yet conclusive, attempt at formulating a theory of this kind was made by Scott 1970. Also related, although less closely, are the type and logic free theories of constructions of Kreisel 1962 and 1965 and Goodman 1970. In its first version, the present theory was based on the strongly impredicative axiom that there is a type of all types whatsoever, which is at the same time a type and an object of that type. This axiom had to be abandoned, however, after it was shown to lead to a contradiction by Jean Yves Girard. I am very grateful to him for showing me his paradox. The change that it necessitated is so drastic that my theory no longer contains intuitionistic simple type theory as it originally did. Instead, its proof theoretic strength should be close to that of predicative analysis.},
	author = {Martin-Löf, Per},
	year = {1972},
	file = {Citeseer - Full Text PDF:/home/jonathan/Zotero/storage/SDQL3INT/Martin-Löf - An intuitionistic theory of types.pdf:application/pdf;Citeseer - Snapshot:/home/jonathan/Zotero/storage/AN4U88MX/summary.html:text/html}
}

@inproceedings{thaler_agents_2019,
	address = {Berlin},
	title = {The agents new cloth? {Towards} {Pure} {Functional} {Programming} in {ABS}.},
	abstract = {The established approach to implement and engineer Agent-Based Simulations (ABS) has primarily been object-oriented, with Python and Java being the most popular languages. In this paper we explore a different approach to this problem and investigate the pure functional programming paradigm, using the language Haskell. We give a high level introduction into the core features of pure functional programming and show how they can be made of use to implement ABS in a case-study of a full implementation of the seminal Sugarscape model. With this case-study we are able to show that pure functional programming as in Haskell has a valid place in building clean, robust and maintainable ABS implementations. Further we show that we can directly leverage the benefits of pure functional programming to ABS: we have strong guarantees of reproducibility at compile time, can easily exploit data-parallelism and concurrency is easier to get right. The main drawback is a lower performance than established performances but this was not the main focus of research and we hope to improve on this in the future.},
	series = {Submitted to {S}ummer {S}imulation 2019},
	author = {Thaler, Jonathan and Siebers, Peer-Olaf},
	month = jul,
	year = {2019}
}

@inproceedings{thaler_show_2019,
 author = {Thaler, Jonathan and Siebers, Peer-Olaf},
 title = {Show Me Your Properties: The Potential of Property-based Testing in Agent-based Simulation},
 booktitle = {Proceedings of the 2019 Summer Simulation Conference},
 series = {SummerSim '19},
 year = {2019},
 location = {Berlin, Germany},
 pages = {1:1--1:12},
 articleno = {1},
 numpages = {12},
 url = {http://dl.acm.org/citation.cfm?id=3374138.3374139},
 acmid = {3374139},
 publisher = {Society for Computer Simulation International},
 address = {San Diego, CA, USA},
 keywords = {Haskell, agent-based simulation, property-based testing, validation \&\#38; verification}
}

@article{thaler_tale_2018,
	title = {A {Tale} {Of} {Lock}-{Free} {Agents}: {Towards} {Software} {Transactional} {Memory} in parallel {Agent}-{Based} {Simulation}},
	language = {English},
	journal = {Complex Adaptive Systems Modeling},
	author = {Thaler, Jonathan and Siebers, Peer-Olaf},
	month = dec,
	year = {2019},
	pages = {25},
	doi = {10.1186/s40294-019-0067-9}
}

@misc{thaler_sugarscape_repository,
	title = {Repository of {S}ugarscape implementation in {H}askell},
	url = {https://github.com/thalerjonathan/haskell-sugarscape},
	howpublished = {\url{https://github.com/thalerjonathan/haskell-sugarscape}},
	language = {English},
	author = {Thaler, J.},
	month = May,
	year = {2019},
	note = {Last Access October 11, 2019}
}

@misc{thaler_sir_repository,
	title = {Repository of Agent-Based {SIR} implementation in {H}askell},
	url = {https://github.com/thalerjonathan/haskell-sir},
	howpublished = {\url{https://github.com/thalerjonathan/haskell-sir}},
	language = {English},
	author = {Thaler, J.},
	month = May,
	year = {2019},
	note = {Last Access October 11, 2019}
}

@misc{gintis_herbert_website,
	title = {Herbert {G}intis {W}ebsite},
	url = {https://people.umass.edu/gintis/},
	howpublished = {\url{https://people.umass.edu/gintis/}},
	language = {English},
	author = {Gintis, H.},
	year = {2019},
	note = {Last Access October 11, 2019}
}

@inproceedings{harris_transactional_2006,
	title = {Transactional memory with data invariants},
	url = {https://www.microsoft.com/en-us/research/publication/transactional-memory-data-invariants/},
	abstract = {This paper introduces a mechanism for asserting invariants that are maintained by a program that uses atomic memory transactions. The idea is simple: a programmer writes check E where E is an expression that should be preserved by every atomic update for the remainder of the program's execution. We have extended STM Haskell to dynamically evaluate check statements atomically with the user's updates: the result is that we can identify precisely which update is the first one to break an invariant.},
	booktitle = {First {ACM} {SIGPLAN} {Workshop} on {Languages}, {Compilers}, and {Hardware} {Support} for {Transactional} {Computing} ({TRANSACT}'06)},
	author = {Harris, Tim and Peyton Jones, Simon},
	month = jun,
	year = {2006}
}

@misc{haskell_applications,
	title = {Haskell {A}pplications and {L}ibraries},
	url = {https://wiki.haskell.org/Applications_and_libraries},
	howpublished = {\url{https://wiki.haskell.org/Applications_and_libraries}},
	language = {English},
	author = {HaskellWiki},
	year = {2019},
	note = {Last Access October 11, 2019}
}

@misc{gloss_library,
	title = {gloss library},
	url = {http://hackage.haskell.org/package/gloss},
	howpublished = {\url{http://hackage.haskell.org/package/gloss}},
	language = {English},
	author = {Lippmeier, B.},
	year = {2019},
	note = {Last Access October 11, 2019}
}

@misc{dunai_library,
	title = {duani library},
	url = {http://hackage.haskell.org/package/dunai},
	howpublished = {\url{http://hackage.haskell.org/package/dunai}},
	language = {English},
	author = {Perez, I. and Bärenz M.},
	year = {2019},
	note = {Last Access October 11, 2019}
}

@misc{pqueue_library,
	title = {pqueue library},
	url = {http://hackage.haskell.org/package/pqueue},
	howpublished = {\url{http://hackage.haskell.org/package/pqueue}},
	language = {English},
	author = {Wasserman, L.},
	year = {2019},
	note = {Last Access October 11, 2019}
}

@misc{containers_library,
	title = {containers library},
	url = {http://hackage.haskell.org/package/containers},
	howpublished = {\url{http://hackage.haskell.org/package/containers}},
	language = {English},
	author = {libraries@haskell.org},
	year = {2019},
	note = {Last Access October 11, 2019}
}

@misc{gamasutra_carmack_fp,
	title = {In-depth: {F}unctional programming in {C}++},
	url = {https://www.gamasutra.com/view/news/169296/Indepth_Functional_programming_in_C.php},
	howpublished = {\url{https://www.gamasutra.com/view/news/169296/Indepth_Functional_programming_in_C.php}},
	language = {English},
	author = {Carmack, J},
	year = {2012},
	month= Apr,
	note = {Last Access October 11, 2019}
}

@misc{thaler_stm_sir_repository,
	title = {Repository of {STM} implementations of the agent-based {SIR} model in {H}askell},
	url = {https://github.com/thalerjonathan/haskell-stm-sir},
	howpublished = {\url{https://github.com/thalerjonathan/haskell-stm-sir}},
	language = {English},
	author = {Thaler, J.},
	month = Oct,
	year = {2019},
	note = {Last Access October 11, 2019}
}

@misc{stm_stats_library,
	title = {stm-stats library},
	url = {http://hackage.haskell.org/package/stm-stats},
	howpublished = {\url{http://hackage.haskell.org/package/stm-stats}},
	language = {English},
	author = {Breitner, J.},
	month = Oct,
	year = {2019},
	note = {Last Access October 11, 2019}
}

@misc{thaler_stm_sugarscape_repository,
	title = {Repository of {STM} implementations of the {S}ugarscape model in {H}askell},
	url = {https://github.com/thalerjonathan/haskell-stm-sugarscape},
	howpublished = {\url{https://github.com/thalerjonathan/haskell-stm-sugarscape}},
	language = {English},
	author = {Thaler, J.},
	month = Oct,
	year = {2019},
	note = {Last Access October 11, 2019}
}

@misc{thaler_zerointelligence_repository,
	title = {Repository of the {G}ode and {S}under {Z}ero {I}ntelligence traders in {H}askell},
	url = {https://github.com/thalerjonathan/zerointelligence},
	howpublished = {\url{https://github.com/thalerjonathan/zerointelligence}},
	language = {English},
	author = {Thaler, J.},
	month = mar,
	year = {2019},
	note = {Last Access October 11, 2019}
}

@misc{lebaron_zerointelligence,
	title = {Zero {I}ntelligence {T}raders: {G}ode and {S}under},
	url = {http://people.brandeis.edu/~blebaron/classes/agentfin/GodeSunder.html},
	howpublished = {\url{http://people.brandeis.edu/~blebaron/classes/agentfin/GodeSunder.html}},
	language = {English},
	author = {LeBaron, B.},
	year = {2016},
	note = {Last Access October 11, 2019}
}

@misc{kaminski_messageoriented,
	title = {What would a message-oriented programming language look like?},
	url = {https://www.tedinski.com/2018/11/20/message-oriented-programming.html},
	howpublished = {\url{https://www.tedinski.com/2018/11/20/message-oriented-programming.html}},
	language = {English},
	author = {Kaminski, T.},
	month = Nov,
	year = {2018},
	note = {Last Access October 11, 2019}
}

@misc{definitionsforoo,
	title = {Definitions {F}or {O}o},
	url = {http://wiki.c2.com/?DefinitionsForOo},
	howpublished = {\url{http://wiki.c2.com/?DefinitionsForOo}},
	language = {English},
	author = {wiki, c2},
	month = Nov,
	year = {2014},
	note = {Last Access October 11, 2019}
}

@misc{maguire_freermonads_better,
	title = {Freer {M}onads, {M}ore {B}etter {P}rograms},
	url = {https://reasonablypolymorphic.com/blog/freer-monads/},
	howpublished = {\url{https://reasonablypolymorphic.com/blog/freer-monads/}},
	language = {English},
	author = {Maguire, S.},
	month = Feb,
	year = {2019},
	note = {Last Access October 11, 2019}
}

@misc{maguire_freermonads_fast,
	title = {Freer {M}onads: {T}oo {F}ast, {T}oo {F}ree},
	url = {https://reasonablypolymorphic.com/blog/too-fast-too-free/},
	howpublished = {\url{https://reasonablypolymorphic.com/blog/too-fast-too-free/}},
	language = {English},
	author = {Maguire, S.},
	month = Feb,
	year = {2019},
	note = {Last Access October 11, 2019}
}

@misc{maguire_higherorder_effects,
	title = {Freer, yet too costly {H}igher-order {E}ffects},
	url = {https://reasonablypolymorphic.com/blog/freer-yet-too-costly/},
	howpublished = {\url{https://reasonablypolymorphic.com/blog/freer-yet-too-costly/}},
	language = {English},
	author = {Maguire, S.},
	month = Mar,
	year = {2019},
	note = {Last Access October 11, 2019}
}

@incollection{savaglio_agent-based_2018,
	address = {Cham},
	series = {Studies in {Computational} {Intelligence}},
	title = {Agent-{Based} {Computing} in the {Internet} of {Things}: {A} {Survey}},
	isbn = {978-3-319-66379-1},
	shorttitle = {Agent-{Based} {Computing} in the {Internet} of {Things}},
	url = {https://doi.org/10.1007/978-3-319-66379-1_27},
	abstract = {The Internet of Things is a revolutionary concept, within cyberphysical systems, rich in potential as well as in multifacet requirements and development issues. To properly address them and to fully support IoT systems development, Agent-Based Computing represents a suitable and effective modeling, programming, simulation paradigm. As matter of facts, agent metaphors, concepts, techniques, methods and tools have been widely exploited to develop IoT systems. Main contemporary contributions in this direction are surveyed and reported in this work.},
	language = {en},
	urldate = {2019-05-23},
	booktitle = {Intelligent {Distributed} {Computing} {XI}},
	publisher = {Springer International Publishing},
	author = {Savaglio, Claudio and Fortino, Giancarlo and Ganzha, Maria and Paprzycki, Marcin and Bădică, Costin and Ivanović, Mirjana},
	editor = {Ivanović, Mirjana and Bădică, Costin and Dix, Jürgen and Jovanović, Zoran and Malgeri, Michele and Savić, Miloš},
	year = {2018},
	doi = {10.1007/978-3-319-66379-1_27},
	keywords = {Agent-based Computing, Architectures, Internet of Things, Methodology, Modeling, Simulation},
	pages = {307--320}
}

@inproceedings{hay_experiments_2015,
	address = {New York, NY, USA},
	series = {{SIGSIM} {PADS} '15},
	title = {Experiments with {Hardware}-based {Transactional} {Memory} in {Parallel} {Simulation}},
	isbn = {978-1-4503-3583-6},
	url = {http://doi.acm.org/10.1145/2769458.2769462},
	doi = {10.1145/2769458.2769462},
	abstract = {Transactional memory is a concurrency control mechanism that dynamically determines when threads may safely execute critical sections of code. It provides the performance of fine-grained locking mechanisms with the simplicity of coarse-grained locking mechanisms. With hardware based transactions, the protection of shared data accesses and updates can be evaluated at runtime so that only true collisions to shared data force serialization. This paper explores the use of transactional memory as an alternative to conventional synchronization mechanisms for managing the pending event set in a Time Warp synchronized parallel simulator. In particular, we explore the application of Intel's hardware-based transactional memory (TSX) to manage shared access to the pending event set by the simulation threads. Comparison between conventional locking mechanisms and transactional memory access is performed to evaluate each within the warped Time Warp synchronized parallel simulation kernel. In this testing, evaluation of both forms of transactional memory found in the Intel Haswell processor, Hardware Lock Elision (HLE) and Restricted Transactional Memory (RTM), are evaluated. The results show that RTM generally outperforms conventional locking mechanisms and that HLE provides consistently better performance than conventional locking mechanisms, in some cases as much as 27\%.},
	urldate = {2019-10-22},
	booktitle = {Proceedings of the 3rd {ACM} {SIGSIM} {Conference} on {Principles} of {Advanced} {Discrete} {Simulation}},
	publisher = {ACM},
	author = {Hay, Joshua and Wilsey, Philip A.},
	year = {2015},
	note = {event-place: London, United Kingdom},
	keywords = {optimistic synchronization, parallel simulation, transactional memory, pending event set},
	pages = {75--86}
}

@article{suryanarayanan_pdes-mas_2013,
	series = {2013 {International} {Conference} on {Computational} {Science}},
	title = {{PDES}-{MAS}: {Distributed} {Simulation} of {Multi}-agent {Systems}},
	volume = {18},
	issn = {1877-0509},
	shorttitle = {{PDES}-{MAS}},
	url = {http://www.sciencedirect.com/science/article/pii/S1877050913003748},
	doi = {10.1016/j.procs.2013.05.231},
	abstract = {Multi-agent systems (MAS) are increasingly being acknowledged as a modelling paradigm for capturing the dynamics of complex systems in a wide range of domains, from system biology to adaptive socio-technical system of systems. The execution of such MAS simulations on parallel machines is a challenging problem due to their dynamic, non-deterministic, data-centric behaviour and nature. These problems are exacerbated as the scale of such MAS models increases. PDES-MAS is a distributed simulation kernel developed specifically to support MAS models addressing the problems of partitioning, load balancing and interest management in an integrated, transparent and adaptive manner. This paper presents an overview of PDES-MAS and for the first time it provides a quantitative evaluation of the system.},
	language = {en},
	urldate = {2019-11-05},
	journal = {Procedia Computer Science},
	author = {Suryanarayanan, Vinoth and Theodoropoulos, Georgios and Lees, Michael},
	month = jan,
	year = {2013},
	keywords = {Agent-based systems, Distributed simulation},
	pages = {671--681},
	file = {ScienceDirect Full Text PDF:/home/jonathan/Zotero/storage/2E9A8LRT/Suryanarayanan et al. - 2013 - PDES-MAS Distributed Simulation of Multi-agent Sy.pdf:application/pdf;ScienceDirect Snapshot:/home/jonathan/Zotero/storage/Z2GL9CPT/S1877050913003748.html:text/html}
} 

@article{logan_distributed_2001,
	title = {The distributed simulation of multiagent systems},
	volume = {89},
	issn = {0018-9219, 1558-2256},
	doi = {10.1109/5.910853},
	abstract = {Agent based systems are increasingly being applied in a wide range of areas including telecommunications, business process modeling, computer games, control of mobile robots, and military simulations. Such systems are typically extremely complex and it is often useful to be able to simulate an agent based system to learn more about its behavior or investigate the implications of alternative architectures. The authors discuss the application of distributed discrete event simulation techniques to the simulation of multiagent systems. We identify the efficient distribution of the agents' environment as a key problem in the simulation of agent based systems and present an approach to the decomposition of the environment that facilitates load balancing.},
	number = {2},
	journal = {Proceedings of the IEEE},
	author = {Logan, B. and Theodoropoulos, G.},
	month = feb,
	year = {2001},
	keywords = {agent based system simulation, agent based systems, agent environment, business process modeling, Computational modeling, computer games, Computer simulation, discrete event simulation, Discrete event simulation, distributed discrete event simulation techniques, distributed processing, distributed simulation, load balancing, Military communication, Military computing, military simulations, mobile robots, Mobile robots, multi-agent systems, multiagent system simulation, Multiagent systems, resource allocation, Robot control, Telecommunication computing, Telecommunication control, telecommunications, virtual machines},
	pages = {174--185},
	file = {IEEE Xplore Abstract Record:/home/jonathan/Zotero/storage/8GG2FD6B/910853.html:text/html}
}

@article{lees_using_2008,
	title = {Using {Access} {Patterns} to {Analyze} the {Performance} of {Optimistic} {Synchronization} {Algorithms} in {Simulations} of {MAS}},
	volume = {84},
	issn = {0037-5497},
	url = {http://dx.doi.org/10.1177/0037549708096691},
	doi = {10.1177/0037549708096691},
	abstract = {We present a detailed analysis of the performance of the Decision Theoretic Read Delay (DTRD) optimistic synchronization algorithm for simulations of multi-agent systems (MAS). We develop an abstract characterization of the access patterns found in MAS simulations based on the simulation's degree of coupling and skew. Using this characterization, we generated stereotypical test cases which we used to compare the performance of the DTRD algorithm with that of Time Warp and time windows. To determine if the test cases reliably predict performance in a real agent simulation, we compared the predictions made by the test cases with performance results from the Boids agent simulation benchmark for a range of simulation parameters. The results indicate that the test cases are useful predictors of performance in real agent simulations, that DTRD adapts to the mixtures of coupling cases found in real agent simulations and is capable of tracking changes in coupling during the simulation.},
	number = {10-11},
	urldate = {2019-10-22},
	journal = {Simulation},
	author = {Lees, Michael and Logan, Brian and Theodoropoulos, Georgios},
	month = oct,
	year = {2008},
	pages = {481--492}
}

@article{suryanarayanan_synchronised_2013,
	title = {Synchronised {Range} {Queries} in {Distributed} {Simulations} of {Multiagent} {Systems}},
	volume = {23},
	issn = {1049-3301},
	url = {http://doi.acm.org/10.1145/2517449},
	doi = {10.1145/2517449},
	abstract = {Range queries are an increasingly important associative form of data access encountered in different computational environments including peer-to-peer systems, wireless communications, database systems, distributed virtual environments, and, more recently, distributed simulations. In this article, we present and evaluate a system for performing logical-time synchronised Range-Queries over data in the context of distributed simulations of multiagent systems. This article presents algorithms performing instantaneous queries within an optimistic synchronisation framework and in the presence of dynamic migration of the simulation state. A quantitative evaluation of the effectiveness of the proposed algorithms under different conditions and for different benchmarks, including Boids, is also presented.},
	number = {4},
	urldate = {2019-10-22},
	journal = {ACM Trans. Model. Comput. Simul.},
	author = {Suryanarayanan, Vinoth and Theodoropoulos, Georgios},
	month = nov,
	year = {2013},
	keywords = {data management, distributed simulation, distributed virtual environments, load balancing, multiagent systems, Range queries},
	pages = {25:1--25:25}
}

@inproceedings{riley_next_2003,
	series = {{WSC} '03},
	title = {Next {Generation} {Modeling} {III} - {Agents}: {Spades} — a {Distributed} {Agent} {Simulation} {Environment} with {Software}-in-the-loop {Execution}},
	isbn = {978-0-7803-8132-2},
	shorttitle = {Next {Generation} {Modeling} {III} - {Agents}},
	url = {http://dl.acm.org/citation.cfm?id=1030818.1030926},
	abstract = {Simulations are used extensively for studying artificial intelligence. However, the simulation technology in use by and designed for the artificial intelligence community often fails to take advantage of much of the work by the larger simulation community to produce distributed, repeatable, and efficient simulations. We present the new system known as \textit{System for Parallel Agent Discrete Event Simulator, (SPADES)}, which is a simulation environment for the artificial intelligence community. \textit{SPADES} focuses on the \textit{agent} as a fundamental simulation component. The \textit{thinking time} of an agent is tracked and reflected in the results of the agents' actions by using a \textit{Software-in-the-Loop} mechanism. \textit{SPADES} supports distributed execution of the agents across multiple systems, while at the same time producing repeatable results regardless of network or system load. We discuss the design of \textit{SPADES} in detail and give experimental results. \textit{SPADES} is flexible enough for a variety of application domains in the artificial intelligence research community.},
	urldate = {2019-10-22},
	booktitle = {Proceedings of the 35th {Conference} on {Winter} {Simulation}: {Driving} {Innovation}},
	publisher = {Winter Simulation Conference},
	author = {Riley, Patrick F. and Riley, George F.},
	year = {2003},
	note = {event-place: New Orleans, Louisiana},
	pages = {817--825}
}

@inproceedings{gasser_mace3j:_2002,
	address = {New York, NY, USA},
	series = {{AAMAS} '02},
	title = {{MACE}3J: {Fast} {Flexible} {Distributed} {Simulation} of {Large}, {Large}-grain {Multi}-agent {Systems}},
	isbn = {978-1-58113-480-3},
	shorttitle = {{MACE}3J},
	url = {http://doi.acm.org/10.1145/544862.544918},
	doi = {10.1145/544862.544918},
	abstract = {Scientific study of multi-agent systems (MAS) requires infrastructure such as development testbeds and simulation tools for repeatable, controlled experiments with MAS structure and behavior. Testbeds and simulation tools are also critical for MAS education and development. A number of MAS testbeds currently exist, but to date none meets in a comprehensive way criteria laid out by many analysts for general, scientific, experimental study of MAS by a large community. Moreover, none really scales to very large MAS or exploits the power of modern distributed computing environments such as large multiprocessor clusters and computational grids. Because of this, and specifically to fulfill widespread need for tools supporting distributed collaborative scientific research in large-scale, large-grain MAS, we created the MACE3J system, a successor to the pioneering MACE testbed.MACE3J is a Java-based MAS simulation, integration, and development testbed, with a supporting library of components, examples, and documentation, distributed freely. MACE3J currently runs on single- and multiprocessor workstations, and in large multiprocessor cluster environments. The MACE3J design is multi-grain, but gives special attention to simulating very large communities of large-grain agents. It exhibits a significant degree of scalability, and has been effectively used in fast simulations of over 5,000 agents, 10,000 tasks, and 10M messages, and on multiprocessor configurations of up to 48 processors, with a future target of at least 1000 processors.This paper presents MACE3J design criteria and our approach to a number of critical tradeoffs that, to our knowledge, have not previously been treated explicitly in MAS literature or platforms. We present the innovative features of the MACE3J architecture that contribute to its breadth, flexibility and scalability, and finally give results from the use of MACE3J in real experiments in realistic MAS domains, both simple and complex.},
	urldate = {2019-10-22},
	booktitle = {Proceedings of the {First} {International} {Joint} {Conference} on {Autonomous} {Agents} and {Multiagent} {Systems}: {Part} 2},
	publisher = {ACM},
	author = {Gasser, Les and Kakugawa, Kelvin},
	year = {2002},
	note = {event-place: Bologna, Italy},
	pages = {745--752}
}

@inproceedings{himmelspach_plugn_2007,
	title = {Plug'n {Simulate}},
	doi = {10.1109/ANSS.2007.34},
	abstract = {Developments in simulation systems, e.g. new simulators, partitioning algorithms, modeling formalisms, or specialized user interfaces, often implies the realization of entire simulation systems from scratch. This requires significant efforts, and, in addition, it hampers the evaluation of the results achieved. The proposed plug 'n simulate concept enables developers to integrate their ideas into an existing framework and thus eases the development and the evaluation of results},
	booktitle = {40th {Annual} {Simulation} {Symposium} ({ANSS}'07)},
	author = {Himmelspach, Jan and Uhrmacher, Adelinde M.},
	month = mar,
	year = {2007},
	note = {ISSN: 1080-241X},
	keywords = {Adaptation models, Analytical models, Biological system modeling, computer aided analysis, digital simulation, James II, Load modeling, Partitioning algorithms, plug 'n simulate, Production facilities, simulation systems, User interfaces},
	pages = {137--143},
	file = {IEEE Xplore Abstract Record:/home/jonathan/Zotero/storage/8M3L8I6L/4127212.html:text/html;IEEE Xplore Full Text PDF:/home/jonathan/Zotero/storage/TC9LDR3K/Himmelspach and Uhrmacher - 2007 - Plug'n Simulate.pdf:application/pdf}
}

@article{minson_distributing_2008,
	title = {Distributing {RePast} agent-based simulations with {HLA}},
	volume = {20},
	copyright = {Copyright © 2008 John Wiley \& Sons, Ltd.},
	issn = {1532-0634},
	url = {https://onlinelibrary.wiley.com/doi/abs/10.1002/cpe.1280},
	doi = {10.1002/cpe.1280},
	abstract = {Large, experimental multi-agent system (MAS) simulations are highly demanding tasks, both computationally and developmentally. Agent toolkits provide reliable templates for the design of even the largest MAS simulations, without offering a solution to computational limitations. Conversely, distributed simulation architectures offer performance benefits, but the introduction of parallel logic can complicate the design process significantly. The motivations of distribution are not limited to this question of processing power. True interoperation of sequential agent-simulation platforms would allow agents designed using different toolkits to transparently interact in common abstract domains. This paper discusses the design and implementation of a system capable of harnessing the computational power of a distributed simulation infrastructure with the design efficiency of an agent toolkit. The system permits integration, through a higher-level architecture (HLA) federation, of multiple instances of the Java-based lightweight agent-simulation toolkit RePast. This paper defines abstractly the engineering process necessary in creating such middleware, and reports on the experience in the specific case of the RePast toolkit. The paper also presents performance results that illustrate that significant speedup can be achieved through the integration of RePast with HLA. Copyright © 2008 John Wiley \& Sons, Ltd.},
	language = {en},
	number = {10},
	urldate = {2019-10-22},
	journal = {Concurrency and Computation: Practice and Experience},
	author = {Minson, R. and Theodoropoulos, G. K.},
	year = {2008},
	keywords = {distributed simulation, multi-agent simulation},
	pages = {1225--1256},
	file = {Snapshot:/home/jonathan/Zotero/storage/YIJDV4ZU/cpe.html:text/html}
}

@inproceedings{gorur_repast_2016,
	address = {San Diego, CA, USA},
	series = {{HPC} '16},
	title = {Repast {HPC} with {Optimistic} {Time} {Management}},
	isbn = {978-1-5108-2318-1},
	url = {https://doi.org/10.22360/SpringSim.2016.HPC.046},
	doi = {10.22360/SpringSim.2016.HPC.046},
	abstract = {High performance computing (HPC) has great potential to speedup agent-based simulations. In parallel and distributed simulation (PADS) community, a well-known fact is that employing an optimistic time management mechanism instead of a conservative time management mechanism may provide remarkable performance enhancement, because optimistic approach avoids redundant synchronization among logical processes (LPs). In this paper, an existing optimistic time management mechanism, namely Time Warp, by Jefferson, is adapted for a distributed agent based simulation tool. We implemented Time Warp on an open source and distributed agent based modeling and simulation (ABMS) tool, namely Repast for High Performance Computing (Repast HPC), from Argonne National Laboratory, Chicago, IL, USA. We incorporated a simple and self-adaptive technique for adjusting checkpoint intervals. Two case studies have been implemented to compare our optimistic approach and existing Repast HPC's conservative approach. The experiments suggest that optimistic approach is more scalable than conservative approach in agent based simulations.},
	urldate = {2019-10-22},
	booktitle = {Proceedings of the 24th {High} {Performance} {Computing} {Symposium}},
	publisher = {Society for Computer Simulation International},
	author = {Gorur, B. Kaan and Imre, Kayhan and Oguztuzun, Halit and Yilmaz, Levent},
	year = {2016},
	note = {event-place: Pasadena, California},
	keywords = {agent based simulation, optimistic time management, parallel and distributed computing, self-adaptive checkpoint, time warp algorithm},
	pages = {4:1--4:9}
}

@article{abar_agent_2017,
	title = {Agent {Based} {Modelling} and {Simulation} tools: {A} review of the state-of-art software},
	volume = {24},
	issn = {15740137},
	shorttitle = {Agent {Based} {Modelling} and {Simulation} tools},
	url = {https://linkinghub.elsevier.com/retrieve/pii/S1574013716301198},
	doi = {10.1016/j.cosrev.2017.03.001},
	language = {en},
	urldate = {2019-10-22},
	journal = {Computer Science Review},
	author = {Abar, Sameera and Theodoropoulos, Georgios K. and Lemarinier, Pierre and O’Hare, Gregory M.P.},
	month = may,
	year = {2017},
	pages = {13--33}
}

@article{cicirelli_efficient_2015,
	title = {Efficient {Environment} {Management} for {Distributed} {Simulation} of {Large}-scale {Situated} {Multi}-agent {Systems}},
	volume = {27},
	issn = {1532-0626},
	url = {http://dx.doi.org/10.1002/cpe.3254},
	doi = {10.1002/cpe.3254},
	abstract = {Multi-agent systems have been proven very effective for the modelling and simulation M\&S of complex systems like those related to biology, engineering, social sciences and so forth. The intrinsic spatial character of many such systems leads to the definition of a situated agent. A situated agent owns spatial coordinates and acts and interacts with its peers in a hosting territory. In the context of parallel/distributed simulation of situated agent models, the territory represents a huge shared variable that requires careful handling. Frequent access by agents to territory information easily becomes a bottleneck degrading system performance and scalability. This paper proposes an original approach to modelling and distributed simulation of large-scale situated multi-agent systems. Time management is exploited for resolving conflicts and achieving data consistency while accessing the environment. The approach allows a simplification of the M\&S tasks by making the modeller unaware of distribution concerns while ensuring the achievement of good scalability and performance during the distributed simulation. Practical aspects of the approach are demonstrated through some modelling examples based on Tileworld. Copyright © 2014 John Wiley \& Sons, Ltd.},
	number = {3},
	urldate = {2019-10-22},
	journal = {Concurr. Comput. : Pract. Exper.},
	author = {Cicirelli, Franco and Giordano, Andrea and Nigro, Libero},
	month = mar,
	year = {2015},
	keywords = {actors, composed logical time, distributed simulation, distributed spatial environment, Java, situated multi-agent systems},
	pages = {610--632},
	file = {Full Text:/home/jonathan/Zotero/storage/8B7R7T86/Cicirelli et al. - 2015 - Efficient Environment Management for Distributed S.pdf:application/pdf}
}

@misc{criterion_serpentine,
	title = {criterion: a Haskell microbenchmarking library},
	url = {http://www.serpentine.com/criterion/},
	howpublished = {\url{http://www.serpentine.com/criterion/}},
	language = {English},
	author = {O'Sullivan, B.},
	month = Oct,
	year = {2014},
	note = {Last Access December 4, 2019}
}

@misc{array_hackage,
	title = {array: Mutable and immutable arrays},
	url = {http://hackage.haskell.org/package/array},
	howpublished = {\url{http://hackage.haskell.org/package/array}},
	language = {English},
	author = {libraries@haskell.org},
	month = Dec,
	year = {2014},
	note = {Last Access December 4, 2019}
}

@misc{criterion_hackage,
	title = {criterion: Robust, reliable performance measurement and analysis},
	url = {http://hackage.haskell.org/package/criterion},
	howpublished = {\url{http://hackage.haskell.org/package/criterion}},
	language = {English},
	author = {O'Sullivan, B.},
	month = Dec,
	year = {2014},
	note = {Last Access December 4, 2019}
}

@misc{concurrent_extra_library,
	title = {concurrent-extra library},
	url = {http://hackage.haskell.org/package/concurrent-extra},
	howpublished = {\url{http://hackage.haskell.org/package/concurrent-extra}},
	language = {English},
	author = {van Dijk, B. and van Dijk, J.},
	month = Mar,
	year = {2018},
	note = {Last Access December 4, 2019}
}

@misc{arrows_haskell,
	title = {Arrows: A General Interface to Computation},
	url = {https://www.haskell.org/arrows/},
	howpublished = {\url{https://www.haskell.org/arrows/}},
	language = {English},
	author = {Ross Paterson},
	note = {Last Access December 4, 2019}
}