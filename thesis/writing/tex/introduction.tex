\chapter{Introduction}
\label{ch:intro}

% MOTIVATION and AIM
The traditional approach to Agent-Based Simulation (ABS) has so far always been object-oriented, due to the influence of the seminal Sugarscape model \cite{epstein_growing_1996}, in which the authors claim \textit{"[..] object-oriented programming to be a particularly natural development environment for Sugarscape specifically and artificial societies generally [..]"} (p. 179). This work established the metaphor in the ABS community, that \textit{agents map naturally to objects} \cite{north_managing_2007}, which still holds up today. %TODO can we cite any statistics about number of developed ABS models?

This thesis challenges this metaphor and explores ways of approaching ABS through the \textit{pure} functional programming paradigm using the language Haskell. To the best of the authors knowledge, it is the first one to do so on a \textit{systematical} level, developing a foundation by presenting fundamental concepts and advanced features to show how to leverage the paradigms benefits \cite{hudak_history_2007} to make them available when implementing ABS functionally. By doing this, the thesis shows \textit{how} to implement ABS purely functional and \textit{why} it is of benefit of doing so, what the drawbacks are and also when a pure functional approach should \textit{not} be used. This aim leads to the thesis' general research question of \textit{how to implement ABS purely functional and what the benefits and drawbacks are when doing so.} 

\medskip

% THE PROBLEM, THE GINTIS CASE
Struggles with established ABS approaches are described in \cite{axelrod_chapter_2006}, where Axelrod reports the vulnerability of ABS to misunderstanding. Due to informal specifications of models and change requests among members of a research team, bugs are very likely to be introduced. He also reported how difficult it was to reproduce the work of \cite{axelrod_convergence_1995}, which took the team four months due to inconsistencies between the original code and the published paper. The consequence is that counter-intuitive simulation results can lead to weeks of checking whether the code matches the model and is bug-free as reported in \cite{axelrod_advancing_1997}.

The same problem was reported in \cite{ionescu_dependently-typed_2012}, which tried to reproduce the work of Gintis \cite{gintis_emergence_2006}. In his work, Gintis claimed to have found a mechanism in bilateral decentralized exchange, which resulted in Walrasian General Equilibrium without the neo-classical approach of a tatonement process through a central auctioneer. This was a major breakthrough for economics as the theory of Walrasian General Equilibrium is non-constructive as it only postulates the properties and existence of the equilibrium \cite{colell_microeconomic_1995} but does not explain the process and dynamics through which this equilibrium can be reached or constructed - Gintis seemed to have found this very process.

The authors \cite{ionescu_dependently-typed_2012} failed to reproduce the results and were only able to solve the problem by directly contacting Gintis which provided the code, the definitive formal reference \footnote{It seems that by now, Gintis has made his code, written in Object Pascal, publicly available through his homepage \url{https://people.umass.edu/gintis/}}. It was found that there was a bug in the code leading to the unexpected results, which were seriously damaged through this error. They also reported ambiguity between the informal model description in Gintis paper and the actual implementation.
This lead to a research in a functional framework for agent-based models of exchange as described in \cite{botta_functional_2011}, which tried to give a very formal functional specification of the model coming very close to an implementation in Haskell. The failure of Gintis was investigated more in depth in the thesis by \cite{evensen_extensible_2010} who got access to Gintis code of \cite{gintis_emergence_2006}. They found that the code didn't follow good object-oriented design principles (all was public, code duplication) and - in accordance with \cite{ionescu_dependently-typed_2012} - discovered a number of bugs serious enough to invalidate the results. 

Thus it is clear that due to the fact that ABS is almost always used for scientific research, producing often break-through scientific results, besides on converging both on standards for testing the robustness of implementations and on its tools, ABS need to be \textit{free of bugs}, \textit{verified against their specification}, \textit{validated against hypotheses} and ultimately be \textit{reproducible} \cite{axelrod_chapter_2006}.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\medskip

% SCOPE
This thesis claims that the ABS community needs functional programming because of its \textit{scientific computing} nature, where results need to be reproducible and correct while simulations should be able to massively scale up as well. Due to the primarily computational character of most ABS models, not requiring asynchronous, non-deterministic IO or direct user interaction, a pure functional approach should be able to directly deliver these non-functional requirements. As pointed out above, the established object-oriented approach needs considerably high effort and might even fail to deliver these objectives due to its conceptually different approach to computing, as in general it lacks strong static typing, uses mutable shared state and has implicit side effects. 

% RESEARCH QUESTION and HYPOTHESEIS
This thesis hypothesises that using pure functional programming for implementing ABS might be a remedy to this problem and would make the resulting simulations easier to test and verify, applicable to property-based testing, easy to add parallelism and concurrency, guaranteed to be reproducible already at compile time, have fewer potential sources of bugs and thus can raise the level of confidence in the correctness of an implementation to a new level. Further, it is well known that functional programming helps in structuring computation in a very clear and precise way, leading to a deeper understanding about problems. Thus, in this thesis the functional approach is regarded as a way to think and explore ABS in a more rigorous way, as a tool for developing abstractions and especially to develop a deeper and more complete understanding of the computational structure underlying ABS. %By implementing and generalising use cases, implicit knowledge is extracted and made explicit.
It is the authors hope that this undertaking is to the whole benefit of the ABS discipline and will also feed back into the traditional object-oriented implementation techniques.

This thesis is \textit{not} about comparing the object-oriented and pure functional programming paradigm in the context of implementing ABS. Such an approach would not be fruitful, as too much ink has been spilt already over which paradigm is better or worse. There seems to be no scientific evidence supporting that either one is truly superior over the other; each has its benefits and weaknesses and this thesis aims to finding out what they are when using pure functional programming in ABS.

\section{Contributions}
\begin{enumerate}
	\item To the best knowledge of the author, this thesis is the first to \textit{systematically} investigate the use of the functional programming paradigm, as in Haskell, to ABS, laying out in-depth technical foundations and identifying its benefits and drawbacks. Also, the use of functional programming, which focuses on explicit data-flow representation, is a strong match to scientific computing, which is data-centric as well. Thus, due to the increased interest in functional concepts added to object-oriented languages in recent years (lambda expressions and map, filter, reduce in Java 8, rise of functional frameworks in JavaScript, Pythons functional features,...), because of its established benefits in concurrent programming, testing and software development in general, presenting such foundational research gives this thesis significant impact. Further, a pure functional approach directly leads to less bugs and guaranteed reproducibility of repeated runs at compile time, resulting in implementations which are more likely to be correct, something of fundamental importance in all kind of scientific computing in general, thus giving this thesis considerable impact.
	
	\item To the best knowledge of the author, this thesis is the first to show the use of Software Transactional Memory to implement concurrent ABS and its potential benefit over lock-based approaches. The use of Software Transactional Memory is particularly compelling in pure functional programming because it can be guaranteed at compile time that retry semantics exclude non-repeatable persistent side effects. By showing how to employ Software Transactional Memory it is possible to implement a simulation which allows massively large-scale ABS but without the low level difficulties of concurrent programming, making it easier and quicker to develop working and correct concurrent ABS models. The use of Software Transactional Memory allows to approach concurrency still as a data-flow approach, without cluttering model code with concurrency semantics. Although purity is lost when using Software Transactional Memory, it is still possible to retain certain guarantees about reproducibility, making it a highly attractive approach to concurrent scientific computing. Further, due to the increasing need for massively large-scale ABS in recent years \cite{lysenko_framework_2008}, making this possible within a purely functional approach as well, gives this thesis substantial impact.
	
	\item To the best of the authors knowledge, this thesis is the first to present the use of property-based testing in ABS, which allows declarative specification testing of the implemented ABS directly in code with \textit{automated} random test case generation. This is an addition to the established Test Driven Development process and a complementary approach to unit testing, ultimately giving the developers an additional, powerful tool to test the implementation on a more conceptual level. More specifically, the thesis shows how to encode full agent specifications and model invariants and do validation and verification including hypothesis testing with property-based testing. This should lead to simulation software which is more likely to be correct, thus making this a highly significant contribution with valuable impact.

	%\item To the best of the authors knowledge, this thesis is the first to outline the potential use of \textit{dependent types} to Agent-Based Simulation on a \textit{conceptual level} to investigate its usefulness for increasing the correctness of a simulation. Dependent types can help to narrow the gap between the model specification and its implementation, reducing the potential for conceptual errors in model-to-code translation. This immediately leads to fewer number of tests required due to guarantees being expressed already at compile time. Ultimately dependent types lead to higher confidence in correctness due to formal guarantees in code, making this a unique contribution with high impact.
\end{enumerate}

\section{Publications}
Throughout the course of the Ph.D. six (6) papers were written and attempted to publish, out of which three (3) were accepted and published and one (1) is currently under review:

\begin{enumerate}
	\item \textit{The Art Of Iterating - Update Strategies in Agent-Based Simulation} \cite{thaler_art_2017}; submitted and accepted at the Social Simulation Conference 2017 - This paper derives four different update strategies and their properties possible in time-driven ABS and discusses them from a programming-paradigm agnostic point of view. It is the first paper which makes the very basics of update semantics clear on a conceptual level and is necessary to understand the options one has when implementing time- and event-driven ABS purely functional. Chapter \ref{ch:impl_abs} builds heavily on the contents of this paper. Further the introduction to ABS in Chapter \ref{sec:method_abs} is covered to a large extent already in this paper.
	
	\item \textit{Pure Functional Epidemics} \cite{thaler_pure_2018}; submitted and accepted at the IFL Conference 2018 - Using an agent-based SIR model, this paper establishes in technical detail \textit{how} to implement time-driven ABS in Haskell using non-monadic Functional Reactive Programming with Yampa and monadic Functional Reactive Programming with Dunai. It outlines benefits and drawbacks and also touches on important points which were out of scope and lack of space in this paper but which will be addressed in more detail in this thesis. Chapter \ref{ch:timedriven} is basically an identical copy of this paper, with minor extensions and restructuring. Further the introduction to Functional Reactive Programming in Chapter \ref{sec:background_fp} is covered to a large extent already in this paper.
	
	\item \textit{A Tale Of Lock-Free Agents} \cite{thaler_tale_2018}; submitted to the TOMACS Journal in October 2018 and rejected in March 2019 - This paper is the first to discuss the use of Software Transactional Memory for implementing concurrent ABS both on a conceptual and on a technical level. It presents two case studies, with the agent-based SIR model as the first and the Sugarscape being the second one. In both case studies it compares performance of Software Transactional Memory and lock-based implementations in Haskell and object-oriented implementations of established languages. Although Software Transactional Memory is now not unique to Haskell any more, this paper shows why Haskell is particularly well suited for the use of Software Transactional Memory and is the only language which can overcome the central problem of how to prevent persistent side effects in retry semantics. Chapter \ref{ch:concurrent_abs} is based on the work of this paper with minor adjustments and extensions.

	\item \textit{The Agents' New Cloths? Towards Pure Functional Agent-Based Simulation} \cite{thaler_agents_2019}; submitted and rejected at the Summer Simulation Conference 2019 - This paper summarizes the main benefits of using pure functional programming as in Haskell to implement ABS and discusses on a conceptual level how to implement it and also what potential drawbacks are and where the use of a functional approach is not encouraged. It is written as a conceptual review paper, which tries to 'sell' pure functional programming to the agent-based community without too much technical detail and parlance where it refers to the important technical literature from where an interested reader can start. The introduction to functional programming in Chapter \ref{sec:background_fp} is covered to a large extent already in this paper.
	
	\item \textit{Show Me Your Properties! The Potential Of Property-Based Testing In Agent-Based Simulation} \cite{thaler_show_2019}; submitted and accepted at the Summer Simulation Conference 2019 - This paper introduces property-based testing on a conceptual level to ABS using the agent-based SIR model and the Sugarscape model as two case studies. Both Chapters \ref{ch:agentspec} and \ref{ch:sir_invariants} of Part \ref{part:property} and the Appendix \ref{app:validating_sugarscape} are substantially expanded discussions of the ideas presented in this paper.
	
	\item \textit{Specification Testing of Agent-Based Simulation using Property-Based Testing.} \cite{thaler_specification_2019}; submitted to the JAAMAS Journal in August 2019, currently under review - This paper introduces property-based testing on a technical level to ABS using the agent-based SIR model model as case study. It builds on the previous, conceptual paper and discusses the topic in much more technical detail and also shows the use of statistically robust hypothesis testing with property-based testing. Both Chapters \ref{ch:agentspec} and \ref{ch:sir_invariants} of Part \ref{part:property} and the Appendix \ref{app:validating_sugarscape} are substantially expanded discussions of the ideas presented in this paper.
\end{enumerate}


\section{Thesis structure}
%This thesis focuses on a strong narrative which tells the story of \textit{how} to do ABS with pure functional programming, \textit{why} one would do so and when one should \textit{avoid} this paradigm in ABS.

The thesis is divided into five parts which act as the thematic narrative throughout the text followed by an Appendix . 

\paragraph{Part \ref{part:preliminaries}} opens the thesis by laying out the necessary prerequisites necessary to understand the ideas and motivation in the rest of the thesis.
\medskip

Chapter \ref{ch:intro} introduces the problem and presents the motivation, aim and hypotheses.

\medskip

Chapter \ref{ch:background} presents related research and discusses the background necessary to understand the rest of the thesis. It presents a definition of ABS and gives an introduction to functional programming with advanced topics necessary to understand the concepts in this thesis. Further it discusses the methodology.

\medskip

Chapter \ref{ch:impl_abs} discusses an architectural categorisation on how to implement ABS from a language-agnostic point of view. 

\medskip

\paragraph{Part \ref{part:implementation}} presents techniques of \textit{how} to implement ABS in pure functional programming. 
\medskip

Chapter \ref{ch:timedriven} derives a time-driven ABS implementation for an agent-based SIR model. Because it is the first chapter discussing how to implement ABS pure functionally, it goes quite into detail in order to lay out the basic concepts.

\medskip

Chapter \ref{ch:eventdriven} presents an event-driven approach to ABS using an event-driven agent-based SIR and the highly complex Sugarscape model. It takes up the concepts derived in the previous Chapter \ref{ch:timedriven}, generalises them and pushes them forward to a more generic solution. Further it also gives a brief outline how to transform the time-driven SIR implementation into an event-driven one.

%\medskip

%Chapter \ref{ch:structure_abs_computation} takes a highly abstract look at the computational approach and structures, derived in quite an ad-hoc fashion in the previous two Chapters \ref{ch:timedriven}, \ref{ch:eventdriven}. It distils the essence of the SF and MSF constructs and shows that by looking at their building blocks of \textit{closures} and \textit{continuations}, SF and MSF can be regarded as very simple, immutable, pure functional objects. Further it looks at how they relate to existing computational structures like Monads, Comonads and Arrows.

\medskip

\paragraph{Part \ref{part:parallel}} presents parallel computation in ABS as the first of two parts of \textit{why} pure functional ABS is of benefit.
\medskip

Chapter \ref{ch:parallelism_ABS} shows rather briefly how to achieve deterministic and pure parallelism in pure functional ABS. 

\medskip

Chapter \ref{ch:concurrent_abs} presents an in-depth discussion on how to implement concurrent ABS using Software Transactional Memory.

\medskip

\paragraph{Part \ref{part:property}} presents property-based testing in ABS as the second of two parts of \textit{why} pure functional ABS is of benefit.
\medskip

Chapter \ref{ch:agentspec} shows how to use property-based testing to implement a full agent-specification test of the event- and time-driven SIR model in code and run it as property tests.

\medskip

Chapter \ref{ch:sir_invariants} shows how to derive and encode invariants the simulations dynamics must uphold in property tests. It also shows how to compare the dynamics of two implementations of the same underlying model, namely the the time- and event-driven SIR implementations. Further it shows how to put model specifications into code and check them with property tests by comparing the System Dynamics simulation to the agent-based one.

\medskip

\paragraph{Part \ref{part:discussion}} is the closing part which discusses and concludes the thesis. 
\medskip

%Chapter \ref{ch:gintis_case} presents the case of an agent-based model which results lead to high hopes in the field of computational economics, only to be found out that it had several bugs, weakening the results. In this chapter we ask whether a pure functional approach would have been of benefit in this case; more specifically, could those bugs have been prevented with a pure functional approach?

%\medskip

Chapter \ref{ch:discussion} revisits and discusses initial motivation, aim and hypotheses. Further, it presents the drawbacks of the pure functional approach, discusses the Gintis case described in the Introduction and answers the question of whether agents map naturally to objects or not.

\medskip

Chapter \ref{ch:conclusion} concludes and presents further research.

\paragraph{Appendices} contains additional material which relates to the overall research of this thesis but would be out of context in the respective chapters.
\medskip

Appendix \ref{app:sd_simulation} shows a pure functional implementation of a System Dynamics SIR simulation using Functional Reactive Programming. It shows that it is possible to directly encode System Dynamics specification in pure functional code with extremely high guarantees in correctness. This implementation is used in Chapter \ref{ch:sir_invariants} where the agent-based SIR dynamics are tested against the System Dynamics ones.

\medskip

Appendix \ref{app:validating_sugarscape} contains a brief overview over the validation process we went through when trying to get our Sugarscape implementation from Chapter \ref{ch:eventdriven} in line with the results from the original specification \cite{epstein_growing_1996}. Further we show how we can use property-based testing in an exploratory model to formulate and test hypotheses.

\medskip

Appendix \ref{app:equilibrium_totality} discusses the deep question of whether it is possible to test or guarantee that a correct implementation of the SIR model does terminate or not. This question arises in the context of Chapters \ref{ch:sir_invariants} and \ref{ch:agentspec}.