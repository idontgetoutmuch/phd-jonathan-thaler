\chapter{Introduction}
\label{ch:intro}

% THE PROBLEM
The traditional approach to Agent-Based Simulation (ABS) has so far always been object-oriented techniques, due to the influence of the seminal work of Epstein et al \cite{epstein_growing_1996} in which the authors claim "[..] object-oriented programming to be a particularly natural development environment for Sugarscape specifically and artificial societies generally [..]" (p. 179). This work established the metaphor in the ABS community, that \textit{agents map naturally to objects} \cite{north_managing_2007} which still holds up today.

% MOTIVATION and AIM
This thesis challenges that metaphor and explores ways of approaching ABS with the \textit{pure} functional programming paradigm using the languages Haskell and Idris. It is the first one to do so on a \textit{systematical} level and develops a foundation by presenting fundamental concepts and advanced features to show how to leverage the benefits of both languages \cite{hudak_history_2007, brady_idris_2013} to become available when implementing ABS functionally. By doing this, the thesis both shows \textit{how} to implement ABS purely functional and \textit{why} it is of benefit of doing so, what the drawbacks are and also when a pure functional approach should \textit{not} be used. 

TODO: also i see the functional approach as a way to think and explore ABS in a deeper way - especially to develop a deeper and more complete understanding on the computational structure underlying ABS. It is established, that FP helps in structuring computation in a very clear and precise way, leading to a deeper understanding about problems TODO this is also what Ionescu says in his thesis. So we also see FP as a tool for a deeper understanding of the computational structures involved in ABS. By implementing use-cases, reflecting on them and generalising we extract implicit knowledge and make it explicit. We hope that this undertaking is to the whole benefit of the ABS discipline and will also feed back into the traditional implementation techniques of OOP.

this Thesis is about abstracting the software concept of abs so we arrive at deeper understanding of abs Implementation in general, and its computatuonal structure. the tool used is pure FP because it sees structures as essential to programming. to quote Ted Kaminski in "Abstractions at the boundaries": Through the use of the right abstractions, we humans were able to reduce our attention to some partof the problem, something small enough that the human brain is capable of actually thinking deeply about it. Something we could study, and eventually emerge with a deep understand of. Then we could go back, armed with our new understanding, to re-interpret the larger problem. Eventually, with the right luck and/or genius, the real problem gets made small enough that *click*. abstractions were also a tool for human thought.
dependent types should allow this to push even further with more Focus on structure than on application

% SCOPE
This thesis claims that the agent-based simulation community needs functional programming because of its \textit{scientific computing} nature, where results need to be reproducible and correct while simulations should be able to massively scale-up as well. %The established object-oriented approaches need considerably high effort and might even fail to deliver these objectives due to its conceptually different approach to computing.

% RESEARCH QUESTION and HYPOTHESEIS
Thus this thesis' general research question is \textit{how to implement ABS purely functional and what the benefits and drawbacks are of doing so.} Further, it hypothesises that by using pure functional programming for implementing ABS makes it is easy to add parallelism and concurrency, the resulting simulations are easy to test and verify, applicable to property-based testing, guaranteed to be reproducible already at compile-time, have fewer potential sources of bugs and thus can raise the level of confidence in the correctness of an implementation to a new level.

\newpage

%The most important property of a general purpose programming language is being \textit{Turing Complete}. This term says roughly that a programming language which has this property can compute anything which is \textit{computable}. We will not go into the precise meaning of computability but it suffices to say that a problem is computable if we can formulate a program which, after a finite number of steps, produces an output for a given input to the problem. This also implies that there are non-computable problems e.g. comparing whether two infinite sets are extensionally equal is uncomputable. Turing completeness also says something about the theoretical limits of a programming language, termed the \textit{halting-problem}: it is not possible for a program written in such a programming language to decide \textit{in general} whether another program of a turing complete language terminates or not. From this follows, that all general purpose programming languages which are turing complete are equal in power: none can compute something another can't and all suffer the same limitations of the halting-problem.
%These fundamental insights come from the foundations and theory of computation and research on computability, which originated in the 1930s by the pioneering work of Turing, Church and Gödel. All of them have developed different models of computation but all were shown to be equal in power: they are all turing complete which means each of them can simulate the others \footnote{This implies that a language which guarantees that its programs always halt, is not powerful enough to interpret itself.}.
%Today's general purpose programming languages can be generally categorized into two categories: they either build on the model of the Turing Machine as introduced by Alan Turing or on the Lambda Calculus as introduced by Alonzo Church.
%Thus assuming that all general purpose programming languages are turing complete, one could ask the following questions:
%
%\begin{enumerate}
%	\item Why don't we implement our problems directly in a Turing Machine or the Lambda Calculus?
%		
%	\item Why are all these programming languages necessary in the first place if all are equal in power?
%
%	\item What are the implications for a programming language when choosing the one or the other model of computation as their foundation?
%\end{enumerate}
%
%The reason why we do not program directly in these models of computation is because the raw power quickly becomes unmanageable and too complex which is also due to the lack of a type system. The interesting thing though is that compared to the Turing Machine, the Lambda Calculus is much more manageable in terms of complexity. When one programs in a TM, the solution gets extremely complicated very quickly whereas one can program quite a while in LC because of its fundamental different nature \footnote{Actually when programming in Haskell (or ML / similar class of families) one programs basically in a slightly 'sugarized' version of the Lambda Calculus.}.
%
%Implementing simple arithmetic operations on natural numbers can be already quite challenging with surprisingly substantial amount of complexity \footnote{Note that these seemingly 'trivial' problems already require substantial amount of work, namely the encoding of natural numbers in either the Turing Machine or the Lambda Calculus, which is not trivial. This for a good reason: operations on natural numbers were used by Gödel to study the basics of computation.} In the subsequent chapters on functional programming and object-oriented programming we will give implementations of such simple arithmetic operations in the Lambda Calculus and the Turing Machine respectively - this will also show by example that the raw power of the Lambda Calculus is more manageable than the one of the Turing Machine.
%Still we can conclude that the TM and LC are basically only useful as theoretical foundations and to study fundamental and foundational problems but not to solve real problems. This is because we think problems different than a TM or LC works. So both do not allow us directly to express in the way we think, we need to build  more mechanisms on top of this raw complexity. To control complexity, the best solution has always been to add layers of abstraction. Thus we build up more and more levels of abstractions where each depends on preceding ones. Some programming languages stop at some point, where other languages go further in abstractions - the point here is that not all programming languages are equal in their abstractions of complexity.
%
%In the end a programming language is a tool to solve a problem by expressing the solution in this language. Depending on the underlying computational model some problems may be easier to solve in different languages \textit{because the language supports expressing a given solution more natural for the given problem}.
%When looking closer at the nature of the Turing Machine and Lambda Calculus we can attribute the Turing Machine to be an operational model and the Lambda Calculus to be a denotational one. Roughly speaking, an operational model describes \textit{how} to compute something whereas a denotational model describes \textit{what} to compute.
%This fundamental difference of operational vs. denotational is directly reflected in programming languages which build on these two different models of computation: imperative languages follow the operational model of the TM and functional languages basically the denotational model of the LC.
%Although today's computers are basically highly efficient Turing Machines and follow thus the operational model \footnote{TODO: why this is so is probably due to history reasons and because probably also a philosophical problem: when facing the real world we need simply operational models as this is the way to manifest something in the real-world, declarative model resorts more to magic which is not as reliable.} this means that also declarative, functional languages are ultimately translated into an operational model, which is possible because both models are of the same power. This but does not make functional languages operational, what matters here is that they allow to approach a problem from a very different perspective - how it is ultimately executed does not matter and is not visible to the programmer, nor should he or she think about it.
%The conclusion is that because of the different approach of operational vs. denotational, one thinks problems very different in either models which in turn also implies that different paradigms and languages are differently well suited to formulate solutions to problems.
%
%All this ultimately leads to the question of how well the pure functional and object-oriented paradigms are suited to formulate ABS in comparison to each other. Also we are interested in the strengths of both paradigms in general and ask if they apply directly when formulating ABS. In this text we want to give an extensive answer to these questions by first looking closer into the abstractions used in pure FP and OOP to formulate an ABS and what the challenges one encounters in doing so.
%
%\newpage

\section{Publications}
Throughout the course of the Ph.D. four (4) papers were published:

\begin{enumerate}
	\item The Art Of Iterating - Update Strategies in Agent-Based Simulation \cite{thaler_art_2017} - This paper derives the 4 different update-strategies and their properties possible in time-driven ABS and discusses them from a programming-paradigm agnostic point of view. It is the first paper which makes the very basics of update-semantics clear on a conceptual level and is necessary to understand the options one has when implementing time-driven ABS purely functional.
	
	\item Pure Functional Epidemics \cite{thaler_pure_2019} - Using an agent-based SIR model, this paper establishes in technical detail \textit{how} to implement time-driven ABS in Haskell using non-monadic FRP with Yampa and monadic FRP with Dunai. It outlines benefits and drawbacks and also touches on important points which were out of scope and lack of space in this paper but which will be addressed in the Methodology chapter of this thesis.
	
	\item A Tale Of Lock-Free Agents (TODO cite) - This paper is the first to discuss the use of Software Transactional Memory (STM) for implementing concurrent ABS both on a conceptual and on a technical level. It presents two case-studies, with the agent-based SIR model as the first and the famous SugarScape being the second one. In both case-studies it compares performance of STM and lock-based implementations in Haskell and object-oriented implementations of established languages. Although STM is now not unique to Haskell any more, this paper shows why Haskell is particularly well suited for the use of STM and is the only language which can overcome the central problem of how to prevent persistent side-effects in retry-semantics. It does not go into technical details of functional programming as it is written for a simulation Journal.

	\item The Agents' New Cloths? Towards Pure Functional Agent-Based Simulation (TODO cite) - This paper summarizes the main benefits of using pure functional programming as in Haskell to implement ABS and discusses on a conceptual level how to implement it and also what potential drawbacks are and where the use of a functional approach is not encouraged. It is written as a conceptual / review paper, which tries to "sell" pure functional programming to the agent-based community without too much technical detail and parlance where it refers to the important technical literature from where an interested reader can start.
	
	\item Show Me Your Properties! The Potential Of Property-Based Testing In Agent-Based Simulation - This paper introduces property-based testing on a conceptual level to agent-based simulation using the agent-based SIR model and the Sugarscape model as two case-studies. 
\end{enumerate}

\newpage

\section{Contributions}
\begin{enumerate}
	\item This thesis is the first to \textit{systematically} investigate the use of the functional programming paradigm, as in Haskell, to ABS, laying out in-depth technical foundations and identifying its benefits and drawbacks. Due to the increased interested in functional concepts which were added to object-oriented languages in recent years, because of its established benefits in concurrent programming, testing and software-development in general, presenting such foundational research gives this thesis significant impact. Also it opens the way for the benefits of FP to incorporate into scientific computing, which are explored in the contributions below.
	
	\item This thesis is the first to show the use of Software Transactional Memory (STM) to implement concurrent ABS and its potential benefit over lock-based approaches. STM is particularly strong in pure FP because of retry-semantics can be guaranteed to exclude non-repeatable persistent side-effects already at compile time. By showing how to employ STM it is possible to implement a simulation which allows massively large-scale ABS but without the low level difficulties of concurrent programming, making it easier and quicker to develop working and correct concurrent ABS models. Due to the increasing need for massively large-scale ABS in recent years \cite{lysenko_framework_2008}, making this possible within a purely functional approach as well, gives this thesis substantial impact.
	
	\item This thesis is the first to present the use of property-based testing in ABS which allows a declarative specification- testing of the implemented ABS directly in code with \textit{automated} test-case generation. This is an addition to the established Test Driven Development process and a complementary approach to unit testing, ultimately giving the developers an additional, powerful tool to test the implementation on a more conceptual level. This should lead to simulation software which is more likely to be correct, thus making this a significant contribution with valuable impact.

	\item This thesis is the first to outline the potential use of \textit{dependent types} to Agent-Based Simulation on a \textit{conceptual level} to investigate its usefulness for increasing the correctness of a simulation. Dependent types can help to narrow the gap between the model specification and its implementation, reducing the potential for conceptual errors in model-to-code translation. This immediately leads to fewer number of tests required due to guarantees being expressed already at compile time. Ultimately dependent types lead to higher confidence in correctness due to formal guarantees in code, making this a unique contribution with high impact.
\end{enumerate}

\newpage

\section{Thesis structure}
This thesis focuses on a strong narrative which tells the story of \textit{how} to do ABS with pure functional programming, \textit{why} one would do so and when one should \textit{avoid} this paradigm in ABS.

TODO: write when all is finished