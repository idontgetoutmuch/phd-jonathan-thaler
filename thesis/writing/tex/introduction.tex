\chapter{Introduction}
\epigraph{The purpose of abstraction is not to be vague, but to create a new semantic level in which one can be absolutely precise.}{Dijkstra, EWD340}
\label{ch:intro}

% MOTIVATION and AIM
The traditional approach to Agent-Based Simulation (ABS) has so far always been object-oriented, due to the influence of the seminal Sugarscape model \cite{epstein_growing_1996}, in which the authors claim "[..] object-oriented programming to be a particularly natural development environment for Sugarscape specifically and artificial societies generally [..]" (p. 179). This work established the metaphor in the ABS community, that \textit{agents map naturally to objects} \cite{north_managing_2007}, which still holds up today. %TODO can we cite any statistics about number of developed ABS models?

This thesis challenges this metaphor and explores ways of approaching ABS through the \textit{pure} functional programming paradigm using the language Haskell. To the best of the authors knowledge, it is the first one to do so on a \textit{systematical} level, developing a foundation by presenting fundamental concepts and advanced features to show how to leverage the paradigms benefits \cite{hudak_history_2007} to make them available when implementing ABS functionally. By doing this, the thesis shows \textit{how} to implement ABS purely functional and \textit{why} it is of benefit of doing so, what the drawbacks are and also when a pure functional approach should \textit{not} be used. This forms the thesis' general research question \textit{how to implement ABS purely functional and what the benefits and drawbacks are of doing so.} 

% SCOPE
Further, this thesis claims that the ABS community needs functional programming because of its \textit{scientific computing} nature, where results need to be reproducible and correct while simulations should be able to massively scale-up as well. Due to the primarily computational character of most ABS models, not requiring non-deterministic, asynchronous input/output (IO) or direct user-interaction, a pure functional approach should be able to directly deliver these non-functional requirements. The established object-oriented approach needs considerably high effort and might even fail to deliver these objectives due to its conceptually different approach to computing as they lack strong static typing, use mutable shared state and have implicit side effects. 

Further, we regard the functional approach as a way to think and explore ABS in a deeper way - especially to develop a deeper and more complete understanding on the computational structure underlying ABS. It is well known, that functional programming helps in structuring computation in a very clear and precise way, leading to a deeper understanding about problems. So we also see it as a tool for developing abstractions which give us a a deeper understanding of the computational structures involved in ABS. By implementing use-cases, reflecting on them and generalising, we extract implicit knowledge and make it explicit. We hope that this undertaking is to the whole benefit of the ABS discipline and will also feed back into the traditional object-oriented implementation techniques.

\bigskip

% THE PROBLEM, THE GINTIS CASE
Struggles with established ABS approaches are described in \cite{axelrod_chapter_2006}, where Axelrod reports the vulnerability of ABS to misunderstanding. Due to informal specifications of models and change requests among members of a research team bugs are very likely to be introduced. He also reported how difficult it was to reproduce the work of \cite{axelrod_convergence_1995}, which took the team four months due to inconsistencies between the original code and the published paper. The consequence is that counter-intuitive simulation results can lead to weeks of checking whether the code matches the model and is bug-free as reported in \cite{axelrod_advancing_1997}.

The same problem was reported in \cite{ionescu_dependently-typed_2012}, which tried to reproduce the work of Gintis \cite{gintis_emergence_2006}. In his work, Gintis claimed to have found a mechanism in bilateral decentralized exchange, which resulted in Walrasian General Equilibrium without the neo-classical approach of a tatonement process through a central auctioneer. This was a major break-through for economics as the theory of Walrasian General Equilibrium is non-constructive as it only postulates the properties of the equilibrium \cite{colell_microeconomic_1995} but does not explain the process and dynamics through which this equilibrium can be reached or constructed - Gintis seemed to have found just this process.

The authors \cite{ionescu_dependently-typed_2012} failed to reproduce the results and were only able to solve the problem by directly contacting Gintis which provided the code, the definitive formal reference \footnote{It seems that by now, Gintis has made his code, written in Object Pascal, publicly available through his homepage \url{https://people.umass.edu/gintis/}}. It was found that there was a bug in the code leading to the unexpected results, which were seriously damaged through this error. They also reported ambiguity between the informal model description in Gintis paper and the actual implementation.
This lead to a research in a functional framework for agent-based models of exchange as described in \cite{botta_functional_2011} which tried to give a very formal functional specification of the model which comes very close to an implementation in Haskell. The failure of Gintis was investigated more in-depth in the thesis by \cite{evensen_extensible_2010} who got access to Gintis code of \cite{gintis_emergence_2006}. They found that the code didn't follow good object-oriented design principles (all was public, code duplication) and - in accordance with \cite{ionescu_dependently-typed_2012} - discovered a number of bugs serious enough to invalidate the results. 

As ABS is almost always used for scientific research, producing often break-through scientific results as pointed out in \cite{axelrod_chapter_2006}, these ABS need to be \textit{free of bugs}, \textit{verified against their specification}, \textit{validated against hypotheses} and ultimately be \textit{reproducible}. Further, Axelrod explicitly mentions that the ABS community should converge both on standards for testing the robustness of ABS and on its tools.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bigskip

% RESEARCH QUESTION and HYPOTHESEIS
This thesis hypothesises that by using pure functional programming for implementing ABS makes the resulting simulations easier to test and verify, applicable to property-based testing, easy to add parallelism and concurrency, guaranteed to be reproducible already at compile time, have fewer potential sources of bugs and thus can raise the level of confidence in the correctness of an implementation to a new level.

\medskip

Note that this thesis is \textit{not} about comparing the object-oriented and pure functional programming paradigm in the context of implementing ABS. Such an approach would not be fruitful, as too much ink has been spilt already over which paradigm is better / worse. There seems to be no scientific evidence supporting that either one is truly superior over the other; each has its benefits and weaknesses and this thesis aims in finding out what they are when using pure functional programming in ABS.

\section{Contributions}
\begin{enumerate}
	\item To the best knowledge of the author, this thesis is the first to \textit{systematically} investigate the use of the functional programming paradigm, as in Haskell, to ABS, laying out in-depth technical foundations and identifying its benefits and drawbacks. Due to the increased interest in functional concepts added to object-oriented languages in recent years (lambdas and map,filter,reduce in Java 8, rise of functional frameworks in JavaScript, Pythons functional features,...), because of its established benefits in concurrent programming, testing and software-development in general, presenting such foundational research gives this thesis significant impact. Further, the use of functional programming, which focuses on explicit data-flow representation, is a strong match to scientific computing, which is data-centric as well.
	
	\item To the best of the knowledge of the author, this thesis is the first to show the use of Software Transactional Memory (STM) to implement concurrent ABS and its potential benefit over lock-based approaches. STM is particularly strong in pure functional programming because it can be guaranteed  at compile time that retry-semantics exclude non-repeatable persistent side effects. By showing how to employ STM it is possible to implement a simulation which allows massively large-scale ABS but without the low level difficulties of concurrent programming, making it easier and quicker to develop working and correct concurrent ABS models. The use of STM allows to approach concurrency still as a data-flow approach, without cluttering model code with concurrency semantics. This and the fact that we can sell retain certain guarantees about reproducibility when using STM, makes it a highly attractive approach to scientific computing. Further, due to the increasing need for massively large-scale ABS in recent years \cite{lysenko_framework_2008}, making this possible within a purely functional approach as well, gives this thesis substantial impact.
	
	\item To the best of the authors knowledge, this thesis is the first to present the use of property-based testing in ABS, which allows declarative specification-testing of the implemented ABS directly in code with \textit{automated} random test case generation. This is an addition to the established Test Driven Development process and a complementary approach to unit testing, ultimately giving the developers an additional, powerful tool to test the implementation on a more conceptual level. This should lead to simulation software which is more likely to be correct, thus making this a significant contribution with valuable impact.

	%\item To the best of the authors knowledge, this thesis is the first to outline the potential use of \textit{dependent types} to Agent-Based Simulation on a \textit{conceptual level} to investigate its usefulness for increasing the correctness of a simulation. Dependent types can help to narrow the gap between the model specification and its implementation, reducing the potential for conceptual errors in model-to-code translation. This immediately leads to fewer number of tests required due to guarantees being expressed already at compile time. Ultimately dependent types lead to higher confidence in correctness due to formal guarantees in code, making this a unique contribution with high impact.
\end{enumerate}

\section{Publications}
Throughout the course of the Ph.D. five (5) papers were written and attempted to publish, out of which three (3) were accepted and published:

\begin{enumerate}
	\item The Art Of Iterating - Update Strategies in Agent-Based Simulation \cite{thaler_art_2017}; submitted and accepted at the Social Simulation Conference 2017 - This paper derives four different update strategies and their properties possible in time-driven ABS and discusses them from a programming-paradigm agnostic point of view. It is the first paper which makes the very basics of update-semantics clear on a conceptual level and is necessary to understand the options one has when implementing time-driven ABS purely functional. Chapter \ref{ch:impl_abs} builds heavily on the contents of this paper. Further the introduction to ABS in Chapter \ref{sec:method_abs} is covered to a large extent already in this paper.
	
	\item Pure Functional Epidemics \cite{thaler_pure_2018}; submitted and accepted at the IFL Conference 2018 - Using an agent-based SIR model, this paper establishes in technical detail \textit{how} to implement time-driven ABS in Haskell using non-monadic FRP with Yampa and monadic FRP with Dunai. It outlines benefits and drawbacks and also touches on important points which were out of scope and lack of space in this paper but which will be addressed in more detail in this thesis. Chapter \ref{ch:timedriven} is basically an identical copy of this paper, with minor extensions and restructuring. Further the introduction to FRP in Chapter \ref{sec:background_fp} is covered to a large extent already in this paper.
	
	\item A Tale Of Lock-Free Agents \cite{thaler_tale_2018}; submitted to the TOMACS Journal in October 2018 and rejected in March 2019- This paper is the first to discuss the use of Software Transactional Memory (STM) for implementing concurrent ABS both on a conceptual and on a technical level. It presents two case-studies, with the agent-based SIR model as the first and the famous SugarScape being the second one. In both case-studies it compares performance of STM and lock-based implementations in Haskell and object-oriented implementations of established languages. Although STM is now not unique to Haskell any more, this paper shows why Haskell is particularly well suited for the use of STM and is the only language which can overcome the central problem of how to prevent persistent side effects in retry-semantics. Chapter \ref{ch:concurrent_abs} is based on the work of this paper with minor adjustments and extensions.

	\item The Agents' New Cloths? Towards Pure Functional Agent-Based Simulation (TODO cite) submitted and rejected at the Summer Simulation Conference 2019 - This paper summarizes the main benefits of using pure functional programming as in Haskell to implement ABS and discusses on a conceptual level how to implement it and also what potential drawbacks are and where the use of a functional approach is not encouraged. It is written as a conceptual / review paper, which tries to "sell" pure functional programming to the agent-based community without too much technical detail and parlance where it refers to the important technical literature from where an interested reader can start. The introduction to functional programming in Chapter \ref{sec:background_fp} is covered to a large extent already in this paper.
	
	\item Show Me Your Properties! The Potential Of Property-Based Testing In Agent-Based Simulation (TODO cite); submitted and accepted at the Summer Simulation Conference 2019 - This paper introduces property-based testing on a conceptual level to agent-based simulation using the agent-based SIR model and the Sugarscape model as two case-studies. Both Chapters 
\ref{ch:agentspec} and \ref{ch:sir_invariants} of Part IV and the Appendix \ref{app:validating_sugarscape} are substantially expanded discussions of the ideas presented in this paper.
\end{enumerate}


\section{Thesis structure}
%This thesis focuses on a strong narrative which tells the story of \textit{how} to do ABS with pure functional programming, \textit{why} one would do so and when one should \textit{avoid} this paradigm in ABS.

The thesis is divided into 5 parts which act as the thematic narrative throughout the text followed by an Appendix . 

\paragraph{Part I} opens the thesis by laying out the necessary prerequisites necessary to understand the ideas and motivation in the rest of the thesis.
\medskip

Chapter \ref{ch:intro} introduces the problem and presents the motivation, aim and hypotheses.

\medskip

Chapter \ref{ch:background} presents related research and discusses the background necessary to understand the rest of the thesis. It presents a definition of ABS and gives a short introduction to functional programming with advanced topics necessary to understand the concepts in this thesis. Further it discusses the methodology.

\medskip

Chapter \ref{ch:impl_abs} discusses an architectural categorisation on how to implement ABS from a language-agnostic point of view. 

\medskip

\paragraph{Part II} presents \textit{how} to do ABS in pure functional programming. 
\medskip

Chapter \ref{ch:timedriven} derives a time-driven ABS implementation for an agent-based SIR model. Because it is the first chapter discussing how to implement ABS pure functionally, it goes quite into detail to lay out the basic concepts.

\medskip

Chapter \ref{ch:eventdriven} presents an event-driven approach to ABS using an event-driven agent-based SIR model the highly complex Sugarscape model. It takes up the concepts derive in the previous Chapter \ref{ch:timedriven}, generalises them and pushes them forward to a more generic solution. Further it also gives a brief outline how to transform the time-driven SIR implementation into an event-driven one.

%\medskip

%Chapter \ref{ch:structure_abs_computation} takes a highly abstract look at the computational approach and structures, derived in quite an ad-hoc fashion in the previous two Chapters \ref{ch:timedriven}, \ref{ch:eventdriven}. It distils the essence of the SF and MSF constructs and shows that by looking at their building blocks of \textit{closures} and \textit{continuations}, SF and MSF can be regarded as very simple, immutable, pure functional objects. Further it looks at how they relate to existing computational structures like Monads, Comonads and Arrows.

\medskip

\paragraph{Part III} presents parallel computation in ABS as the first of two parts of \textit{why} pure functional ABS is of benefit.
\medskip

Chapter \ref{ch:parallelism_ABS} shows rather briefly how to achieve deterministic and pure parallelism in pure functional ABS. 

\medskip

Chapter \ref{ch:concurrent_abs} presents an in-depth discussion on how to implement concurrent ABS using Software Transactional Memory.

\medskip

\paragraph{Part IV} presents property-based testing in ABS as the second of two parts of \textit{why} pure functional ABS is of benefit.
\medskip

Chapter \ref{ch:agentspec} shows how to use property-based testing to implement a full agent-specification test of the event- and time-driven SIR model in code and run it as property-tests.

\medskip

Chapter \ref{ch:sir_invariants} shows how to derive and encode invariants, the dynamics of the simulation must uphold in property-tests. It also shows how to compare the dynamics of two implementations of the same underlying model, namely the the time- and event-driven SIR implementations. Further it shows how to put model specifications into code and check them with property-tests: it shows how to compare the SD simulation to the agent-based one.

\medskip

\paragraph{Part V} is the closing part which looks at the thesis as a whole, discusses and concludes.
\medskip

%Chapter \ref{ch:gintis_case} presents the case of an agent-based model which results lead to high hopes in the field of computational economics, only to be found out that it had several bugs, weakening the results. In this chapter we ask whether a pure functional approach would have been of benefit in this case; more specifically, could those bugs have been prevented with a pure functional approach?

%\medskip

Chapter \ref{ch:discussion} puts all parts in perspective to each other and the initial motivation and hypothesis and discusses them under these viewpoints.

\medskip

Chapter \ref{ch:conclusion} concludes, briefly outlines unanswered questions and presents further research.

\paragraph{Appendices} contains additional material which relates to the overall research of this thesis but would be out of context in the respective chapters referring to it.
\medskip

Appendix \ref{app:sd_simulation} shows a pure functional implementation of a System Dynamics (SD) SIR simulation using Functional Reactive Programming (FRP). It shows that we can directly encode SD specification in pure functional FRP code with extremely high guarantees in correctness. We use this implementation in Chapter \ref{ch:sir_invariants} where we test the agent-based SIR dynamics against the SD ones.

\medskip

Appendix \ref{app:equilibrium_totality} discusses the deep question of whether it is possible to test or guarantee that a correct implementation of the SIR model does terminate or not. This question arises in the context of Chapter \ref{ch:sir_invariants} and \ref{ch:agentspec}.

\medskip

Appendix \ref{app:validating_sugarscape} contains a brief overview over the validation process we went through when trying to get our Sugarscape implementation from Chapter \ref{ch:eventdriven} in line with the results from the original specification \cite{epstein_growing_1996}. Further we show how we can use property-based testing in an exploratory model to formulate and test hypotheses.