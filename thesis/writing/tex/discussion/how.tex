\section{How}
The central question which needed to be answered first was \textit{how} ABS could be done pure functionally, as there didn't exist any research which offered a systematic solution to that problem. More specifically, it was unclear how to represent agents, how to express agent identity, local agents state, changing behaviour and interactions amongst agents and the environment. After all this is straightforward in OO due to mutable shared state encapsulated in objects.

% the answer
The solution was to use arrowized FRP both in the pure implementation of Yampa and the monadic version as in the library Dunai. Building on top of them allowed us to implement pro-activity of agents, encapsulation of local agent state, an environment as shared mutable state and synchronous agent-interactions based on an event-driven approach. The central concept behind these approaches are Signal Functions (SF), generalised in Dunai to Monadic Stream Functions (MSF), which are implemented using closures and continuations, fundamental building blocks and concepts of pure functional programming. 

% WARNING: don't fall again into the pitfall of opinionated OO criticism, this can burn me as it is too opinionated. simply refer to what we cannot do properly with java objects

% 1. SFs/MSFs can be seen as simple objects
SF and MSF can be seen as very simple \textit{immutable} objects with a single method following a \textit{shared nothing} semantics as mentioned in Chapter \ref{ch:structure_abs_computation} already. This interpretation and the fact that we seem to achieve encapsulation of local agent state and interactions obviously raises the question if agents actually \textit{do} map naturally to objects - after all, despite being in a pure functional setting, we are talking about objects again!

% 2. it seems that agents map to objects, but what are objects?
It seems that we indeed have to agree that agents do actually map naturally to objects. However, throughout the course of this thesis it became clear that we have to think objects in a much broader context than the one of existing OO terminology as in the popular family of Java, C++ and Python. The reason that we have shown that we can represent agents as objects also in a purely functional way, leads us to the question, what actually constitutes objects and we have to be careful not to confuse the \textit{concept} of objects with their \textit{implementation} within a language.

\medskip

% 3. what are objects

There does not exist a commonly agreed upon definition of objects and OO but it is agreed that the original idea of objects was conceived by Alan Kay, the inventor of the SmallTalk language \footnote{\url{http://wiki.c2.com/?HeInventedTheTerm}}. TODO: citation? and it contained the fundamental concepts \footnote{\url{http://wiki.c2.com/?AlanKaysDefinitionOfObjectOriented}}:

TODO
http://wiki.c2.com/?DefinitionsForOo
http://wiki.c2.com/?HeInventedTheTerm
http://wiki.c2.com/?AlanKaysDefinitionOfObjectOriented

%It is a fact that simulations are about consuming, processing and producing data. ABS being simulation methodology is no exception to that fact. Unfortunately, due to OO lack of rigour theoretical foundations, OO as it is used today is \textit{not} very good at representing and manipulating pure data and its data-flow because of two things: \textit{mutable shared state} and explicitly associate data-types and functions(methods)/code/behaviour.

%FROM https://www.youtube.com/watch?v=QM1iUe6IofM&feature=youtu.be
%Inheritance is not relevant any more: it has come to a widely agreement amongst OO developers that inheritance should be avoided: https://www.javaworld.com/article/2073649/why-extends-is-evil.html . Note that we are speaking about subclassing not implementing an interface, which is something entirely different
%Polymorphism: is not unique to OO and exists in non-OO languages as well and plays a central role in Haskell (and ML languages). Further it is possible to implement polymorphic code in C
%Encapsulation: this is seen as the major strength of OO but unfortunately it does not work at a fine grained level of code in todays OO. The original idea was indeed great and it is no coincidence that my implementation ended up with a variation of that as well as Erlang: encapsulate state behind a public interface and interact with it through messages (TODO: fill in alan kay). The very central point of messages though was that they followed "shared nothing" semantics, meaning that no references or pointers could be contained in that message as this would immediately result in a violation of the public interface and ultimately breaks encapsulation. 
%OO dominates the industry since around mid 90s. There are varying opinions on that but a major influence to popularise OO was Java, which made its first appearance in 1996. Java was a much easier approach to OO than existing ones e.g. in C++ and VB: it abandoned multiple inheritance, introduced interfaces, was cross-platform, provided high quality libraries including a GUI framework (GUI programming was the way to go in the 90s until it got abandoned in 00s with the emergence of Web 2.0), C/C++ syntax made it easy to pick up, avoided header-files, abandoned pointers and memory management and added garbage collection which made applications a lot safer.

% TODO: need to discuss the problem of shared state. state per se is not necessarily a problem and ever program has state in some form. how explicit it is represented is often used as classification between different kind of paradigms e.g. it has been said that functional programming is stateless but that is obviously not true, state is all over the place but it is very very contained, well behaved and explicit. with shared mutable state this is not the case anymore and we get into the troube of data-dependencies and orderings. this is exactly what we encountered when having introduced a global environment in Sugarscape: although our state is referential transparent and pure functional, they way we used it is globally and we run in ordering issues.

% TODO: isnt shared state also a problem in erlang? after all we can send Pids around and interact with those processes as soon as another process has access to a Pid. In which way is it different to reference passing in OO? There seems to be no difference... so maybe the anti OO argument is not that strong after all and my argument is simply weak or wrong? 

%TODO: i REALLY need to find proper literature / research / evidence which shows the problematic nature of modern OO: mutable shared state which is tied to code. Inheritance and open recursion gives the rest. the problem is that deeply linking \textit{shared mutable} state to its code is the path to failure: abstraction breaks, concurrency and parallelism becomes hard and breaks abstraction, data-driven programming becomes difficult (although that got addressed by adding functional features). NOTE: my approach and erlang have state and behaviour as well but in our case the state is shared nothing and immutable (yes in Haskell we update the agents state but that happens ultimately through closures and continuation in a referential transparent way and still no state is shared between agents. the environment is an exception to some extent as agents can access it globally: this works but requires a specific ordering either through sequential access or STM. this is no different than in an erlang implementation of sugarscape: there needs to be some arbitration of concurrent access). TODO: isnt there some fundamental research on that issue out there?
% TODO: maybe these act as a starting point?
% https://www.yegor256.com/2016/08/15/what-is-wrong-object-oriented-programming.html
% https://dl.acm.org/citation.cfm?id=1806847
% https://web.cs.ucdavis.edu/~filkov/papers/lang_github.pdf "Most notably, it does appear that strong typing is modestly better than weak typing, and among functional languages, static typing is also somewhat better than dynamic typing" "We also find that functional languages are somewhat better than procedural languages" but modest effects
% https://www.javaworld.com/article/2073649/why-extends-is-evil.html
% READ extension problem paper
% READ Ted Kaminskis thesis

%This was by no means clear in the early-to-mid 1990s where the OO paradigm was seen as a silver bullet to the problems of programming: a whole software industry had to re-learn best practices, patterns \cite{gamma_design_1994} and how to avoid pitfalls and bad code \cite{fowler_refactoring:_2012}. Thus we cannot blame \cite{epstein_growing_1996} for advertising OO as the ways to implement ABS, at that time it seemed indeed to be the right thing to do. 

%The combination of both was exactly the sales pitch of OO for the last 20+ years. Unfortunately this combination leads to nasty bugs due to shared mutable state, deeply complex object hierarchies due to inheritance overuse which also fix behaviour at compile time, open recursion which in the end costs the potential for higher degree of correctness, ease of parallelism and concurrency and the use of property-based testing. Thus we need to separate both: what we need is immutable, shared-nothing state allowing for a data-centric approach \textit{and} an interaction mechanism which allows agents to communicate with each other.

% 4. implementation of objects: the problems: data-driven programming is difficult, not really encapsulating and shared mutable state makes concurrency and testing a lot harder. this sound as a contradition but it has been shown that despite objects claim they compose and enforce encapsulation, they do not.
% https://dl.acm.org/citation.cfm?doid=242224.242415
The original \textit{concepts} of objects and OO vary considerably from how objects and OO is \textit{implemented} today in the family of popular OO languages like Java, C++ and Python. The most substantial different to the original definition of Kay is that messages are synchronous - the object cannot decide to ignore it - and messages are not pure date - they do not follow a shared nothing semantics.
This leads to the failure of objects to compose behaviour and encapsulate data properly \cite{bill_what_2017}, \cite{erkki_lindpere_why_2013}. Ironically, this has always been the main argument for advertising the use of object oriented programming. Why is this so?
The reason for this is that objects hide both \textit{mutation} and \textit{sharing through pointers or references} of object-internal data. This makes data-flow mostly implicit due to the side-effects on the mutable data which is globally scattered across objects. To deal with the problem of composability and implicit data-flow the seminal work \cite{gamma_design_1994} put forward the use of \textit{patterns} to organize objects and their interaction. Other concepts, trying to address the problems, were the SOLID principles and Dependency Injection. 

% 4a this leads to an inherent difficulty to follow data-flow in an OO program and also makes it very difficult in concurrent settings as semantics of synchronisation "bleed" out of the object, breaking encapsulation. 
Despite these advances in understanding the OO paradigm and how to use it properly, the increased complexity leads to an inherent difficulty to express and follow data-flow in an OO program and exploit parallelism and concurrency due to mutable shared state. Even worse, concurrency breaks encapsulation of objects as well and prevents composing them. 

The rise of functional concepts in OO languages in the last years are a strong indication that OO is lacking features which have existed in FP for decades. Java 8 added lambda expressions and functional style programming using map, fold, reduce, filter, which together with lambdas allow a data-flow oriented approach to computing. Python, which surges in popularity within the OO family of languages, allows very data-flow centric and functional style of programming through lambda functions, list comprehensions and other functional features as it does not require programmers to stick to the OO paradigm. Popularisation of JavaScript frameworks like React, Elm and Purescript, which emphasise a functional, data-flow driven approach of web-programming. Thus it seems that functional concepts overcome the weakness of OO to model explicit, immutable data-flows which can be exploited towards easier parallelisation and concurrency.

% 5. our approach is one of very simple, pure functional, immutable objects and we have shown that they indeed allow us to apply concurrency and property-based testing
All these properties of explicit data-flow and applicability of parallelism and concurrency are highly desirable when implementing Simulations: it is a fact that simulations are data-centric, that is they are all about about consuming, processing and producing data and they have to do it fast and correct. ABS being simulation methodology is no exception to that fact.

The question is then why not use toolkits like Matlab or R - after all they are completely data-centric? This would be the other extreme, just like OO is and we would run into difficulties as well. The point is that ABS is not purely data-centric either and is indeed richer: agents can interact with each other and with an environment. So we have a tension here: ABS is data-centric on the one hand, and interaction-centric on the other - can we combine both worlds? Our approach is \textit{one} answer to do that in a pure, strong statically typed language - Haskell. It can be seen as an object-centric approach, which \textit{implements} a very simple \textit{concept} of shared-nothing, immutable, pure functional objects.

TODO: this data-object duality also exists in mathematics for example natural numbers are just data, groups are objects.