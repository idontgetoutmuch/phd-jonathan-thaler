\chapter{General Conclusion}
%\epigraph{A good Ph.D. thesis is asking more questions than it answers.}{J. G.}
\label{ch:conclusion}

This thesis has shown at length \textit{how} pure functional ABS is possible in a robust maintainable way and \textit{why} it is of benefit. Each chapter gives strong evidence to our claim that pure functional programming has indeed its place in ABS is valid - especially a full implementation in Sugarscape is a highly complex and non-trivial matter and our highly structured and robust approach can be seen as proof of success. At the same time we conclude that it is yet too early to pick up this paradigm for ABS. We think that engineering a proper implementation of a complex ABS model takes substantial effort in pure functional programming due to different techniques required and due to its strong static type system. We believe that at the moment such an effort pays off only in cases of high-impact and large-scale simulations which results might have far-reaching consequences, for example influence policy decisions. It is only there where the high requirements for reproducibility, robustness and correctness provided by functional programming are really needed. Still, we plan on distilling the developed techniques into a general purpose ABS library. This should allow implementing models much easier and quicker, making the pure functional programming approach an attractive alternative for prototyping, opening the direction for a broad use of functional programming in the field of ABS.

Further, this thesis deepened the understanding of the structure of agent based computation by expressing it in a pure functional context, leading to a deeper and more general understanding of agents, how they can be represented and whether they indeed map naturally to objects or not. This central question of whether they map naturally to objects or not, permeates the whole thesis and drives it forward. The last chapter gave an in-depth answer of that question and we see that objects indeed have their place in ABS but, as we have carefully explained, the question is what objects constitute. By approaching the problem from a pure functional perspective, we also arrived at a deeper and broader understanding of objects, not only restricted to the traditional object-oriented definition of Java, C++ or Python. So we can say: \textit{"Yes, agents map naturally to objects, but we have to be precise what constitutes objects."}. Whether they are newtypes, tuples, (Generalised) Algebraic Data Types, pure functions, Monads, Comonads, Arrows, SF, MSF, Actors or object-oriented objects, they are all valid ways of representing agents with varying degree of abstraction, flexibility and power and they all come with their benefit and drawbacks, which have to be clearly understood together with the problem to solve. This thesis simply added a promising new tool to the family of existing ones and only time will tell whether this tool is indeed as valuable as hinted in this thesis.

\section{Further Research}
\subsection{A general purpose library}
For pure functional ABS to ever reach a larger audience and acceptance, it will need a lot of support, especially in the form of a well designed, easy to use, robust, correct, high quality Haskell library. Designing and developing such a library is research on its own as it needs to combine all the separate concepts introduced in this thesis into one code base. We hope that from this development further insights into ABS in general and pure functional ABS in particular will emerge, which can then be published to the community.

%generalise concepts explored into a pure functional ABS library in Haskell (called chimera)
%stm based concurrency for event-driven ABS using parallel DES. challenge is the time-warp implementation using monads. in general it should be easy to roll-back agents actions but with monads we have to be careful - for some monads rolling back is not neccessary e.g. rand and reader, for others it is, and for some it is impossible e.g. IO

\subsection{Dependent types}
We see this thesis as an intermediary and necessary step towards dependent types for which we first needed to understand the potential and limitations of a non-dependently typed pure functional approach in Haskell. Dependent types are extremely promising in functional programming as they allow us to express stronger guarantees about the correctness of programs and go as far as allowing to formulate programs and types as constructive proofs, which must be total by definition \cite{altenkirch_pi_2010, altenkirch_why_2005, thompson_type_1991}.

To the best of our knowledge, so far no research using dependent types in agent-based simulation exists at all. We aim to explore this for the first time and ask more specifically how we can add dependent types to our pure functional approach, which conceptual implications this has for ABS and what we gain from doing so. We plan on using Idris \cite{brady_idris_2013} as the language of choice as it is very close to Haskell with focus on real-world application and running programs as opposed to other languages with dependent types like Agda and Coq.

We hypothesise that dependent types could help ruling out even more classes of bugs at compile time and encode invariants and model specifications on the type level, which implies that we don't need to test them using property testing. This would allow the ABS community to reason about a model directly in code. We think that a promising approach is to follow the work of \cite{brady_programming_2013, brady_state_2016, fowler_dependent_2014} in which the authors utilize Generalised Algebraic Data Types to implement an indexed Monad, which allows to implement correct-by-construction software. % We have already started to outline a few core principles in the Appendix \ref{app:equilibrium_totality}, but we conjecture that the true benefit is yet to be revealed.

\subsection{Shallow encoding}
Using arrowized FRP with pure signal functions as in Yampa and Monadic Stream Functions as in Dunai is only \textit{one} approach to ABS. As we have shown at length in this thesis, although it is a robust and maintainable approach with highly valuable and promising benefits, there are other potential approaches left unexplored.

A standard approach to encode a problem in Haskell is by designing an embedded domain specific language (EDSL) for that (domain) problem and then implement the problem at hand in this specifically designed language. One has to distinguish between a \textit{deep} and \textit{shallow} encoding: in the former one, the EDSL is expressed "deeply" using direct data types and functions of the host language Haskell - our approach using SF and MSF is of this nature.

The shallow encoding approach on the other hand provides a language on top of the host language, often expressed using Generalised Algebraic Data Types which are used to encode a problem as a data structure where the execution of the problem is done by an interpreter which evaluates this data structure and translates it to the semantics of the host language. An example of a shallow embedded EDSL is a language for mathematical expressions consisting of constants, multiplication and subtractions, which are represented as syntax trees and then translated into Haskell multiplication and subtraction to arrive at the final result.

The main benefit of a shallow encoding is that, similar to tagless final, it allows to separate definition from implementation due to the separation of the EDSL and its interpretation. This allows to strictly separate implementation from specification, composes very well and thus should also be easy to test as mocking of parts is straightforward.

\medskip

A popular and powerful approach to implement shallow EDSLs are so called \textit{Freer Monads} \cite{rivas_notions_2014}. One big advantage of them is that they free one from the ordering of effects imposed through Monad Transformers as already mentioned in Chapter \ref{sec:background_fp}. Unfortunately, Freer Monads seem to be somewhere around 30 times slower than the equivalent MTL code with a complexity of $O(n^2)$ \cite{maguire_freermonads_better}. For IO bound problems like business applications, this is not a big deal but as already mentioned, ABS are almost always never IO bound, so raw computation is all what counts and this is undoubtedly worse with Freer Monads. Even though there seem to be a better encoding possible, which is about 2x slower than MTL \cite{maguire_freermonads_fast} the fact that we are already performance limited in our deep encoding makes the Free Monads approach not very appealing \cite{maguire_higherorder_effects}. Still, we hypothesise that it will be highly interesting and valuable research with a strong focus on formal reasoning about correctness.

%Other criticism of Freer Monads are: \url{https://medium.com/barely-functional/freer-doesnt-come-for-free-c9fade793501} are: boilerplate code which though can be generated automatically by some libraries, performance when not IO based because the program is bascially a data-structure which is interpreted, concurrency seems to be tricky, 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% NOTES
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%- FREE MONADS % http://www.haskellforall.com/2012/07/purify-code-using-free-monads.html http://comonad.com/reader/2011/free-monads-for-less/, https://stackoverflow.com/questions/13352205/what-are-free-monads

\subsection{Actor-based ABS}
We hypothesise that the future of concurrent, agent interaction centric ABS lies in a functional, actor based concurrent approach. It required the full thesis to come to this conclusion thus this thesis only scratched the surface of the potential for actor based ABS as in Erlang or Cloud Haskell. We think that this topic deserves rigorous research as well as it is currently strongly neglected with only very few papers existing, which just scratch the surface. The idea seems compelling: functional programming with an actor language seems the way to do ABS in the future as it gives us almost all properties introduced in this thesis with the exception that performance is substantially better and agent interactions are a lot easier and naturally expressed.

There have been a few attempts on implementing the actor model in real programming languages where the most notable ones are Erlang and Scala. Both languages saw some use in implementing ABS with notable papers being \cite{bezirgiannis_improving_2013,di_stefano_using_2005, di_stefano_exat:_2007,  sher_agent-based_2013, varela_modelling_2004}

%Scala is a modern mixed paradigm programming language, which also allows functional programming and also incorporates a library for the actor model. It also saw the use in the implementation of ABS with a notable paper \cite{krzywicki_massively_2015} and ScalABM \footnote{https://github.com/ScalABM} which is alibrary for ABM in economics.

%The paper of \cite{jennings_agent-based_2000} gives an excellent overview over the strengths and weaknesses of agent-based software engineering, which can be directly applied to both Erlang and Scala.

Further, process calculi like the CSP \cite{hoare_communicating_1985} and $\pi$-Calculus \cite{milner_communicating_1999} become applicable in the context of an Actor Model, which should allow to actually \textit{prove} the correctness of a specification. Due to the direct mapping of the process calculi languages to Erlang we see this as highly promising.

%Due to the very different approach and implications the actor model of concurrency implies, we don't explore it further and leave it for further research as it is beyond the focus of the thesis.

\subsection{A theory of pure functional agents}
The work in this thesis is quite applied, with a software-engineering heavy approach and in general does not follow a grand underlying formal theory of (pure functional) agents. The reason for that is, that to the best knowledge of the author, such a theory does not (yet) exist and this thesis' rather practical and experimental approach of distilling out certain patterns and recurring concepts of ABS computation, shows that.

Still, after having investigated the underlying concepts behind SF and MSF, namely continuations in the discussions, it became clear, that the basic computational concepts of our pure functional approach is closely related to \textit{coalgebras}. %It might have been obvious to certain people from the beginning, to the author is was not, which is why this thesis has this applied character instead of a rather formal, theoretical approach, as it is the case in the field of Mathematics or theoretical Computer Science.
% Codata 
%- https://www.javiercasas.com/articles/codata-in-action/
Another closely related concept here is \textit{codata} \cite{downen_codata_2019}. Whereas in \textit{data}, we construct a complex (opaque) data type from primitive types (data definitions in Haskell), in \textit{codata} we extract components from a complex (opaque) data type through eliminators. Put shortly, data is concerned how values are constructed and codata is concerned how those values are used \cite{downen_codata_2019} - data types are directly observable, codata types are only indirectly observable through their interface. Again, this is conceptually closely related to object-oriented programming and the authors of \cite{downen_codata_2019} believe that codata is a common ground between functional and object-oriented programming. Yet another concept, which has close relations to objects are \textit{comonads} \cite{uustalu_essence_2006}. They can be seen as a structure with notions of  context-dependent computation or streams, which ABS can be seen as of.

%%- Conal Elliott has examined a comonadic formulation of functional reactive programming http://conal.net/blog/posts/functional-interactive-behavior
%- what about comonads? read essence dataflow paper \cite{uustalu_essence_2006}: monads not capable of stream-based programming and arrows too general therefor comonads, we are using msfs for abs therefore streambased so maybe applicable to our approach/agents=comonads. comonads structure notions of context-dependent computation or streams, which ABS can be seen as of. this paper says that monads are not capable of doing stream functions, maybe this is the reason why i fail in my attempt of defining an ABS in idris because i always tried to implement a monad family. stopped at comonad section, continue from there. understand comonads: https://www.schoolofhaskell.com/user/edwardk/cellular-automata and 
%https://kukuruku.co/post/cellular-automata-using-comonads/ and 
%https://chshersh.github.io/posts/2019-03-25-comonadic-builders
%- comonads https://fmapfixreturn.wordpress.com/2008/07/09/comonads-in-everyday-life/
%
%% STEP 2: co-monads are objects,
%- comonads are objects very important and closely related http://www.haskellforall.com/2013/02/you-could-have-invented-comonads.html
%
%% STEP 3: agents are objects?
%- if conal elliott can make a comonadic formulatin of FRP and comonads are objects, then i guess i am very close to a pure functional representation of objects? pure functional objects?

What is striking is that those concepts are conceptually closely related to object-oriented programming and have been used to model that paradigm, thus it seems that we have come around a full circle and found a potential link between our pure functional and the established object-oriented approach to ABS. This implies that there might lurk some programming paradigm agnostic, unified theory of agents as used in ABS somewhere behind these concepts. We believe that such a theory would help ABS to put itself on solid formal grounds, connect it to other areas of computation and other sciences and ultimately be a powerful tool to investigate certain aspects of models more rigorously and be of help in specification, validation and verification.