\chapter{General Conclusion}
%\epigraph{A good Ph.D. thesis is asking more questions than it answers.}{J. G.}
\label{ch:conclusion}

This thesis has shown at length \textit{how} pure functional ABS is possible in a robust maintainable way and \textit{why} it is of beneficial. Each chapter gives strong evidence as to our claim that pure functional programming indeed has its place in ABS is valid. Particularly, a full implementation in Sugarscape is a highly complex and non-trivial matter and our highly structured and robust approach can be seen as proof of success. At the same time we conclude that it is still too early to pick up this paradigm for ABS. We think that engineering a proper implementation of a complex ABS model takes substantial effort in pure functional programming, due to the different techniques required and due to its strong static type system. We believe that at the moment, the effort pays off only in cases of high-impact and large-scale simulations, the results of which might have far-reaching consequences, for example influencing policy decisions. It is only there where the high requirements for reproducibility, robustness and correctness provided by functional programming are really needed. Still, we plan on distilling these techniques into a general-purpose ABS library. This should allow for the implementation of models much more easily and quickly, making the pure functional programming approach an attractive alternative for prototyping, opening the direction for a broad use of functional programming in the field of ABS.

Furthermore, this thesis deepened the understanding of the structure of agent-based computation by expressing it in a pure functional context, leading to a deeper and more general understanding of agents, how they can be represented and whether they indeed map naturally to objects or not. The last chapter gave an in-depth answer to that question and we see that objects indeed have their place in ABS. But, as we have carefully explained, the question is what objects constitute. By approaching the problem from a pure functional perspective, we also arrived at a deeper and broader understanding of objects, not only restricted to the traditional object-oriented definition of Java, C++ or Python. So we can say: \textit{"Yes, agents map naturally to objects, but we have to be precise what constitutes objects."}. This thesis simply added a promising new tool to the family of existing ones and only time will tell whether this tool is indeed as valuable as hinted in this thesis.

\section{Further Research}
\subsection{A General Purpose Library}
For pure functional ABS to reach a an ever larger audience and have acceptance, it will need a lot of support, especially in the form of a well-designed, easy to use, robust, correct, high quality Haskell library. Designing and developing such a library is a full research project on its own, as it needs to combine all the separate concepts introduced in this thesis into one code base. We hope that from this development further insights into ABS in general, and pure functional ABS in particular will emerge, which can then be published to the community.

\subsection{Dependent Types}
We see this thesis as an intermediary and necessary step towards dependent types, for which we initially needed to understand the potential and limitations of a non-dependently typed pure functional approach in Haskell. Dependent types are highly promising in functional programming as they allow us to provide stronger guarantees about the correctness of programs and go as far as allowing to formulate programs and types as constructive proofs, which must be total by definition \cite{altenkirch_pi_2010, altenkirch_why_2005, thompson_type_1991}.

To the best of our knowledge, so far, no research using dependent types in agent-based simulation exists at all. We aim to explore this for the first time and ask more specifically how we can add dependent types to our pure functional approach, what conceptual implications this has for ABS, and what we gain from doing so. We plan on using Idris \cite{brady_idris_2013} as the language of choice, as it is very close to Haskell with focus on real-world application and running programs as opposed to other languages with dependent types like Agda and Coq.

We hypothesise that dependent types could help in ruling out even more classes of bugs at compile time and encode invariants and model specifications on the type level, which implies that we don't need to test them using property testing. This would allow the ABS community to reason about a model directly in code. We think that a promising approach is to follow the work of \cite{brady_programming_2013, brady_state_2016, fowler_dependent_2014} in which the authors utilize Generalised Algebraic Data Types to implement an indexed Monad, which allows for implementing correct-by-construction programs.

\subsection{Shallow Encoding}
Using Arrowized FRP with pure signal functions as in Yampa and Monadic Stream Functions as in Dunai is only \textit{one} approach to ABS. As we have shown at length in this thesis, although it is a robust and maintainable approach with highly valuable and promising benefits, there are other potential approaches left unexplored.

A standard approach to encode a problem in Haskell is by designing an embedded domain specific language (EDSL) for that (domain) problem and then implement the problem at hand in this specifically designed language. One has to distinguish between a \textit{deep} and \textit{shallow} encoding: in the former, the EDSL is expressed "deeply" using direct data types and functions of the host language Haskell - our approach using SF and MSF is of this nature.

The shallow encoding approach, on the other, hand provides a language on top of the host language often expressed using Generalised Algebraic Data Types, which are used to encode a problem as a data structure. The execution of the problem is done by an interpreter that evaluates this data structure and translates it to the semantics of the host language. An example of a shallow embedded EDSL is a language for mathematical expressions consisting of constants, multiplication and subtractions, which are represented as syntax trees and then translated into Haskell multiplication and subtraction to arrive at the final result.

The main benefit of a shallow encoding is that, similarly to tagless final, it allows us to separate definition from implementation due to the separation of the EDSL and its interpretation. This allows to strictly separate implementation from specification, composes very well, and thus should also be easy to test, as mocking of parts is straightforward.

\medskip

A popular and powerful approach to implement shallow EDSLs are so called \textit{Freer Monads} \cite{rivas_notions_2014}. One big advantage of them is that they free one from the ordering of effects imposed through Monad Transformers as already mentioned in Chapter \ref{sec:background_fp}. Unfortunately, Freer Monads seem to be around 30 times slower than the equivalent MTL code with a complexity of $O(n^2)$ \cite{maguire_freermonads_better}. For IO bound problems like business applications, this is not a big deal but as already mentioned, ABS are almost always never IO bound, so raw computation is all what counts and this is undoubtedly worse with Freer Monads. Even though there seems to be better encoding possible, that is about 2 times slower than MTL \cite{maguire_freermonads_fast}, the fact that we are already performance limited in our deep encoding makes the Free Monads approach not very appealing \cite{maguire_higherorder_effects}. Still, we hypothesise that it will be highly interesting and valuable research with a strong focus on formal reasoning about correctness.

%Other criticism of Freer Monads are: \url{https://medium.com/barely-functional/freer-doesnt-come-for-free-c9fade793501} are: boilerplate code which though can be generated automatically by some libraries, performance when not IO based because the program is bascially a data-structure which is interpreted, concurrency seems to be tricky, 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% NOTES
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%- FREE MONADS % http://www.haskellforall.com/2012/07/purify-code-using-free-monads.html http://comonad.com/reader/2011/free-monads-for-less/, https://stackoverflow.com/questions/13352205/what-are-free-monads

\subsection{Actor-Based ABS}
We hypothesise that the future of concurrent, agent interaction centric ABS lies in a functional, actor based concurrent approach. This hypothesis required the full thesis to come to this conclusion. Consequently, this thesis has only scratched the surface of the potential for actor-ased ABS as in Erlang or Cloud Haskell. We think that this topic deserves rigorous research as well, as it is currently strongly neglected with very few papers existing that only just scratch the surface. The idea is compelling: Functional programming with an actor language seems to be the way to do ABS in the future as it gives us almost all the properties introduced in this thesis, with the exception that the performance is substantially better and agent interactions are a lot easier and naturally expressed.

There have been a few attempts to implement the actor model in real programming languages, the most notable ones are Erlang and Scala. Both languages saw some use in implementing ABS with notable papers being \cite{bezirgiannis_improving_2013,di_stefano_using_2005, di_stefano_exat:_2007,  sher_agent-based_2013, varela_modelling_2004}.

%Scala is a modern mixed paradigm programming language, which also allows functional programming and also incorporates a library for the actor model. It also saw the use in the implementation of ABS with a notable paper \cite{krzywicki_massively_2015} and ScalABM \footnote{https://github.com/ScalABM} which is alibrary for ABM in economics.

%The paper of \cite{jennings_agent-based_2000} gives an excellent overview over the strengths and weaknesses of agent-based software engineering, which can be directly applied to both Erlang and Scala.

Furthermore, process calculi like the CSP \cite{hoare_communicating_1985} and $\pi$-Calculus \cite{milner_communicating_1999} become applicable in the context of an Actor Model, which should allow us to actually \textit{prove} the correctness of a specification. Due to the direct mapping of the process calculi languages to Erlang we see this research as highly promising.

\subsection{A Theory of Pure Functional Agents}
The work in this thesis is quite applied and methodological, with a heavy software-engineering approach. In general, it does not follow a grand underlying formal theory of (pure functional) agents. The reason for that is, that to the best knowledge of the author, such a theory does not (yet) exist and this thesis' rather practical and methodological approach of distilling out certain patterns and recurring concepts of ABS computation, shows that.

However, after having investigated the underlying concepts behind SF and MSF, namely continuations in the discussion of Chapter \ref{sec:agents_to_objects}, it became clear that the basic computational concepts of our pure functional approach are closely related to \textit{coalgebras}. 

%- https://www.javiercasas.com/articles/codata-in-action/
Another closely related concept here is \textit{codata} \cite{downen_codata_2019}. Whereas in \textit{data}, we construct a complex (opaque) data type from primitive types (data definitions in Haskell), in \textit{codata} we extract components from a complex (opaque) data type through eliminators. In short, data is concerned with how values are constructed and codata is concerned with how those values are used \cite{downen_codata_2019}. Data types are directly observable, but codata types are only indirectly observable through their interface. Again, this is conceptually closely related to object-oriented programming and the authors of \cite{downen_codata_2019} believe that codata is a common ground between functional and object-oriented programming. Yet another concept, which is closely relations to objects are \textit{comonads} \cite{uustalu_essence_2006}. They can be seen as a structure with notions of context-dependent computation or streams, which ABS can be seen as of.

%%- Conal Elliott has examined a comonadic formulation of functional reactive programming http://conal.net/blog/posts/functional-interactive-behavior
%- what about comonads? read essence dataflow paper \cite{uustalu_essence_2006}: monads not capable of stream-based programming and arrows too general therefor comonads, we are using msfs for abs therefore streambased so maybe applicable to our approach/agents=comonads. comonads structure notions of context-dependent computation or streams, which ABS can be seen as of. this paper says that monads are not capable of doing stream functions, maybe this is the reason why i fail in my attempt of defining an ABS in idris because i always tried to implement a monad family. stopped at comonad section, continue from there. understand comonads: https://www.schoolofhaskell.com/user/edwardk/cellular-automata and 
%https://kukuruku.co/post/cellular-automata-using-comonads/ and 
%https://chshersh.github.io/posts/2019-03-25-comonadic-builders
%- comonads https://fmapfixreturn.wordpress.com/2008/07/09/comonads-in-everyday-life/
%
%% STEP 2: co-monads are objects,
%- comonads are objects very important and closely related http://www.haskellforall.com/2013/02/you-could-have-invented-comonads.html
%
%% STEP 3: agents are objects?
%- if conal elliott can make a comonadic formulatin of FRP and comonads are objects, then i guess i am very close to a pure functional representation of objects? pure functional objects?

What is striking is that those concepts have been used to model the object-oriented programming paradigm. Consequently, it seems that we have come around full circle and found a potential link between our pure functional and the established object-oriented approach to ABS. This implies that there might be some programming paradigm agnostic, unified theory of agents as used in ABS lurking somewhere behind these concepts. We believe that such a theory would help ABS to put itself on solid formal grounds, connecting it to other areas of computation and other sciences. Ultimately, it would be a powerful tool to more rigorously investigate certain aspects of models and be of help in specification, validation and verification.