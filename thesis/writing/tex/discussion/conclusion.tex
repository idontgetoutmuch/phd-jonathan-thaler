\chapter{Conclusion}
\label{ch:conclusion}
This thesis has shown at length \textit{how} pure functional ABS is possible in a robust maintainable way and \textit{why} it is of benefit and when a pure functional approach should be \textit{avoided}.

Chapter TODO time- and event-driven are strong evidence that our claim that pure FP has indeed its place in ABS is valid - especially a full implementation in Sugarscape is a highly complex and non-trivial matter and our highly structured and robust approach can be seen as proof of success. At the same time we conclude that it is yet too early to pick up this paradigm for ABS. We think that engineering a proper implementation of a complex ABS model takes substantial effort in pure FP due to different techniques required and due to its strong static type system (TODO: cite productivity). We believe that at the moment such an effort pays off only in cases of high-impact and large-scale simulations which results might have far-reaching consequences e.g. influence policy decisions. It is only there where the high requirements for reproducibility, robustness and correctness provided by FP are really needed. Still, we plan on distilling the developed techniques of the case-study into a general purpose ABS library. This should allow implementing models much easier and quicker, making the pure FP approach an attractive alternative for prototyping, opening the direction for a broad use of FP in the field of ABS.

This thesis established now the knowledge of how to engineer time- and event-driven ABS with complex state both in the agent and environment, main difficulty is direct agent-interaction (see macal classification into 4 types of ABS), compile-time guaranteed reproducibility, explicit handling of complex state (read only, read/write), concurrency explicit and limited to STM, very promising concurrency but direct agent-interactions main problem (erlang as a rescue?), main drawbacks: everything is explicit, performance.

Further, it deepened the understanding of the structure of agent based computation by expressing it in a pure functional context, leading to a deeper and more general understanding of agents, how they can be represented and whether they indeed map naturally to objects or not. This central question of whether they map naturally to objects or not, permeates the whole thesis and drives it forward. The last chapter gave an in-depth discussion of that question and we see that objects indeed have their place in ABS but, as we have carefully explained, the question is what objects constitute. By approaching the problem from a (pure) functional perspective, we also arrived at a deeper and broader understanding of objects, not only restricted to the traditional OO definition of Java,C++ or Python. So we can say: \textit{"Yes they map naturally to objects, but we have to be precise what constitutes objects."}. Whether they are newtypes, tuples, (G)ADTs, pure functions, monads, comonads, arrows, SFs, MSFs, Actors or OO objects. They are all valid ways of representing agents with varying degree of abstraction, flexibility and power and they all come with their benefit and drawbacks which have to be clearly understood together with the problem to solve. This thesis simply added a promising new tool to the family of existing ones and only time will tell whether this tool is indeed as valuable as hinted in this thesis.

In this section we briefly summarise the future research to undertake, other than the one already mentioned in various parts of this thesis, especially in the respective discussion sections.

\section{Shallow encoding}
Using arrowized FRP with pure Signal Functions as in Yampa and Monadic Stream Functions as in Dunai is only \textit{one} approach to ABS \footnote{After all, my education and thinking was influenced by object oriented thinking for 15 years, so this could be also the case that I intuitionally arrive at such a solution again.}. As we have shown at length in this thesis, although it is a robust and maintainable approach with highly valuable and promising benefits, there are other potential approaches left unexplored.

A standard approach to encode a problem in Haskell is by designing an embedded domain specific language (EDSL) for that (domain) problem and then implement the problem at hand in this specifically designed language. One has to distinguish between a \textit{deep} and \textit{shallow} encoding: in the former one, the EDSL is expressed "deeply" using direct data-types and functions of the host language Haskell - our approach using SFs and MSFs is of this nature.

The shallow encoding approach on the other hand provides a language on top of the Host language, often expressed using ADTs (Algebraic Data Types) or GADT (Generalised ADTs) which are used to encode a problem as a data-structure - the execution of the problem is done by an interpreter which evaluates this data-structure and translates it to the semantics of the host language. An example of a shallow embedded EDSL is a language for mathematical expressions consisting of constants, multiplication and subtractions, which are represented as syntax trees and then translated into Haskell multiplication and subtraction to arrive at the final result.

The main benefit of a shallow encoding is that it allows to separate definition from implementation due to the separation of the EDSL and its interpretation. This allows to strictly separate implementation from specification, composes very well and thus should also be easy to test as mocking of parts is straightforward.

\medskip

So called \textit{Freer Monads} \cite{rivas_notions_2014} allow to express such shallow EDSL. One big additional advantage of them is that they free one from the ordering of effects imposed through Monad Transformers as mentioned in (TODO introduction to monad transformers in background). Unfortunately, Freer Monads seem to be somewhere around 30 times slower than the equivalent MTL code with a complexity of $O(n^2)$ \footnote{\url{https://reasonablypolymorphic.com/blog/freer-monads/}}. For IO bound problems like business applications, this is not a big deal but as already mentioned in the introduction, ABS are almost always not IO bound, so raw computation is all what counts and this is undoubtedly worse with Freer monads. Even although there seem to be a better encoding possible, which is about 2x slower than MTL \footnote{\url{https://reasonablypolymorphic.com/blog/too-fast-too-free/}} the fact that we are already performance limited in our deep encoding makes the Free Monads approach not very appealing \footnote{\url{https://reasonablypolymorphic.com/blog/freer-yet-too-costly/}}. Also the fact that \textit{ContT} is not an Algebraic Effect, it seems to be difficult to implement continuations in Freer Monads which are but the fundamental building blocks in our deep encoding. Still, we expect that it will be highly interesting and valuable research with focus on deeper and stronger guarantees about correctness and testing than our deep encoding.

%Other criticism of Freer Monads are: \url{https://medium.com/barely-functional/freer-doesnt-come-for-free-c9fade793501} are: boilerplate code which though can be generated automatically by some libraries, performance when not IO based because the program is bascially a data-structure which is interpreted, concurrency seems to be tricky, 

%\subsection{Languages}
%We precisely pointed out in the beginning of this thesis why we chose Haskell as language of choice. Obviously Haskell is not the only (pure) functional language and there exist a number of other alternatives which would be equally worth of systematic investigation of their use for ABS. Shortly we can conclude that the use of Haskell moves the nature of the structure of ABS computation into the light, together with compile-time guarantees, and benefits in testing and parallel implementations. Depending on each language though we get a very different direction:

%\paragraph{LISP} Being the oldest functional programming language and the 2nd oldest high-level programming language ever created and still used by many people, LISP had to be considered in the beginning of the thesis. The language has the immense powerful feature of homoiconicity: data is code and code is data at the same time. This allows a LISP program to generate data-structures, which resemble valid LSIP code thus mutating its own code at runtime. This would give immense power to create powerful abstractions in terms of ABS. Unfortunately LISP is fully interpreted and has no types and is also impure, which would probably have led to very imperative, traditional approaches to ABS. Still, there exists research \cite{kawabe_nepi2programming_2000} which implements a MAS in LISP.
	
%\paragraph{Scala} Scala is a multi-paradigm language, which also comes with an implementation of the actor-model as a library which enables to do actor-programming in the way of Erlang. It was developed in 2004 and became popular in recent years due to the increased availability of multi-core CPUs which emphasised the distributed, parallel and concurrent programming for which the actor-model is highly suited. There exists research on using Scala for ABS \cite{krzywicki_massively_2015, todd_multi-agent_nodate}. The benefit Scala has over Erlang is that it has type-checking at compile-time and is thus more robust, still it is impure due to side-effects and messages can contain references, thus violating the original shared-nothing semantics of Erlang.

\section{A general purpose library}
For pure functional ABS to ever reach a larger audience and acceptance, it will need a lot of support, especially in the form of a well designed, easy to use, robust, correct, high quality Haskell Library. Designing and developing such a library is research on its own as it needs to combine all the separate concepts introduced in this thesis into one code base. We hope that from this development further insights into ABS in general and pure functional ABS in particular will emerge, which can then be published to the community.

%generalise concepts explored into a pure functional ABS library in Haskell (called chimera)
%stm based concurrency for event-driven ABS using parallel DES. challenge is the time-warp implementation using monads. in general it should be easy to roll-back agents actions but with monads we have to be careful - for some monads rolling back is not neccessary e.g. rand and reader, for others it is, and for some it is impossible e.g. IO

\section{Actor based ABS}
One of the thesis fundamental conclusions is that the future of ABS lies in a functional, actor based concurrent approach. It required the full thesis to come to this conclusion thus this thesis only scratched the surface of the potential for actor based ABS as in Erlang or Cloud Haskell. We think that this topic deserves rigorous research as well as it is currently strongly neglected with only very few papers existing, which just scratch the surface. The idea seems compelling: functional programming with an actor language seems the way to do ABS in the future as it gives us almost all properties introduced in this thesis with the exception that agent interactions are a lot easier and naturally expressed.

There have been a few attempts on implementing the actor model in real programming languages where the most notable ones are Erlang and Scala. Erlang was created in 1986 by Joe Armstrong for Eriksson for developing distributed high reliability software in telecommunications. It implements light-weight processes, which allows to spawn thousands of them without heavy memory overhead. The language saw some use in implementing ABS with notable papers being \cite{di_stefano_using_2005, di_stefano_exat:_2007, varela_modelling_2004, sher_agent-based_2013, bezirgiannis_improving_2013}

Scala is a modern mixed paradigm programming language, which also allows functional programming and also incorporates a library for the actor model. It also saw the use in the implementation of ABS with a notable paper \cite{krzywicki_massively_2015} and ScalABM \footnote{https://github.com/ScalABM} which is alibrary for ABM in economics.

The paper of \cite{jennings_agent-based_2000} gives an excellent overview over the strengths and weaknesses of agent-based software-engineering, which can be directly applied to both Erlang and Scala.

Due to the very different approach and implications the actor model of concurrency implies, we don't explore it further and leave it for further research as it is beyond the focus of the thesis.

\section{Dependent and linear types}
We see this thesis as an intermediary and necessary step towards dependent types for which we first needed to understand the potential and limitations of a non-dependently typed pure functional approach in Haskell. Dependent types are extremely promising in functional programming as they allow us to express stronger guarantees about the correctness of programs and go as far as allowing to formulate programs and types as constructive proofs, which must be total by definition \cite{thompson_type_1991, altenkirch_why_2005, altenkirch_pi_2010}.

So far no research using dependent types in agent-based simulation exists at all. In our next paper we want to explore this for the first time and ask more specifically how we can add dependent types to our pure functional approach, which conceptual implications this has for ABS and what we gain from doing so. We plan on using Idris \cite{brady_idris_2013} as the language of choice as it is very close to Haskell with focus on real-world application and running programs as opposed to other languages with dependent types e.g. Agda and Coq.

We hypothesize that dependent types could help ruling out even more classes of bugs at compile time and encode invariants and model specifications on the type level, which implies that we don't need to test them using e.g. property-testing with QuickCheck. This would allow the ABS community to reason about a model directly in code. We think that a promising approach is to follow the work of \cite{brady_programming_2013, fowler_dependent_2014, brady_state_2016} in which the authors utilize GADTs to implement an indexed monad, which allows to implementation correct-by-construction software.

We have already started to outline a few core principles in the Appendix \ref{app:equilibrium_totality}, but we conjecture that the true benefit is yet to be revealed.