\chapter{Conclusion}
\label{ch:conclusion}
This thesis has shown at length \textit{how} pure functional ABS is possible in a robust maintainable way and \textit{why} it is of benefit and when a pure functional approach should be \textit{avoided}.

The chapters on time- \ref{ch:timedriven} and event-driven \ref{ch:eventdriven} ABS are strong evidence that our claim that pure functional programming has indeed its place in ABS is valid - especially a full implementation in Sugarscape is a highly complex and non-trivial matter and our highly structured and robust approach can be seen as proof of success. At the same time we conclude that it is yet too early to pick up this paradigm for ABS. We think that engineering a proper implementation of a complex ABS model takes substantial effort in pure functional programming due to different techniques required and due to its strong static type system. We believe that at the moment such an effort pays off only in cases of high-impact and large-scale simulations which results might have far-reaching consequences e.g. influence policy decisions. It is only there where the high requirements for reproducibility, robustness and correctness provided by functional programming are really needed. Still, we plan on distilling the developed techniques into a general purpose ABS library. This should allow implementing models much easier and quicker, making the pure functional programming approach an attractive alternative for prototyping, opening the direction for a broad use of functional programming in the field of ABS.

Further, this thesis deepened the understanding of the structure of agent based computation by expressing it in a pure functional context, leading to a deeper and more general understanding of agents, how they can be represented and whether they indeed map naturally to objects or not. This central question of whether they map naturally to objects or not, permeates the whole thesis and drives it forward. The last chapter gave an in-depth discussion of that question and we see that objects indeed have their place in ABS but, as we have carefully explained, the question is what objects constitute. By approaching the problem from a (pure) functional perspective, we also arrived at a deeper and broader understanding of objects, not only restricted to the traditional object-oriented definition of Java, C++ or Python. So we can say: \textit{"Yes, agents map naturally to objects, but we have to be precise what constitutes objects."}. Whether they are newtypes, tuples, (G)ADTs, pure functions, monads, comonads, arrows, SFs, MSFs, Actors or object-oriented objects. They are all valid ways of representing agents with varying degree of abstraction, flexibility and power and they all come with their benefit and drawbacks, which have to be clearly understood together with the problem to solve. This thesis simply added a promising new tool to the family of existing ones and only time will tell whether this tool is indeed as valuable as hinted in this thesis.

In the remaining sections we briefly summarise the future research to undertake.

\section{Shallow encoding}
Using arrowized FRP with pure Signal Functions as in Yampa and Monadic Stream Functions as in Dunai is only \textit{one} approach to ABS. As we have shown at length in this thesis, although it is a robust and maintainable approach with highly valuable and promising benefits, there are other potential approaches left unexplored.

A standard approach to encode a problem in Haskell is by designing an embedded domain specific language (EDSL) for that (domain) problem and then implement the problem at hand in this specifically designed language. One has to distinguish between a \textit{deep} and \textit{shallow} encoding: in the former one, the EDSL is expressed "deeply" using direct data-types and functions of the host language Haskell - our approach using SFs and MSFs is of this nature.

The shallow encoding approach on the other hand provides a language on top of the Host language, often expressed using ADTs (Algebraic Data Types) or GADT (Generalised ADTs) which are used to encode a problem as a data-structure - the execution of the problem is done by an interpreter which evaluates this data-structure and translates it to the semantics of the host language. An example of a shallow embedded EDSL is a language for mathematical expressions consisting of constants, multiplication and subtractions, which are represented as syntax trees and then translated into Haskell multiplication and subtraction to arrive at the final result.

The main benefit of a shallow encoding is that it allows to separate definition from implementation due to the separation of the EDSL and its interpretation. This allows to strictly separate implementation from specification, composes very well and thus should also be easy to test as mocking of parts is straightforward.

\medskip

A popular and powerful approach to implement shallow EDSLs are so called \textit{Freer Monads} \cite{rivas_notions_2014}. One big advantage of them is that they free one from the ordering of effects imposed through Monad Transformers as already mentioned in Chapter \ref{sec:background_fp}. Unfortunately, Freer Monads seem to be somewhere around 30 times slower than the equivalent MTL code with a complexity of $O(n^2)$ \footnote{\url{https://reasonablypolymorphic.com/blog/freer-monads/}}. For IO bound problems like business applications, this is not a big deal but as already mentioned, ABS are almost always not IO bound, so raw computation is all what counts and this is undoubtedly worse with Freer Monads. Even although there seem to be a better encoding possible, which is about 2x slower than MTL \footnote{\url{https://reasonablypolymorphic.com/blog/too-fast-too-free/}} the fact that we are already performance limited in our deep encoding makes the Free Monads approach not very appealing \footnote{\url{https://reasonablypolymorphic.com/blog/freer-yet-too-costly/}}. Still, we expect that it will be highly interesting and valuable research with focus on deeper and stronger guarantees about correctness and testing than our deep encoding.

%Other criticism of Freer Monads are: \url{https://medium.com/barely-functional/freer-doesnt-come-for-free-c9fade793501} are: boilerplate code which though can be generated automatically by some libraries, performance when not IO based because the program is bascially a data-structure which is interpreted, concurrency seems to be tricky, 

\section{A general purpose library}
For pure functional ABS to ever reach a larger audience and acceptance, it will need a lot of support, especially in the form of a well designed, easy to use, robust, correct, high quality Haskell library. Designing and developing such a library is research on its own as it needs to combine all the separate concepts introduced in this thesis into one code base. We hope that from this development further insights into ABS in general and pure functional ABS in particular will emerge, which can then be published to the community.

%generalise concepts explored into a pure functional ABS library in Haskell (called chimera)
%stm based concurrency for event-driven ABS using parallel DES. challenge is the time-warp implementation using monads. in general it should be easy to roll-back agents actions but with monads we have to be careful - for some monads rolling back is not neccessary e.g. rand and reader, for others it is, and for some it is impossible e.g. IO

\section{Actor based ABS}
We conclude that the future of concurrent, interaction-centric ABS lies in a functional, actor based concurrent approach. It required the full thesis to come to this conclusion thus this thesis only scratched the surface of the potential for actor based ABS as in Erlang or Cloud Haskell. We think that this topic deserves rigorous research as well as it is currently strongly neglected with only very few papers existing, which just scratch the surface. The idea seems compelling: functional programming with an actor language seems the way to do ABS in the future as it gives us almost all properties introduced in this thesis with the exception that agent interactions are a lot easier and naturally expressed.

There have been a few attempts on implementing the actor model in real programming languages where the most notable ones are Erlang and Scala. Erlang was created in 1986 by Joe Armstrong for Eriksson for developing distributed high reliability software in telecommunications. It implements light-weight processes, which allows to spawn thousands of them without heavy memory overhead. The language saw some use in implementing ABS with notable papers being \cite{bezirgiannis_improving_2013,di_stefano_using_2005, di_stefano_exat:_2007, varela_modelling_2004, sher_agent-based_2013}

%Scala is a modern mixed paradigm programming language, which also allows functional programming and also incorporates a library for the actor model. It also saw the use in the implementation of ABS with a notable paper \cite{krzywicki_massively_2015} and ScalABM \footnote{https://github.com/ScalABM} which is alibrary for ABM in economics.

The paper of \cite{jennings_agent-based_2000} gives an excellent overview over the strengths and weaknesses of agent-based software-engineering, which can be directly applied to both Erlang and Scala.

Further, process calculi like CSP, CCS and Pi-Calculus become applicable in the context of an Actor Model, which should allow to actually \textit{prove} the correctness of a specification. Due to the direct mapping of the process calculi languages to Erlang we see this as highly promising, also in light of the weak performance.

Due to the very different approach and implications the actor model of concurrency implies, we don't explore it further and leave it for further research as it is beyond the focus of the thesis.

\section{Dependent and linear types}
We see this thesis as an intermediary and necessary step towards dependent types for which we first needed to understand the potential and limitations of a non-dependently typed pure functional approach in Haskell. Dependent types are extremely promising in functional programming as they allow us to express stronger guarantees about the correctness of programs and go as far as allowing to formulate programs and types as constructive proofs, which must be total by definition \cite{altenkirch_pi_2010, altenkirch_why_2005, thompson_type_1991}.

So far no research using dependent types in agent-based simulation exists at all. In our future research we want to explore this for the first time and ask more specifically how we can add dependent types to our pure functional approach, which conceptual implications this has for ABS and what we gain from doing so. We plan on using Idris \cite{brady_idris_2013} as the language of choice as it is very close to Haskell with focus on real-world application and running programs as opposed to other languages with dependent types e.g. Agda and Coq.

We hypothesize that dependent types could help ruling out even more classes of bugs at compile time and encode invariants and model specifications on the type level, which implies that we don't need to test them using e.g. property-testing with QuickCheck. This would allow the ABS community to reason about a model directly in code. We think that a promising approach is to follow the work of \cite{brady_programming_2013, brady_state_2016, fowler_dependent_2014} in which the authors utilize GADTs to implement an indexed monad, which allows to implementation correct-by-construction software.

We have already started to outline a few core principles in the Appendix \ref{app:equilibrium_totality}, but we conjecture that the true benefit is yet to be revealed.