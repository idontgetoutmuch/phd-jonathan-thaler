\chapter{Evaluation}
\label{ch:evaluation}
% starting point
This thesis started out by challenging the established views that \textit{"[..] object-oriented programming to be a particularly natural development environment for Sugarscape specifically and artificial societies generally [..]"} \cite{epstein_growing_1996} (p. 179) and that \textit{agents map naturally to objects} \cite{north_managing_2007}. As a highly challenging alternative it proposed a radical different approach to implementing ABS, using the pure functional programming paradigm. As language of choice Haskell was motivated due to its matureness, increasing relevance to real-world applications and cutting edge pure functional programming concepts. 

% motivation
The motivation are the promises pure functional programming in Haskell comes with, which are relevant to ABS as well:
\begin{itemize}
	\item The static strong type system allows to remove substantial number and class of bugs at run-time and if one programs careful one can even guarantee that no bugs as in crashes or exceptions will occur at run-time. This is especially true for purely computational problems (without IO) as ABS almost always are.
	
	\item Explicit handling and control of side-effects delivers even more static guarantees at compile time and allows to deal with deterministic side-effects (random-number streams, read-/write only contexts, state) in a referential transparent way. In combination with strong static type this allows to reduce logical bugs (subject to the domain of the problem) by dramatically reducing available and valid operations on data - after all stateful applications are a fact, the challenge is how to deal with state. As ABS is full of state due to agents and the environment, this seems to be an obvious great thing to have to increase correctness of an implementation. Further, this should allow to produce an implementation which is guaranteed to reproducible (runs with same initial conditions \textit{will} result in same dynamics) at compile time.
	
	\item Parallel and concurrent programming is seen to be lot easier, less painful and less error prone in functional programming in general and in Haskell in particular due to immutable data and the explicit side-effects. The concept of Software Transactional Memory, which offers to formulate a problem as a data-flow problem like there was no concurrency seemed highly promising. Besides, data-parallel programming promises to speed up code without the need for changing any of the logic or types. This seemed to offer a straightforward way of speeding up ABS implementations either through data-parallelism or concurrency. This has always been quite difficult to achieve in traditional ABS due to OO and pure functional programming seems to offer a solution.
	
	\item The data-centric declarative style, referential transparency and immutability of data makes testing substantially easier due to composability: functions can be easily tested in isolation from each other even if they involve side-effects. This opens the door for (randomised) property-based testing which intuitively seemed to be a perfect match to test ABS implementations which are (almost) always stochastic in nature.
\end{itemize}

The relevance of each of these promises to ABS is pointed out in the respective promise and it is quite obvious that these benefits would clearly be of immense value in ABS, with the common baseline that they all support implementations of ABS to be more likely to be correct - something of fundamental value in simulation. The question was then how much of them can we actually reap if we follow a pure functional approach to ABS? To answer this we first needed to actually find out \textit{how} ABS could be done pure functionally, as there didn't exist any research which offered a systematic solution to that problem.

\input{./tex/discussion/towards.tex}

% benefit 1: static guarantees
\input{./tex/discussion/staticGuarantees.tex}

% benefit 2: parallel ABS
\section{Parallel ABS}
TODO

% benefit 3: property-based testing
\section{Property-Based Testing}
TODO

% put before gintis case
\input{./tex/discussion/generalising.tex}