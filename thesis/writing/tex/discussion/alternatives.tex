\section{Alternatives}
\label{sec:alternatives}

Shortly discuss alternative implementation directions which we didn't / couldn't follow because of not enough time / not enough experience / developed experience too late. 

\subsection{Haskell}
Freer Monads: \url{https://reasonablypolymorphic.com/blog/freer-monads/}. They aim to separate Definition from implementation by writing a domain-specific language using GADTs which are then interpreted. This allows to strictly separate implementation from specification, composes very well and thus is easier to test as parts can be easily mocked. Also Freer Monads free one from the order of effects imposed through Monad Transformers. In general Freer Monads seem to aim for the same abstraction what modern interface-based oop does.
Problem: Yes, freer monads are today somewhere around 30x slower than the equivalent mtl code. because its $O(n^2)$. ABS are not IO bound, so raw computation is all what counts and this is undoubtly worse with Freer monads. Given that we are already having problematic performance, we can't sacrifice even more. There seem to be a better encoding possible, which is about 2x slower than MTL: \url{https://reasonablypolymorphic.com/blog/too-fast-too-free/}. Still it might prove to be useful in other terms like proving correctness and then translating it, but how could we do it?  
ContT is Not an Algebraic Effect so it seems to be difficult to implement continuations in freer monads. Unfortunately this is what we really need as shown in Event driven ABS and generalising structure chapters.
Other criticism of Freer Monads are: \url{https://medium.com/barely-functional/freer-doesnt-come-for-free-c9fade793501} are: boilerplate code which though can be generated automatically by some libraries, performance when not IO based because the program is bascially a data-structure which is interpreted, concurrency seems to be tricky, 
TODO read: \url{https://reasonablypolymorphic.com/blog/freer-yet-too-costly/}


TODO: it seems that Final Tagless is another alternative. Look into it: \url{https://jproyo.github.io/posts/2019-03-17-tagless-final-haskell.html}

\subsection{Languages}
We precisely pointed out in the beginning of this thesis why we chose Haskell as language of choice. Obviously Haskell is not the only (pure) functional language and there exist a number of other alternatives which would be equally worth of systematic investigation of their use for ABS. Shortly we can conclude that the use of Haskell moves the nature of the structure of ABS computation into the light, together with compile-time guarantees, and benefits in testing and parallel implementations. Depending on each language though we get a very different direction:

\paragraph{LISP} Being the oldest functional programming language and the 2nd oldest high-level programming language ever created and still used by many people, LISP had to be considered in the beginning of the thesis. The language has the immense powerful feature of homoiconicity: data is code and code is data at the same time. This allows a LISP program to generate data-structures, which resemble valid LSIP code thus mutating its own code at runtime. This would give immense power to create powerful abstractions in terms of ABS. Unfortunately LISP is fully interpreted and has no types and is also impure, which would probably have led to very imperative, traditional approaches to ABS. Still, there exists research \cite{kawabe_nepi2programming_2000} which implements a MAS in LISP.
	
\paragraph{Erlang} The programming-model of actors \cite{agha_actors:_1986} was the inspiration for the Erlang programming language \cite{armstrong_erlang_2010}, which was created in the 1980's by Joe Armstrong for Eriksson for developing distributed high reliability software in telecommunications. The implication is that, the focus would shift immediately to the use of the actor model for concurrent interaction of agents through messages. The languages type-system is strong and dynamic and thus lacks type-checking at compile-time. Thus the structure of computation plays naturally no role because we cannot look at it from the abstract perspective as we can in Haskell. Purity can not be guaranteed and due to agents being processes concurrency is everywhere, and even though it is very tamed through shared-nothing messaging semantics, this implies that repeated runs with same initial conditions might lead to different results. Obviously we could avoid implementing agents as processes but then we basically sacrifice the very heart and feature of the language.
	
\paragraph{Scala} Scala is a multi-paradigm language, which also comes with an implementation of the actor-model as a library which enables to do actor-programming in the way of Erlang. It was developed in 2004 and became popular in recent years due to the increased availability of multi-core CPUs which emphasised the distributed, parallel and concurrent programming for which the actor-model is highly suited. There exists research on using Scala for ABS \cite{krzywicki_massively_2015, todd_multi-agent_nodate}. The benefit Scala has over Erlang is that it has type-checking at compile-time and is thus more robust, still it is impure due to side-effects and messages can contain references, thus violating the original shared-nothing semantics of Erlang.

\paragraph{F\#} Widely used in finance TODO 