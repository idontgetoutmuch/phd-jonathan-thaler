\section{Benefits}
After having established \textit{how} to do pure functional ABS in a robust and maintainable way the question was: does our approach leverage and deliver the promises of functional programming as well: what are its benefits? We have discussed them in the respective chapters already at length and will thus only recap them here in a broader context.

\subsection{Static guarantees}
Probably the biggest strength is that we can guarantee reproducibility at compile time: given identical initial conditions, repeated runs of the simulation will lead to same outputs. This is of fundamental importance in simulation and addressed in the Sugarscape model: \textit{"... when the sequence of random numbers is specified ex ante the model is deterministic. Stated yet another way, model output is invariant from run to run when all aspects of the model are kept constant including the stream of random numbers."} (page 28, footnote 16) - we can guarantee that in our pure functional approach already \textit{at compile time}.

Further, we can enforce update semantics to a certain degree by dramatically restricting the operations on state and the available state to agents. For example, in the time-driven approach the fact that the environment is provided as read-only and agents cannot interfere with other agents due to purity and complete lack of side-effects, factually enforces the parallel update strategy: there is simply no way for agents to misbheave and violate semantics of updates by mutating state they are not allowed to.

Another fundamental strength is the power of polymorphism in Haskell, which goes far beyond the polymorphism \footnote{Yes, polymorphism is not unique to OO} of existing object oriented languages. We see a particular instance of that in the polymorphism we developed in the concepts behind Sugarscape: we can compose effects depending on the model and we can easily swap out environment and events with very few changes with the benefit that the compiler will inform us about breaking changes. This is directly related to refactoring, which is very convenient and quickly becomes the norm in the development process: guided by types (change / refine them) and relying on the compiler to point out problems, results in very effective and quick changes without danger of bugs showing up at run-time. This is not possible in dynamicall OO languages like Python because of its lack of compiler and types, and much less effective in Java due to its dynamic type-system which is only remedied through strong IDE support.

Note that this thesis directly capitalises on the fact that most ABS models are primarily of computational nature, thus CPU bound and do not involve IO \textit{inside the agents} while running the simulation. The concurrent approach with STM is an exception but at least we retain the guarantees that the non-determinism within the agent behaviour originates from the concurrency using STM and nothing else. Even if some IO is required, like rendering the simulation as we did in Sugarscape, due to the lose coupling and compositional qualities of pure functional programming it is straightforward to separate these concerns and keep the impure rendering parts from the pure agent behaviour. If there arises the use-case where agents absolutely need to perform some impure IO within their behaviour then there exist two options. The first one is to let agents construct IO actions and pass them to the simulation kernel for execution, requiring the simulation kernel to run now in IO instead of being pure. This is especially suitable for one-way IO actions, where an agent does not need to synchronously wait for a result. If a synchronous IO action is required with the agent waiting for a result, it could be communicated back from the simulation kernel. This keeps the agent behaviour still pure but with the consequence of indirection and higher complexity. The other option is to simply run agents within the IO Monad - then everything is possible and all bets are off regarding static guarantees and reproducibility.

%Summarising the benefits of static guarantees, we can directly relate them to the Verification \& Validation requirements of ABS as outlined by \cite{robinson_simulation:_2014}.
%
%\begin{itemize}
%	\item Modelling progress of time and variability - This is achieved by using Functional Reactive Programming (FRP), which allows the implementation of continuous and discrete time systems.
%
%	\item Fixing random number streams to allow simulations to be repeated under same conditions; Deterministic time-delta; Repeated runs lead to same dynamics;  Ruling out external sources of non-determinism / randomness - ensured by \textit{pure} functional programming and Random Monads.
%	
%	\item Relying only on past - This is guaranteed by \textit{Arrowized} FRP, which addressed exactly that problem of making it impossible for the programmer to define acausal systems, guaranteed at compile time.
%	
%	\item Bugs due to implicitly mutable state - This is reduced using pure functional programming.
%\end{itemize}

%%%%%%%%%%%
% PARALLELISM 
\subsection{Parallelism and Concurrency}
Adding data-parallelism is easy and often requires simply swapping out a data-structure or library function against its parallel version. Concurrency, although still hard, is less painful to address and add in a pure functional setting due to immutable data and explicit side-effects. Further, the benefits of implementing concurrent ABS based on Software Transactional Memory (STM) has been shown at length in the respective part which underlines the strength of Haskell for concurrent ABS due to its strong guarantees about retry-semantics. 

%%%%%%%%%%%%%
% TESTING
\subsection{Property-Based Testing}
Testing in general allows much more control and checking of invariants due to the explicit handling of effects - together with the strong static type system, the testing-code is in full, explicit control over the functionality it tests. Property-based testing in particular is a perfect match to testing ABS due to the random nature in both and because it supports convenient expressing of specifications. Thus we can conclude that in a pure functional setting, testing is very expressive and powerful and supports working towards an implementation which is very likely to be correct. For further insight into testing Functional Reactive Programs we can directly leverage on the work of \cite{perez_testing_2017}. A classic use-case which is a unique benefit of pure functional programming, namely \textit{equational reasoning} was not investigated in this thesis as it was beyond the focus of this Ph.D. We expect that this technique is applicable to parts of our approach as well but leave this for further research.

%\begin{enumerate}
%	\item Run-Time robustness by compile-time guarantees - by expressing stronger guarantees already at compile-time we can restrict the classes of bugs which occur at run-time by a substantial amount due to Haskell's strong and static type system.  This implies the lack of dynamic types and dynamic casts \footnote{Note that there exist casts between different numerical types but they are all safe and can never lead to errors at run-time.} which removes a substantial source of bugs.  Note that we can still have run-time bugs in Haskell when our functions are partial.
%	
%	\item Purity - By being explicit and polymorphic in the types about side-effects and the ability to handle side-effects explicitly in a controlled way allows to rule out non-deterministic side-effects which guarantees reproducibility due to guaranteed same initial conditions and deterministic computation. Also by being explicit about side-effects e.g. Random-Numbers and State makes it easier to verify and test.
%	
%	\item Explicit Data-Flow and Immutable Data - All data must be explicitly passed to functions thus we can rule out implicit data-dependencies because we are excluding IO. This makes reasoning of data-dependencies and data-flow much easier as compared to traditional object-oriented approaches which utilize pointers or references.
%	
%	\item Declarative - describing \textit{what} a system is, instead of \textit{how} (imperative) it works. In this way it should be easier to reason about a system and its (expected) behaviour because it is more natural to reason about the behaviour of a system instead of thinking of abstract operational details.
%	
%	\item Concurrency and parallelism - due to its pure and 'stateless' nature, functional programming is extremely well suited for massively large-scale applications as it allows adding parallelism without any side-effects and provides very powerful and convenient facilities for concurrent programming. The paper of (TODO: cite my own paper on STM) explores the use Haskell for concurrent and parallel ABS in a deeper way.
%\end{enumerate}