\section{Benefits}
TODO: not happy with that, it doesnt feel right, too short and detached, maybe can integrate it into the previous part.

We have discussed the benefits of pure functional ABS in the respective chapters already at length and recap them here in a broader context.

%After having established \textit{how} to do pure functional ABS in a robust and maintainable way the question was: does our approach leverage and deliver the promises of functional programming as well: what are its benefits? 

\subsection{Static guarantees}
Probably the biggest strength is that we can guarantee reproducibility at compile time: given identical initial conditions, repeated runs of the simulation will lead to same outputs. This is of fundamental importance in simulation and addressed in the Sugarscape model: \textit{"... when the sequence of random numbers is specified ex ante the model is deterministic. Stated yet another way, model output is invariant from run to run when all aspects of the model are kept constant including the stream of random numbers."} (page 28, footnote 16) - the pure functional approach can guarantee that \textit{at compile time}.

Further, we can enforce update semantics to a certain degree by dramatically restricting the state agents can manipulate. For example, in the time-driven approach the fact that the environment is provided as read-only and agents cannot interfere with other agents due to purity and complete lack of side effects, factually enforces the parallel update strategy: there is simply no way for agents to misbehave and violate semantics of updates by mutating state they are not allowed to.

%Summarising the benefits of static guarantees, we can directly relate them to the Verification \& Validation requirements of ABS as outlined by \cite{robinson_simulation:_2014}.
%
%\begin{itemize}
%	\item Modelling progress of time and variability - This is achieved by using Functional Reactive Programming (FRP), which allows the implementation of continuous and discrete time systems.
%
%	\item Fixing random number streams to allow simulations to be repeated under same conditions; Deterministic time-delta; Repeated runs lead to same dynamics;  Ruling out external sources of non-determinism / randomness - ensured by \textit{pure} functional programming and Random Monads.
%	
%	\item Relying only on past - This is guaranteed by \textit{Arrowized} FRP, which addressed exactly that problem of making it impossible for the programmer to define acausal systems, guaranteed at compile time.
%	
%	\item Bugs due to implicitly mutable state - This is reduced using pure functional programming.
%\end{itemize}

%%%%%%%%%%%
% PARALLELISM 
\subsection{Parallelism and concurrency}
Adding data parallelism is easy and often requires simply swapping out a data structure or library function against its parallel version. Concurrency, although still hard, is less painful to address and add in a pure functional setting due to immutable data and explicit side effects. Further, the benefits of implementing concurrent ABS based on STM has been shown at length in the respective chapter which underlines the strength of Haskell for concurrent ABS due to its strong guarantees about retry semantics. 

%%%%%%%%%%%%%
% TESTING
\subsection{Property-based testing}
Functional programming in general gives much more control and checking of invariants due to the explicit handling of effects. Together with the strong static type system, testing code is in full, explicit control over the functionality it checks. Property-based testing in particular is a perfect match for testing ABS due to the stochastic nature of both and because it supports convenient expressing of specifications. %Thus we can conclude that in a pure functional setting, testing is very expressive and powerful and supports working towards an implementation which is very likely to be correct.
For further insight into testing FRP we can directly leverage on the work of \cite{perez_testing_2017}. Another unique benefit of pure functional programming, \textit{equational reasoning} was not investigated in this thesis as it was beyond the focus of this Ph.D. We expect that this technique is applicable to parts of our approach as well but leave this for further research.

%\begin{enumerate}
%	\item Run-Time robustness by compile-time guarantees - by expressing stronger guarantees already at compile-time we can restrict the classes of bugs which occur at run-time by a substantial amount due to Haskell's strong and static type system.  This implies the lack of dynamic types and dynamic casts \footnote{Note that there exist casts between different numerical types but they are all safe and can never lead to errors at run-time.} which removes a substantial source of bugs.  Note that we can still have run-time bugs in Haskell when our functions are partial.
%	
%	\item Purity - By being explicit and polymorphic in the types about side-effects and the ability to handle side-effects explicitly in a controlled way allows to rule out non-deterministic side-effects which guarantees reproducibility due to guaranteed same initial conditions and deterministic computation. Also by being explicit about side-effects e.g. Random-Numbers and State makes it easier to verify and test.
%	
%	\item Explicit Data-Flow and Immutable Data - All data must be explicitly passed to functions thus we can rule out implicit data-dependencies because we are excluding IO. This makes reasoning of data-dependencies and data-flow much easier as compared to traditional object-oriented approaches which utilize pointers or references.
%	
%	\item Declarative - describing \textit{what} a system is, instead of \textit{how} (imperative) it works. In this way it should be easier to reason about a system and its (expected) behaviour because it is more natural to reason about the behaviour of a system instead of thinking of abstract operational details.
%	
%	\item Concurrency and parallelism - due to its pure and 'stateless' nature, functional programming is extremely well suited for massively large-scale applications as it allows adding parallelism without any side-effects and provides very powerful and convenient facilities for concurrent programming. The paper of (TODO: cite my own paper on STM) explores the use Haskell for concurrent and parallel ABS in a deeper way.
%\end{enumerate}