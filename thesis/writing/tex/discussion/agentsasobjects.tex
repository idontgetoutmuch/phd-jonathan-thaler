\subsection{Agents As Objects}
It seems that we indeed have to agree that agents do actually map naturally to objects. Throughout the course of this thesis though it became clear that we have to think objects in a much broader context than the one of existing OO terminology as in Java, C++, Python. The reason that we have shown that we can represent agents as objects also in a purely functional way, leads us to the next question, what actually constitutes objects? We have to be careful not to confuse the \textit{concept} of objects with the \textit{implementation} of objects. Lets first be clear about the \textit{concept} of an object (Alan kay, Actors, Java/C++/Python family) and then look at \textit{implementations} (Java/C++/Python family, actors, pure functionally)


Although object-oriented programming was invented to give programmers a better way of composing their code, strangely objects ultimately do \textit{not} compose \cite{bill_what_2017}, \cite{erkki_lindpere_why_2013}. The reason for this is that objects hide both \textit{mutation} and \textit{sharing through pointers or references} of object-internal data. This makes data-flow mostly implicit due to the side-effects on the mutable data which is globally scattered across objects. To deal with the problem of composability and implicit data-flow the seminal work \cite{gamma_design_1994} put forward the use of \textit{patterns} to organize objects and their interaction. Other concepts, trying to address the problems, were the SOLID principles and Dependency Injection. Although a huge step in the right direction, these concepts come with a very heavy overhead, are often difficult to understand and to apply and don't solve the fundamental problem \cite{lawrence_krubner_object_2014}. To put it short: even for experienced programmers, proper object-oriented programming \textit{is hard}. The difficulty arises from how to split up a problem into objects and their interactions and controlling the implicit mutation of state which is spread across all objects. Still if one masters the technique of object-oriented program-design and implementation, due to the implicit global mutable state bugs due to side-effects are the daily life of a programmer as shown below. Note that this critique of object-oriented programming addresses the deficits of this paradigm as it is implemented and in use today in languages likes Java and C++. The original idea of object-orientation, invented by Alan Kay \footnote{\url{http://wiki.c2.com/?AlanKaysDefinitionOfObjectOriented}} was very different than today and has much more common with the Actor Model as will be discussed in the literature-review.


\paragraph{Object definition}
identity
internal state
message exchange

\paragraph{Object implementation}
Java/C++/Python family
Actors as in Erlang
pure functionally

% TODO: the history does say something else about objects as alan kay had them in mind.

When we go back to the beginning of this thesis and revisit the viewpoints that object-oriented programming (OO) is a particularly natural development environment for ABS \cite{epstein_growing_1996} and \textit{"agents map naturally to objects"} \cite{north_managing_2007} in the light of the full thesis, the obvious question which comes to mind is whether this thesis implies that we have been doing implementing ABS wrong ever since Epstein advocated OO for it in 1996 - shall Haskell be the new way to got? Obviously that is not the case but as we have shown, with (pure) functional programming comes a lot of potential. Lets elaborate on that.

\medskip

It is a fact that simulations are about consuming, processing and producing data. ABS being simulation methodology is no exception to that fact. Unfortunately, due to OO lack of rigour theoretical foundations, OO as it is used today is \textit{not} very good at representing and manipulating pure data and its data-flow because of two things: \textit{mutable shared state} and explicitly associate data-types and functions(methods)/code/behaviour.

%FROM https://www.youtube.com/watch?v=QM1iUe6IofM&feature=youtu.be
Inheritance is not relevant any more: it has come to a widely agreement amongst OO developers that inheritance should be avoided: https://www.javaworld.com/article/2073649/why-extends-is-evil.html . Note that we are speaking about subclassing not implementing an interface, which is something entirely different
Polymorphism: is not unique to OO and exists in non-OO languages as well and plays a central role in Haskell (and ML languages). Further it is possible to implement polymorphic code in C
Encapsulation: this is seen as the major strength of OO but unfortunately it does not work at a fine grained level of code in todays OO. The original idea was indeed great and it is no coincidence that my implementation ended up with a variation of that as well as Erlang: encapsulate state behind a public interface and interact with it through messages (TODO: fill in alan kay). The very central point of messages though was that they followed "shared nothing" semantics, meaning that no references or pointers could be contained in that message as this would immediately result in a violation of the public interface and ultimately breaks encapsulation. 
OO dominates the industry since around mid 90s. There are varying opinions on that but a major influence to popularise OO was Java, which made its first appearance in 1996. Java was a much easier approach to OO than existing ones e.g. in C++ and VB: it abandoned multiple inheritance, introduced interfaces, was cross-platform, provided high quality libraries including a GUI framework (GUI programming was the way to go in the 90s until it got abandoned in 00s with the emergence of Web 2.0), C/C++ syntax made it easy to pick up, avoided header-files, abandoned pointers and memory management and added garbage collection which made applications a lot safer.

% TODO: need to discuss the problem of shared state. state per se is not necessarily a problem and ever program has state in some form. how explicit it is represented is often used as classification between different kind of paradigms e.g. it has been said that functional programming is stateless but that is obviously not true, state is all over the place but it is very very contained, well behaved and explicit. with shared mutable state this is not the case anymore and we get into the troube of data-dependencies and orderings. this is exactly what we encountered when having introduced a global environment in Sugarscape: although our state is referential transparent and pure functional, they way we used it is globally and we run in ordering issues.

% TODO: isnt shared state also a problem in erlang? after all we can send Pids around and interact with those processes as soon as another process has access to a Pid. In which way is it different to reference passing in OO? There seems to be no difference... so maybe the anti OO argument is not that strong after all and my argument is simply weak or wrong? 

%TODO: i REALLY need to find proper literature / research / evidence which shows the problematic nature of modern OO: mutable shared state which is tied to code. Inheritance and open recursion gives the rest. the problem is that deeply linking \textit{shared mutable} state to its code is the path to failure: abstraction breaks, concurrency and parallelism becomes hard and breaks abstraction, data-driven programming becomes difficult (although that got addressed by adding functional features). NOTE: my approach and erlang have state and behaviour as well but in our case the state is shared nothing and immutable (yes in Haskell we update the agents state but that happens ultimately through closures and continuation in a referential transparent way and still no state is shared between agents. the environment is an exception to some extent as agents can access it globally: this works but requires a specific ordering either through sequential access or STM. this is no different than in an erlang implementation of sugarscape: there needs to be some arbitration of concurrent access). TODO: isnt there some fundamental research on that issue out there?
% TODO: maybe these act as a starting point?
% https://www.yegor256.com/2016/08/15/what-is-wrong-object-oriented-programming.html
% https://dl.acm.org/citation.cfm?id=1806847
% https://web.cs.ucdavis.edu/~filkov/papers/lang_github.pdf "Most notably, it does appear that strong typing is modestly better than weak typing, and among functional languages, static typing is also somewhat better than dynamic typing" "We also find that functional languages are somewhat better than procedural languages" but modest effects
% https://www.javaworld.com/article/2073649/why-extends-is-evil.html
% READ extension problem paper
% READ Ted Kaminskis thesis


%The rise of functional concepts in OO languages in the last years are a strong indication that OO is lacking features which have existed in FP for decades:
%
%\begin{itemize}
%	\item Java 8 added lambda expressions and functional style programming using map, fold, reduce, filter, which together with lambdas allow a data-flow oriented approach to computing.
%	 
%	\item Python, which surges in popularity within the OO family of languages, allows very data-flow centric and functional style of programming through lambda functions, list comprehensions and other functional features as it does not require programmers to stick to the OO paradigm.
%	
%	\item Popularisation of JavaScript frameworks like React, Elm and Purescript, which emphasise a functional, data-flow driven approach of web-programming.
%\end{itemize}

This was by no means clear in the early-to-mid 1990s where the OO paradigm was seen as a silver bullet to the problems of programming: a whole software industry had to re-learn best practices, patterns \cite{gamma_design_1994} and how to avoid pitfalls and bad code \cite{fowler_refactoring:_2012}. Thus we cannot blame \cite{epstein_growing_1996} for advertising OO as the ways to implement ABS, at that time it seemed indeed to be the right thing to do. 

The question is then why not use toolkits like Matlab or R - after all they are completely data-centric? This would be the other extreme, just like OO is and we would run into difficulties as well. The point is that ABS is not purely data-centric either and is indeed richer: agents can interact with each other and with an environment. So we have a tension here: ABS is data-centric on the one hand, and interaction-centric on the other - can we combine both worlds?

The combination of both was exactly the sales pitch of OO for the last 20+ years. Unfortunately this combination leads to nasty bugs due to shared mutable state, deeply complex object hierarchies due to inheritance overuse which also fix behaviour at compile time, open recursion which in the end costs the potential for higher degree of correctness, ease of parallelism and concurrency and the use of property-based testing. Thus we need to separate both: what we need is immutable, shared-nothing state allowing for a data-centric approach \textit{and} an interaction mechanism which allows agents to communicate with each other.

\medskip

This thesis is \textit{one} way of showing how to separate both and reap the benefits. A time-driven ABS like SIR or an ACE with simple agents not interaction with each other like ZI traders is heavily data-centric and very low on agent-interaction. Such data-driven ABS models are quite well expressed in a purely functional approach with the advantage that one can reap the benefits of reproducibility at compile time, using STM for concurrency and property-based testing for verification and validation. An event-driven simulation with complex agent state and agent-interactions like social simulations like Sugarscape or Chemical or Biology simulation with cell interactions are also possible in a pure functional setting as we have shown in the case of the Sugarscape model. Although we were able to give a good solution to complex agent state and synchronous, direct Agent-interactions in our event-driven SIR and Sugarscape and they \textit{do} work in Haskell, they are cumbersome to get right without library support (see further research below) and we cannot reap the benefits of STM in their case. 

This has lead to the fundamental conclusion that simulations which implement complex agent state and agent-communication centric models should rather be implemented in an functional language with actor based concurrency messaging. There are basically two options Cloud Haskell and Erlang \footnote{There is also Elixir, an Erlang dialect. Also there is Scala with the Akka / Actor Library but this is not purely functional and violates the shared nothing semantics, making it less data-centric}.
They are all message orientation will allow you to easily express the complex agent-interactions whilst having the potential to run them in parallel to gain a potentially substantial speed up. Despite its focus on messages, all are (pure) functional languages, which puts you into the data-centric approach: messages are pure data with \textit{shared nothing semantics}. This makes testing easier and also opens the way for property-based testing which is available in Erlang as well where it even allows to detect race conditions \cite{claessen_finding_2009}. Thus we can conclude that agents do \textit{not} map naturally to objects, agents map naturally to actors. 

% TODO: cite armstrongs blog about shared nothing semantics, should be somewhere in my 1st or 2nd year report 

\medskip

Thus it is not that implementing ABS with OO is wrong - it works reasonably well as a large number of industry strength libraries and frameworks demonstrate. It is more the \textit{missed potential} of a (pure) functional, data-centric approach: strong static type system with explicit controlled side-effects; parallel computation to speed up the simulation with very few changes but retaining static guarantees at compile time; STM to implement concurrent data-flow problems as actual data-flow problems without the need to resort to synchronisation primitives and cluttering the program logic with semantics for synchronisation and concurrency; Property-based testing for verification and validation of a data-centric approach which is central to all simulations; actor model concurrency in the case of Cloud Haskell and Erlang for agent-interaction centric models with a functional, data-centric core. 

Still, there are reasons to stick with OO and avoid FP. There exist a bunch the industry strength toolkits and libraries (Repast, NetLogo, AnyLogic) and the widespread use and knowledge of OO which makes abs implementers readily available. This allows for a quick and cheap implementation of low-impact and straightforward models where the need for correctness, reproducibility, verification and validation is not of primary concern. Also, performance in FP is still a far cry from OO although that argument might get diminished by the potential of using actor based concurrency like in Erlang to implement ABS. Another benefit is that OO as a modelling tool to a problem is still highly useful in the case of UML. %TODO:  discusses if and how peers object-oriented agent-based modelling framework can be applied to our pure functional approach. TODO: i need to re-read peers framework specifications / paper from the simulation bible book. Although peers framework uses UML and OO techniques to create an agent-based model, we realised from a short case-study with him that most of the framework can be directly applied to our pure functional approach as well, which is not a huge surprise, after all the framework is more a modelling guide than an implementation one. E.g. a class diagram identifies the main datastructures, their operations and relations, which can be expressed equally in our approach - though not that directly as in an oo language but at least the class diagram gives already a good outline and understanding of the required datafields and operations of the respective entities (e.g. agents, environment, actors,...). A state diagram expresses internal states of e.g. an agent, which we discussed how to do in both our time- and even-driven approach. A sequence diagram e.g. expresses the (synchronous) interactions between agents or with their environment, something for which we developed techniques in our event-driven approach and we discuss in depth there. 

\medskip

After having undertaken this long journey on how to implement ABS pure functionally, what the general computational structures are in ABS and what benefits and drawbacks there are, at the very end of our discussion I want to return to the claim that \textit{agents map naturally to objects} \cite{north_managing_2007}.

My approach of doing ABS and representing agents in pure FP can be interpret as trying to emulate objects in a purely functional way. In this case we have to say: yes agents map naturally to objects. The question is then: are there other, better mechanisms, more in FP I missed / didnt think of ... to implement ABS in FP? I hypothesize that this is probably NOT the case and that every approach in pure FP follows a roughly similar direction with only a few differences. Obviously it is apparent that both OOP and FP are not silverbullets to ABS and both come with their benefits and drawbacks and both have their existence. Thus I hypothesize that we might see the emergence of different computation paradigms in the future which might fit better to ABS than either one.

yes agents map naturally to objects, but what kind of objects? they differ in implementation details and in this thesis proposed a pure functional approach to a notion of objects. objects in Java work different, as well as in Smalltalk and objective c. processes in the functional language Erlang can be seen as objects too as they fullfill all criteria. also cite alan kay

\subsubsection{Actors}
\label{sec:actors}
TODO: this seems not to fit into the narrative here, maybe it fits into discussion part or further research

The Actor-Model, a model of concurrency, was initially conceived by Hewitt in 1973 \cite{hewitt_universal_1973} and refined later on \cite{hewitt_what_2007}, \cite{hewitt_actor_2010}. It was a major influence in designing the concept of agents and although there are important differences between actors and agents there are huge similarities thus the idea to use actors to build agent-based simulations comes quite natural. The theory was put on firm semantic grounds first through Irene Greif by defining its operational semantics \cite{grief_semantics_1975} and then Will Clinger by defining denotational semantics \cite{clinger_foundations_1981}. In the seminal work of Agha \cite{agha_actors:_1986} he developed a semantic mode, he termed \textit{actors} which was then developed further \cite{agha_foundation_1997} into an actor language with operational semantics which made connections to process calculi and functional programming languages (see both below). 

An actor is a uniquely addressable entity which can do the following \textit{in response to a message}
\begin{itemize}
	\item Send an arbitrary number (even infinite) of messages to other actors.
	\item Create an arbitrary number of actors.
	\item Define its own behaviour upon reception of the next message.
\end{itemize}

In the actor model theory there is no restriction on the order of the above actions and so an actor can do all the things above in parallel and concurrently at the same time. This property and that actors are reactive and not pro-active is the fundamental difference between actors and agents, so an agent is \textit{not} an actor but conceptually nearly identical and definitely much closer to an agent in comparison to an object. The actor model can be seen as quite influential to the development of the concept of agents in ABS, which borrowed it from Multi Agent Systems \cite{wooldridge_introduction_2009}. Technically, it emphasises message-passing concurrency with share-nothing semantics (no shared state between agents), which maps nicely to functional programming concepts.

The programming-model of actors \cite{agha_actors:_1986} was the inspiration for the Erlang programming language \cite{armstrong_erlang_2010}, which was created in the 1980's by Joe Armstrong for Eriksson for developing distributed high reliability software in telecommunications. The implication is that, the focus would shift immediately to the use of the actor model for concurrent interaction of agents through messages. The languages type-system is strong and dynamic and thus lacks type-checking at compile-time. Thus the structure of computation plays naturally no role because we cannot look at it from the abstract perspective as we can in Haskell. Purity can not be guaranteed and due to agents being processes concurrency is everywhere, and even though it is very tamed through shared-nothing messaging semantics, this implies that repeated runs with same initial conditions might lead to different results. Obviously we could avoid implementing agents as processes but then we basically sacrifice the very heart and feature of the language.