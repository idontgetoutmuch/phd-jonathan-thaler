\section{Agents As Objects}
When we go back to the beginning of this thesis and revisit the viewpoints that object-oriented programming (OO) is a particularly natural development environment for ABS \cite{epstein_growing_1996} and \textit{"agents map naturally to objects"} \cite{north_managing_2007} in the light of the full thesis, the obvious question which comes to mind is whether this thesis implies that we have been doing implementing ABS wrong ever since Epstein advocated OO for it in 1996 - shall Haskell be the new way to got? Obviously that is not the case but as we have shown, with (pure) functional programming comes a lot of potential. Lets elaborate on that.

\medskip

It is a fact that simulations are about consuming, processing and producing data. ABS being simulation methodology is no exception to that fact. Unfortunately, due to OO lack of rigour theoretical foundations, OO as it is used today is \textit{not} very good at representing and manipulating pure data and its data-flow because of two things: \textit{mutable shared state} and explicitly associate data-types and functions(methods)/code/behaviour.

%FROM https://www.youtube.com/watch?v=QM1iUe6IofM&feature=youtu.be
Inheritance is not relevant any more: it has come to a widely agreement amongst OO developers that inheritance should be avoided: https://www.javaworld.com/article/2073649/why-extends-is-evil.html . Note that we are speaking about subclassing not implementing an interface, which is something entirely different
Polymorphism: is not unique to OO and exists in non-OO languages as well and plays a central role in Haskell (and ML languages). Further it is possible to implement polymorphic code in C
Encapsulation: this is seen as the major strength of OO but unfortunately it does not work at a fine grained level of code in todays OO. The original idea was indeed great and it is no coincidence that my implementation ended up with a variation of that as well as Erlang: encapsulate state behind a public interface and interact with it through messages (TODO: fill in alan kay). The very central point of messages though was that they followed "shared nothing" semantics, meaning that no references or pointers could be contained in that message as this would immediately result in a violation of the public interface and ultimately breaks encapsulation. 
OO dominates the industry since around mid 90s. There are varying opinions on that but a major influence to popularise OO was Java, which made its first appearance in 1996. Java was a much easier approach to OO than existing ones e.g. in C++ and VB: it abandoned multiple inheritance, introduced interfaces, was cross-platform, provided high quality libraries including a GUI framework (GUI programming was the way to go in the 90s until it got abandoned in 00s with the emergence of Web 2.0), C/C++ syntax made it easy to pick up, avoided header-files, abandoned pointers and memory management and added garbage collection which made applications a lot safer.

% TODO: need to discuss the problem of shared state. state per se is not necessarily a problem and ever program has state in some form. how explicit it is represented is often used as classification between different kind of paradigms e.g. it has been said that functional programming is stateless but that is obviously not true, state is all over the place but it is very very contained, well behaved and explicit. with shared mutable state this is not the case anymore and we get into the troube of data-dependencies and orderings. this is exactly what we encountered when having introduced a global environment in Sugarscape: although our state is referential transparent and pure functional, they way we used it is globally and we run in ordering issues.

% TODO: isnt shared state also a problem in erlang? after all we can send Pids around and interact with those processes as soon as another process has access to a Pid. In which way is it different to reference passing in OO? There seems to be no difference... so maybe the anti OO argument is not that strong after all and my argument is simply weak or wrong? 

%TODO: i REALLY need to find proper literature / research / evidence which shows the problematic nature of modern OO: mutable shared state which is tied to code. Inheritance and open recursion gives the rest. the problem is that deeply linking \textit{shared mutable} state to its code is the path to failure: abstraction breaks, concurrency and parallelism becomes hard and breaks abstraction, data-driven programming becomes difficult (although that got addressed by adding functional features). NOTE: my approach and erlang have state and behaviour as well but in our case the state is shared nothing and immutable (yes in Haskell we update the agents state but that happens ultimately through closures and continuation in a referential transparent way and still no state is shared between agents. the environment is an exception to some extent as agents can access it globally: this works but requires a specific ordering either through sequential access or STM. this is no different than in an erlang implementation of sugarscape: there needs to be some arbitration of concurrent access). TODO: isnt there some fundamental research on that issue out there?
% TODO: maybe these act as a starting point?
% https://www.yegor256.com/2016/08/15/what-is-wrong-object-oriented-programming.html
% https://dl.acm.org/citation.cfm?id=1806847
% https://web.cs.ucdavis.edu/~filkov/papers/lang_github.pdf "Most notably, it does appear that strong typing is modestly better than weak typing, and among functional languages, static typing is also somewhat better than dynamic typing" "We also find that functional languages are somewhat better than procedural languages" but modest effects
% https://www.javaworld.com/article/2073649/why-extends-is-evil.html
% READ extension problem paper
% READ Ted Kaminskis thesis


%The rise of functional concepts in OO languages in the last years are a strong indication that OO is lacking features which have existed in FP for decades:
%
%\begin{itemize}
%	\item Java 8 added lambda expressions and functional style programming using map, fold, reduce, filter, which together with lambdas allow a data-flow oriented approach to computing.
%	 
%	\item Python, which surges in popularity within the OO family of languages, allows very data-flow centric and functional style of programming through lambda functions, list comprehensions and other functional features as it does not require programmers to stick to the OO paradigm.
%	
%	\item Popularisation of JavaScript frameworks like React, Elm and Purescript, which emphasise a functional, data-flow driven approach of web-programming.
%\end{itemize}

This was by no means clear in the early-to-mid 1990s where the OO paradigm was seen as a silver bullet to the problems of programming: a whole software industry had to re-learn best practices, patterns \cite{gamma_design_1994} and how to avoid pitfalls and bad code \cite{fowler_refactoring:_2012}. Thus we cannot blame \cite{epstein_growing_1996} for advertising OO as the ways to implement ABS, at that time it seemed indeed to be the right thing to do. 

The question is then why not use toolkits like Matlab or R - after all they are completely data-centric? This would be the other extreme, just like OO is and we would run into difficulties as well. The point is that ABS is not purely data-centric either and is indeed richer: agents can interact with each other and with an environment. So we have a tension here: ABS is data-centric on the one hand, and interaction-centric on the other - can we combine both worlds?

The combination of both was exactly the sales pitch of OO for the last 20+ years. Unfortunately this combination leads to nasty bugs due to shared mutable state, deeply complex object hierarchies due to inheritance overuse which also fix behaviour at compile time, open recursion which in the end costs the potential for higher degree of correctness, ease of parallelism and concurrency and the use of property-based testing. Thus we need to separate both: what we need is immutable, shared-nothing state allowing for a data-centric approach \textit{and} an interaction mechanism which allows agents to communicate with each other.

\medskip

This thesis is \textit{one} way of showing how to separate both and reap the benefits. A time-driven ABS like SIR or an ACE with simple agents not interaction with each other like ZI traders is heavily data-centric and very low on agent-interaction. Such data-driven ABS models are quite well expressed in a purely functional approach with the advantage that one can reap the benefits of reproducibility at compile time, using STM for concurrency and property-based testing for verification and validation. An event-driven simulation with complex agent state and agent-interactions like social simulations like Sugarscape or Chemical or Biology simulation with cell interactions are also possible in a pure functional setting as we have shown in the case of the Sugarscape model. Although we were able to give a good solution to complex agent state and synchronous, direct Agent-interactions in our event-driven SIR and Sugarscape and they \textit{do} work in Haskell, they are cumbersome to get right without library support (see further research below) and we cannot reap the benefits of STM in their case. 

This has lead to the fundamental conclusion that simulations which implement complex agent state and agent-communication centric models should rather be implemented in an functional language with actor based concurrency messaging. There are basically two options Cloud Haskell and Erlang \footnote{There is also Elixir, an Erlang dialect. Also there is Scala with the Akka / Actor Library but this is not purely functional and violates the shared nothing semantics, making it less data-centric}.
They are all message orientation will allow you to easily express the complex agent-interactions whilst having the potential to run them in parallel to gain a potentially substantial speed up. Despite its focus on messages, all are (pure) functional languages, which puts you into the data-centric approach: messages are pure data with \textit{shared nothing semantics}. This makes testing easier and also opens the way for property-based testing which is available in Erlang as well where it even allows to detect race conditions \cite{claessen_finding_2009}. Thus we can conclude that agents do \textit{not} map naturally to objects, agents map naturally to actors. 

% TODO: cite armstrongs blog about shared nothing semantics, should be somewhere in my 1st or 2nd year report \\

\medskip

Thus it is not that implementing ABS with OO is wrong - it works reasonably well as a large number of industry strength libraries and frameworks demonstrate. It is more the \textit{missed potential} of a (pure) functional, data-centric approach: strong static type system with explicit controlled side-effects; parallel computation to speed up the simulation with very few changes but retaining static guarantees at compile time; STM to implement concurrent data-flow problems as actual data-flow problems without the need to resort to synchronisation primitives and cluttering the program logic with semantics for synchronisation and concurrency; Property-based testing for verification and validation of a data-centric approach which is central to all simulations; actor model concurrency in the case of Cloud Haskell and Erlang for agent-interaction centric models with a functional, data-centric core. 

Still, there are reasons to stick with OO and avoid FP. There exist a bunch the industry strength toolkits and libraries (Repast, NetLogo, AnyLogic) and the widespread use and knowledge of OO which makes abs implementers readily available. This allows for a quick and cheap implementation of low-impact and straightforward models where the need for correctness, reproducibility, verification and validation is not of primary concern. Also, performance in FP is still a far cry from OO although that argument might get diminished by the potential of using actor based concurrency like in Erlang to implement ABS. Another benefit is that OO as a modelling tool to a problem is still highly useful in the case of UML. %TODO:  discusses if and how peers object-oriented agent-based modelling framework can be applied to our pure functional approach. TODO: i need to re-read peers framework specifications / paper from the simulation bible book. Although peers framework uses UML and OO techniques to create an agent-based model, we realised from a short case-study with him that most of the framework can be directly applied to our pure functional approach as well, which is not a huge surprise, after all the framework is more a modelling guide than an implementation one. E.g. a class diagram identifies the main datastructures, their operations and relations, which can be expressed equally in our approach - though not that directly as in an oo language but at least the class diagram gives already a good outline and understanding of the required datafields and operations of the respective entities (e.g. agents, environment, actors,...). A state diagram expresses internal states of e.g. an agent, which we discussed how to do in both our time- and even-driven approach. A sequence diagram e.g. expresses the (synchronous) interactions between agents or with their environment, something for which we developed techniques in our event-driven approach and we discuss in depth there. 

\medskip

After having undertaken this long journey on how to implement ABS pure functionally, what the general computational structures are in ABS and what benefits and drawbacks there are, at the very end of our discussion I want to return to the claim that \textit{agents map naturally to objects} \cite{north_managing_2007}.

My approach of doing ABS and representing agents in pure FP can be interpret as trying to emulate objects in a purely functional way. In this case we have to say: yes agents map naturally to objects. The question is then: are there other, better mechanisms, more in FP I missed / didnt think of ... to implement ABS in FP? I hypothesize that this is probably NOT the case and that every approach in pure FP follows a roughly similar direction with only a few differences. Obviously it is apparent that both OOP and FP are not silverbullets to ABS and both come with their benefits and drawbacks and both have their existence. Thus I hypothesize that we might see the emergence of different computation paradigms in the future which might fit better to ABS than either one.

yes agents map naturally to objects, but what kind of objects? they differ in implementation details and in this thesis proposed a pure functional approach to a notion of objects. objects in Java work different, as well as in Smalltalk and objective c. processes in the functional language Erlang can be seen as objects too as they fullfill all criteria. also cite alan kay

