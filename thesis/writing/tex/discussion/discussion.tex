\chapter{General Discussion}
\label{ch:discussion}
% starting point
This thesis started out by challenging the established views that \textit{"[..] object-oriented programming [is] a particularly natural development environment for Sugarscape specifically and artificial societies generally [..]"} \cite{epstein_growing_1996} (p. 179) and that \textit{agents map naturally to objects} \cite{north_managing_2007}. As an alternative, a radically different approach to implementing ABS was proposed, using the pure functional programming paradigm. As the language of choice, Haskell was motivated due to its pure functional features, matureness and increasing relevance to real-world applications. 

% motivation
The conjecture was that by using Haskell, one can directly transfer the promises made by pure functional programming to ABS as well, directly gaining highly important benefits, with the common baseline that all those benefits support implementing ABS which are more likely to be correct, something of fundamental value in simulation:

\begin{enumerate}
	\item The strong static type system allows for removing a substantial number and class of bugs at run time and if one programs careful one can even guarantee that no bugs as in crashes or exceptions will occur at run time. This is particularly the case for purely computational problems, without non-deterministic, persistent side effects running in the \texttt{IO} Monad, as ABS almost always are. Obviously IO is involved in all ABS, otherwise the results are not observable. By purely computational, we mean the lack of IO in the agents, as a fundamental part of the model specification, other than visualisation and exporting to an output file.
	
	\item Explicit handling and control of side effects delivers even more static guarantees at compile time and allows us to deal with deterministic side effects (random-number streams, read and write-only contexts, state) in a referential transparent way. In combination with strong static typing this allows to reduce logical bugs, subject to the domain of the problem, by dramatically reducing available, valid operations on data. After all, stateful applications are a fact, the challenge is how to deal with state. As ABS is an inherently stateful problem due to agents and the environment, this should increase the correctness of an ABS implementation as well. Further, this should allow us to produce an implementation which is guaranteed to be reproducible at compile time, where repeated runs with same initial conditions \textit{will} result in same dynamics.
	
	\item Parallel and concurrent programming is claimed to be a lot easier, less painful and less error prone in functional programming in general and in Haskell in particular due to immutable data and the explicit handling of side effects. The concept of STM, which allows to express a problem as a data-flow problem, is highly promising. Besides, data-parallel programming promises to speedup code without the need for changing any of the logic or types. This seemed to offer a straightforward way of speeding up ABS implementations either through data parallelism or concurrency. This has always been quite difficult to achieve in traditional object-oriented ABS and pure functional programming offers a promising solution.
	
	\item The data-centric declarative style, referential transparency and immutability of data makes testing substantially easier due to composability: functions can be easily tested in isolation from each other even if they involve side effects. This opens the door for randomised property-based testing, which seemed to be a perfect match to test ABS implementations which are almost always stochastic in nature.
\end{enumerate}

The central question which needed to be answered first was \textit{how} ABS could be done purely functional, as no research exists which offered a systematic solution to that problem. More specifically, it was unclear how to represent agents, how to express agent identity, local agent state, changing behaviour and interactions amongst agents and the environment. After all, this is straightforward in object-oriented programming due to method calls and mutable shared state, encapsulated in objects. This thesis solution was to use Arrowized FRP, both in the pure implementation of Yampa and the monadic version as in the library Dunai. Building on top of them allowed for implementing pro-activity of agents, encapsulation of local agent state, an environment as shared mutable state and synchronous agent interactions based on an event-driven approach. The central concept behind these approaches are Signal Functions, generalised in Dunai to Monadic Stream Functions, which are implemented using closures and continuations, fundamental building blocks and concepts of pure functional programming. With these techniques it became possible to implement time-driven models like the agent-based SIR, as introduced in Chapter \ref{sec:sir_model} and the highly complex event-driven Sugarscape model as introduced in Chapter \ref{sec:sugarscape}. The fact that the developed concepts can manage the complexity of a full Sugarscape implementation is proof that they are suitable for most agent-based models, running on single machines. 

\medskip

Probably the biggest strength coming out of these implementation techniques is that we can guarantee reproducibility at compile time: given identical initial conditions, repeated runs of the simulation \textit{will} lead to same outputs. This is of fundamental importance in simulation and addressed in the Sugarscape model: \textit{"... when the sequence of random numbers is specified ex ante the model is deterministic. Stated yet another way, model output is invariant from run to run when all aspects of the model are kept constant including the stream of random numbers."} (page 28, footnote 16) - the pure functional approach can guarantee that \textit{at compile time}. Furthermore, we can enforce update semantics to a certain degree by restricting the state agents can manipulate. For example, in the time-driven approach the fact that the environment is provided as read-only and agents cannot interfere with other agents due to purity and complete lack of side effects, factually enforces the parallel update strategy. There is simply no way for agents to misbehave and violate the semantics of updates by mutating state, they are not allowed to.

\medskip

The thesis then turned to the additional opportunities a pure functional approach offers, with focus on parallelism and concurrency and property-based testing. By applying compositional parallelism, it was possible to speed up the non-monadic time-driven ABS by a substantial factor without losing static guarantees about reproducibility. The same was not possible with a monadic approach, which motivated the transition to concurrency using STM, where a substantial speedup was achieved in a monadic implementation sacrificing purity. Still, by limiting the side effects to STM guarantees that the differences of the dynamics of repeated runs come only from the side effects of concurrency and \textit{nothing else}. 

It was shown that adding data parallelism is easy and often requires simply swapping out a data structure or library function against its parallel version. Concurrency, although still hard, is less painful to address and add in a pure functional setting due to immutable data and explicit side effects. Further, the benefits of implementing concurrent ABS based on STM has been shown at length in the respective chapter, which underlines the strength of Haskell for concurrent ABS due to its strong guarantees about retry semantics.

\medskip

The last step was to apply property-based testing to pure functional ABS, to test the hypothesis as to whether stochastic ABS and random property-based testing are a good match. Indeed, it has turned out to be a perfect match: it was possible to fully specify the agents' behaviour of the time and event-driven SIR model directly in code and verify them with QuickCheck. Furthermore, other important techniques relevant for ABS like validation against specifications and comparisons of different implementations of the same model are easily done with property-based testing. Also, by showing how to perform hypothesis testing with property-based testing in the case of the Sugarscape model (see Appendix \ref{app:validating_sugarscape}), we were able to show how to apply it to exploratory models which have no formal ground truth as well.

It was shown that functional programming in general gives much more control and checking of invariants due to the explicit handling of effects. Together with the strong static type system, testing code is in full, explicit control over the functionality it checks. Property-based testing in particular is a perfect match for testing ABS due to the stochastic nature of both and because it supports convenient expressing of specifications. %Thus we can conclude that in a pure functional setting, testing is very expressive and powerful and supports working towards an implementation which is very likely to be correct.

\medskip

This concludes that the thesis successfully proved the usefulness of a pure functional approach, where the initial hypotheses and claims about the benefits as outlined in Chapter \ref{ch:motivation}, were definitely fulfilled.

\input{./tex/discussion/drawbacks.tex}

\input{./tex/discussion/generalising.tex}

%\input{./tex/discussion/whenNot.tex}

\input{./tex/discussion/gintisCase.tex}

\input{./tex/discussion/objects.tex}