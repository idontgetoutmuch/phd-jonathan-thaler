\subsection{Sugarscape}
As already shown in the case of the monadic SIR implementation from the previous section, running agents in parallel within a monadic context does not bring us any speedup - on the contrary, we get penalised with a substantial performance loss due to the overhead incurred by adding parallelism. Further, running the agents in the \textit{Par} Monad alone incurs also a substantial overhead, thus ultimately these roads are dead ends for our Sugarscape implementation as well.

Still, there is one direction for parallelism left, we didn't explore so far: the behaviour of the environment, which is a pure computation, using maps and folds \footnote{In general, folds can be parallelized only when the operation being folded is associative, and then the linear fold can be turned into a tree. Although applicable, we don't follow that approach here and leave it for further research.} over an \textit{IntMap}. It might look like we are out of luck as it seem that we cannot parallelise the updating of an \textit{IntMap} but the work of \cite{marlow_parallel_2013} shows that it is indeed possible through a combination of the \textit{Par} Monad and the \textit{Applicative} type class. The \textit{IntMap} provides the function \textit{traverseWithKey :: Applicative t $\Rightarrow$ (Key $\rightarrow$ a $\rightarrow$ t b) $\rightarrow$ IntMap a $\rightarrow$ t (IntMap b)}. We can use this whenever we need to traverse the whole \textit{IntMap} to update every cell in the list. The obvious use case for this is the regrowing of resources (sugar and spice) in every step.

Unfortunately, measurements quickly reveal that this parallelism makes the performance worse than the sequential - obviously the regrowing of resources is not computation heavy and the parallelism incurs more overhead than the speedup it provides.

Another thing we can parallelise is the computation of the pollution diffusion which uses \textit{map} to compute the new pollution level of each cell. Using \textit{'withStrategy (parList rseq)'} is applied to the list of all cells but the parallelism is too fine-grained: we actually get worse performance than without it - another case for premature optimisation without hard facts profiling.

Thus we end up with the same conclusion as with the monadic SIR implementations: there is practically no opportunity to parallelise the implementation and we refer to the concurrency chapter where we show how to achieve substantial performance improvements when we employ concurrency instead of parallelism.