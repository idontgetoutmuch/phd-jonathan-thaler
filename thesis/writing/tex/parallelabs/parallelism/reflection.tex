\subsection{Reflection}
Despite high hopes, there were very few opportunities to apply parallelism to our pure functional ABS. This has three reasons: it is often highly model specific and our models simply didn't offer a lot of suitable parallelisations, the data-structures have to support parallelism e.g. map doesn't, but we also have to say that the sequential nature of ABS in general seems to be less suited to parallelism. We will see that concurrency offers a remedy against that.

In general we aimed at running agents in parallel using the various techniques. Because of the quite sequential nature of the agent behaviours themselves, there is much less potential for parallelism \textit{within} an agent, thus the obvious idea was to run them all in parallel because they are an obvious unit of partitioning, have considerable workload and can indeed be run in parallel under given circumstances.
Unfortunately it is not possible applying parallelism in case the agents run within a monadic context: we have side-effects which imposes ordering e.g. in the case of a

It becomes apparent, that applying parallelism to our approaches doesn't lead to very much performance increase. This is because in the cases were we can actually run the agents with evaluation parallelism, the performance is not bound by them. As soon as we switch to monadic agents, evaluation parallelism is out of the window, as agents can't be run in parallel anymore because side-effects require to impose a sequential ordering. This can be only tackled using non-deterministic concurrency, which we will show in-depth in the next chapter because it is much more promising than prallelism in terms of performance gain. Further it is also more technically involved and the way we chose to approach it using Software Transactional Memory (STM) hasn't been undertaken in this form ever and to our best knowledge we are the first one to do so.

We see a direct consequence of this that types also reflect the semantics of our model: when our agents are pure they can be run indeed in parallel and independent from each other, if they are monadic, then this is not applicable to parallelism. In the next section, we show how to approach this problem and come up with a solution where we can run monadic agents in parallel. This is obviously only possible within a concurrent setting which means we have to sacrifice determinism in our solution. Still we reach considerable speed ups using Software Transactional Memory.