\section{Parallelism in ABS}
The promise of parallelism is compelling: speeding up the execution but retaining all static compile-time guarantees about determinism. In other words, using parallelism could give us a substantial performance improvement without sacrificing the static guarantees of reproducible outputs from repeated runs.

Generally, parallelism can be applied whenever the execution of code is order-independent, that is, referential transparent and has no implicit or explicit side-effects. We follow the book \cite{marlow_parallel_2013}, which can be seen as the main authority for parallelism and concurrency in Haskell and refer to it for an in-depth discussions of parallel Haskell. From this reference, we can derive the following potential directions for parallelism in ABS:

\begin{itemize}
	\item \textit{Evaluation parallelism} - Without going into too much technical detail, evaluation parallelism allows to build functions which run in parallel e.g. a parallel version of \textit{map}. This is achieved using the \textit{Eval Monad} which is then run using a parallel evaluation strategy, arriving at a pure value - the evaluation of the \textit{Eval Monad} itself is pure and does not require the IO (this is exactly what we expect from parallelism: to be deterministic). The implication of its pure execution is, that although it is expressed using the \textit{Eval Monad}, we can make use of it within pure computations like the non-monadic SIR implementation built on Yampa from Chapter \ref{sec:timedriven_firststep}.

	\item \textit{Data-flow parallelism } - Par Monad: what for? not possible in yampa, but in dunai?
	
	\item \textit{Data-structure parallelism} - an environment could be organised and accessed through such a data-structure, which could potentially lead to big speed ups. Agents could locally read the data-structure data-parallel and the simulation kernel could feed the output of the agents data-parallel back into this structure.
	

\end{itemize}

We keep this section rather short and exemplary and only try to apply the outlined parallelism techniques directly to our existing implementations and measure the speed-up. 

\input{./tex/parallelabs/parallelism/nonmonadic.tex}

\input{./tex/parallelabs/parallelism/monadic.tex}

\input{./tex/parallelabs/parallelism/eventdriven.tex}

\input{./tex/parallelabs/parallelism/parallelruns.tex}

\input{./tex/parallelabs/parallelism/reflection.tex}