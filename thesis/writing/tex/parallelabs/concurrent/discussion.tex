\section{Discussion}
In this chapter we have shown how to apply concurrency to monadic ABS to gain substantially speedup. We developed a novel approach, using STM, which to our best knowledge has not been discussed systematically in the context of ABS so far. This new approach outperforms a traditional lock-based implementation running in the \textit{IO} Monad \textit{and} guarantees that the differences between runs with same initial conditions stem from the non-determinism within \textit{STM} \textit{but nothing else}. The latter point can't be guaranteed by the lock-based approach as it runs in the \textit{IO} Monad, which allows literally anything from reading from a file, to launching a missile. Further, with STM, concurrency becomes more a control-flow oriented concern, so using STM allows us to treat the concurrent problem within an agent as a data-flow oriented one without cluttering the model code with operational details of concurrency. This gives strong evidence that STM should be favoured over lock-based approaches in general for implementing concurrent ABS in Haskell.

Note that in this chapter we assumed that concurrent execution has no qualitative influence on the dynamics: although repeated runs with same initial conditions (might) lead to different results due to non-determinism, the dynamics follow still the same distribution as the one from the sequential implementation. To verify this we can make use the techniques of property-based testing as shown in Chapter \ref{ch:sir_invariants} but we leave it for further research.

The next step would be to add synchronous agent-interactions as they occur in the Sugarscape use-cases of mating, trading and lending. We have started to do work on this already and could implement also one-directional agent-interactions as they occur in the disease transmission, payback of loans and notification of inheritance upon the death of a parent agent. We use the \textit{TQueue} primitive to emulate the behaviour of mailboxes through which agents can post events to each other. The result is promising but needs more investigation. We have also started looking into synchronous agent-interactions using STM which is a lot trickier and is very susceptible to dead-locks (which are still possible in STM!). We have yet to prove how to implement reliable synchronous agent-interactions without deadlocks in \textit{STM}. It might be very well the case that a truly concurrent approach is doomed due to the following \cite{marlow_parallel_2013} (Chapter 10. Software Transactional Memory, "What Can We Not Do with STM?"): \textit{"In general, the class of operations that STM cannot express are those that involve multi-way communication between threads. The simplest example is a synchronous channel, in which both the reader and the writer must be present simultaneously for the operation to go ahead. We cannot implement this in STM, at least compositionally [..]: the operations need to block and have a visible effect — advertise that there is a blocked thread — simultaneously."}. 

Further, \textit{STM} is not fair because \textit{all} threads, which block on a transactional primitive, have to be woken up, thus a FIFO guarantee cannot be given. We hypothesize that for most models, where the \textit{STM} approach is applicable, this has no qualitative influence on the dynamics as agents are assumed to act conceptually at the same time and no fairness is needed. We leave the test of this hypothesis for future research.

We didn't look into applying distributed computation to our approach. One direction to follow would be to use the \textit{Cloud Haskell} library, which is very similar to the concurrency model in Erlang. We leave this for further research as it is beyond the scope of this thesis.

%further research: the approach of executing dependent functions in different layers \url{https://academic.oup.com/bib/article/11/3/334/225993} might allow even further speed-up, also the same paper: "Mobile discrete simulations consisting of agents navigating a grid like environment are less well-suited to a GPU implementation as they are traditionally implemented in sequential environments. Parallel implementations of discrete mobile systems on the GPU must explicitly handle collision conditions which result from agents simultaneously moving to the same discrete location."