\section{Discussion}
implementing agent-interactions in a concurrent implementation with STM. we have started to do work on this already and could implement also async agent-interactions as they occur in the disease transmission, payback of loans and notification of inheritance upon the death of a parent agent. We use the \textit{TQueue} primitive to emulate the behaviour of mail-boxes through which agents can post events to each other which they need to process during the same time-step. The result is promising but needs further investigation. We have also started looking into synchronous agent-interactions using STM which is a lot trickier and is very susceptible to dead-locks (which are still possible in STM!).
Marlow Book: "In general, the class of operations that STM cannot express are those that involve multi-way communication between threads. The simplest example is a synchronous channel, in which both the reader and the writer must be present simultaneously for the operation to go ahead. We cannot implement this in STM, at least compositionally, for the same reason that we cannot implement TMVar with fairness: the operations need to block and have a visible effect—advertise that there is a blocked thread—simultaneously."


further research: the approach of executing dependent functions in different layers \url{https://academic.oup.com/bib/article/11/3/334/225993} might allow even further speed-up, also the same paper: "Mobile discrete simulations consisting of agents navigating a grid like environment are less well-suited to a GPU implementation as they are traditionally implemented in sequential environments. Parallel implementations of discrete mobile systems on the GPU must explicitly handle collision conditions which result from agents simultaneously moving to the same discrete location."


Evaluation Order: Of course, this aspect is not the main focus of the article, but at minimum there should be an evaluation of the simulation output statistics to check for a reasonable correspondence among the simulator implementations. Further, the underlying subject of update order and conflict resolution is central enough to the manuscript to deserve a dedicated discussion, particularly since there is a tension between correctness and performance. The related work section currently focuses on STM and Haskell. In my view, the problem of contention for the agents' environment, for which the lock-based and STM approach provide solutions, should be discussed first.