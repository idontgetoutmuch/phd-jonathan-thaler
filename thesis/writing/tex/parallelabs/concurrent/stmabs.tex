\section{STM in ABS}
\label{sec:stm_abs}
In this section we give a short overview of how we apply STM to pure functional ABS. In both case-studies we fundamentally follow a time-driven, parallel approach as introduced in Chapter \ref{sub:par_strategy}, where the simulation is advanced by a given $\Delta t$ and in each step all agents are executed. To employ parallelism, each agent runs within its own thread and agents are executed in lock-step, synchronising between each $\Delta t$, which is controlled by the main thread. See Figure \ref{fig:stm_abs_structure} for a visualisation of our concurrent, time-driven lock-step approach.

By running each agent in a thread will guarantee the execution in parallel even if the agent has a monadic context. This forces us to evaluate each agents monadic context separately instead of running them all in a common context. Note that ultimately we are ending up in the \textit{IO} context because \textit{STM} can be only transacted from within an \textit{IO} context due to non-deterministic side effects. This is no contradiction to our original claim: yes we are running in \textit{IO} but not the agent behaviour itself, which is a fundamental difference.

An agent thread will block until the main thread sends the next $\Delta t$ and runs the \textit{STM} action atomically with the given $\Delta t$. When the \textit{STM} action has been committed, the thread will send the output of the agent action to the main thread to signal it has finished. The main thread awaits the results of all agents to collect them for output of the current step e.g. visualisation or writing to a file.

As will be described in subsequent sections, central to both case-studies is an environment which is shared between the agents using a \textit{TVar} or \textit{TArray} primitive, through which the agents communicate concurrently with each other. To get the environment in each step for visualisation purposes, the main thread can access the \textit{TVar} and \textit{TArray} as well. 

\begin{figure}
	\centering
	\includegraphics[width=1.0\textwidth, angle=0]{./fig/concurrentabs/stm_abs.png}
	\caption{Diagram of the parallel time-driven lock-step approach.}
	\label{fig:stm_abs_structure}
\end{figure}

\subsection{Adding STM to agents}
We briefly discuss how to add STM to agents on a technical level and also show how to run them within their own threads. We use the SIR implementation as example - applying it to the Sugarscape implementation works exactly the same way and is left as a trivial exercise to the reader.

The first step is to simply add the \textit{STM} Monad as the \textit{outermost} level to the already the existing transformer stack. Further, the environment is now passed as a transactional data primitive to the agent at \textit{construction time}. Thus the agent does not receive the \textit{SIREnv} as input any more but receives it through currying when constructing its initial MSF. Further, the agent modifies the \textit{SIREnv} directly through the \textit{TVar}, as demonstrated in the case of the infected agent.

\begin{HaskellCode}
-- Make Rand a transformer to be able to add STM as innermost monad
type SIRMonad g = RandT g STM
-- Input to agent is now an empty tuple instead of the Environment
type SIRAgent g = SF (SIRMonad g) () SIRState

-- The MSF construction function takes now the TVar with the environment.
sirAgent :: RandomGen g => TVar SIREnv -> Disc2dCoord -> SIRState -> SIRAgent g

-- The infected agent behaviour is nearly the same except that
-- the agent modifies the environment through the TVar
infected :: RandomGen g => SF (SIRMonad g) () (SIRState, Event ())
infected = proc _ -> do
  recovered <- occasionally illnessDuration () -< ()
  if isEvent recovered
    then (do
      -- update the environment through the TVar
      arrM_ (lift $ lift $ modifyTVar env (changeCell coord Recovered)) -< ()
      returnA -< (Recovered, Event ()))
    else returnA -< (Infected, NoEvent)
\end{HaskellCode}

The agent thread is straight forward: it takes \textit{MVar} synchronisation primitives to synchronise with the main thread and simply runs the agent behaviour each time it receives the next \textit{DTime}:

\begin{HaskellCode}
agentThread :: RandomGen g 
            => Int             -- ^ Number of steps to compute
            -> SIRAgent g      -- ^ Agent behaviour MSF
            -> g               -- ^ Random-number generator of the agent
            -> MVar SIRState   -- ^ Synchronisation back to main thread
            -> MVar DTime      -- ^ Receiving DTime for next step
            -> IO ()
agentThread 0 _ _ _ _ = return () -- all steps computed, terminate thread
agentThread n sf rng retVar dtVar = do
  -- wait for dt to compute current step
  dt <- takeMVar dtVar

  -- compute output of current step
  let sfReader = unMSF sf ()
      sfRand   = runReaderT sfReader dt
      sfSTM    = runRandT sfRand rng
  -- run the STM action atomically within IO
  ((ret, sf'), rng') <- atomically sfSTM 

  -- post result to main thread
  putMVar retVar ret
  
  -- tail-recursion to next step 
  agentThread (n - 1) sf' rng retVar dtVar
\end{HaskellCode}

Computing a simulation step is now trivial within the main thread: all agent threads \textit{MVars} are signalled to unblock followed by an immediate block on the \textit{MVars} into which the agent threads post back their result. The state of the current step is then extracted from the environment, which is stored within the \textit{TVar} which the agent threads have updated.

\begin{HaskellCode}
simulationStep :: TVar SIREnv
               -> [MVar DTime]
               -> [MVar SIRState]
               -> DTime
               -> IO SIREnv
simulationStep env dtVars retVars dt = do
  -- tell all threads to continue with the corresponding DTime
  mapM_ (`putMVar` dt) dtVars
  -- wait for results but ignore them, SIREnv contains all states
  mapM_ takeMVar retVars
  -- return state of environment when step has finished
  readTVarIO env
\end{HaskellCode}

The difference to an implementation which uses \textit{IO} are minor but far reaching. Instead of using \textit{STM} as outermost Monad, we use \textit{IO}, thus running the whole agent behaviour within the \textit{IO} Monad. Instead of receiving the environment through a \textit{TVar}, the agent receives it through an \textit{IORef}. It also receives an \textit{MVar} which is the synchronisation primitive to synchronise the access to the environment in the \textit{IORef} amongst all agents. Agents grab and release the synchronisation lock of the \textit{MVar} when they enter and leave a critical section in which they operate on the environment stored in the \textit{IORef}.