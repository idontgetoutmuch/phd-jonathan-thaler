\chapter{Implementing ABS}
\label{ch:impl_abs}

In this Chapter we briefly discuss general problems and considerations, ABS implementations need to solve, independent from the programming paradigm. In general, an ABS implementation must solve the following fundamental problems:

\begin{enumerate}
	\item How to represent an agent, its local state and its interface.
	\item How to represent agent-to-agent interactions and defining and enforcing their semantics.
	\item How to represent an environment.
	\item How to represent agent-to-environment interactions and defining and enforcing their semantics.
	\item How agents and an environment can initiate actions without external stimuli.
	\item How to step the simulation.
\end{enumerate}

% agent- and environment pro-activity
We argue that the most fundamental concept of ABS is the \textit{pro-activity} of both, agents and its environment. In computer systems, pro-activity, the ability to initiate actions on its own without external stimuli, is only possible when there is some internal stimulus, most naturally represented by a continuous increasing time-flow. Due to the discrete nature of computer systems, this time-flow must be discretized in steps as well and each step must be made available to the agent, acting as the internal stimulus. This allows the agent then to perceive time and become pro-active depending on time. So we can understand an ABS as a discrete time-simulation where time is broken down into continuous, real-valued or discrete natural-valued time-steps. Independent of the representation of the time-flow we have the two fundamental choices whether the time-flow is local to the agent or whether it is a system-global time-flow. Time-flows in computer-systems can only be created through threads of execution where there are two ways of feeding time-flow into an agent. Either it has its own thread-of-execution or the system creates the illusion of its own thread-of-execution by sharing the global thread sequentially among the agents where an agent has to yield the execution back after it has executed its step. Note the similarity to an operating system with cooperative multitasking in the latter case and real multi-processing in the former.

% time- and event-driven ABS
Generally, there exist time- and event-driven approaches to ABS \cite{meyer_event-driven_2014}. In time-driven ABS, time is explicitly modelled and is the main driver of the ABS dynamics. The semantics of models using this approach, center around time. As a representative example, which will be used in Chapter \ref{ch:timedriven} on time-driven ABS, we use the agent-based SIR model \cite{macal_agent-based_2010, thaler_pure_2018}. Often such models are inspired by an underlying System Dynamics approach, where the continuous time-flow is the main driving force of the dynamics. It is clear that almost every ABS models time in some way, after all, this is the very heart of Simulation: modelling a virtual system over some (virtual) time. Still we want to distinguish clearly between different semantics of time-representation in ABS: when time is seen as a continuous flow such as in the example of the agent-based SIR model, we talk about a truly time-driven approach. In other words: if an agent behaves as a time-signal then we speak of a time-driven approach. This means that if the system is sampled with a $\Delta t = 0$ then, even though the agents are executed their behaviour must stay constant and must not change.

In the case where time advances in a discrete way either by means of events or messages, we talk about an event-driven approach. As a representative example, which will be used in Chapter \ref{ch:eventdriven} on event-driven ABS, we use the Sugarscape model. In this model time is discrete and represented by the natural numbers where agents act in every tick - time is not modelled explicitly as in the agent-based SIR case. In such a model, the underlying semantics map more naturally to a DES core, extended by ABS features. Although the Sugarscape model does not semantically map to a DES core in a strict sense, our implementation approach is very close to such and can be easily extended to a true DES core - thus it serves as a good example for the discussion of the event-driven approach. Further, using an event-driven SIR implementation, we also show how to extend it to a pure DES core, allowing to implement models with more explicit event-driven semantics as discussed in \cite{meyer_event-driven_2014}.

% agent representation
According to the definition of ABS in  Chapter \ref{sec:method_abs}, an agent is a uniquely addressable entity with an identity, an internal state it has exclusive control over and can be interacted with by means of messages. In the established object-oriented approaches to ABS all this is implemented naturally by the use of objects: an object has a clear identity, encapsulates internal state and exposes an interface through public methods through which objects can interact with each other, also called messaging. The same applies to the environment and it is by no means clear how to achieve this in a pure functional approach where we don't have objects available - this will be addressed in the subsequent Chapters \ref{ch:timedriven} and \ref{ch:eventdriven}.

Before we look into pure functional ABS implementation concepts in the next chapters, we need to discuss the concept of update strategies \cite{thaler_art_2017}. Generally, there are four strategies to approach time-driven ABS, where the differences deal with how the simulation is stepped, the agents are executed and the interaction semantics work.

% agent-to-agent interaction ant its semantics
%The semantics of messaging define when sent messages are visible to the receivers and when the receivers process them. Message-processing could happen either immediately or delayed, depending on how message-delivery works. There are two ways of message-delivery: immediate or queued. In the case of immediate message-deliver the message is sent directly to the agent without any queuing in between e.g. a direct method-call. This would allow an agent to immediately react to this message as this call of the method transfers the thread-of-execution to the agent. This is not the case in the queued message-delivery where messages are posted to the message-box of an agent and the agent pro-actively processes the message-box at regular points in time. With established OOP approaches we can have both: either a direct method-call or a message-box approach - in pure FP this is a much more subtle problem and it turns out that the problem of messaging / interacting of agents and of agents with the environment is the most subtle problem when approaching ABS from a pure functional perspective.

\section{Sequential Strategy}
\label{sec:seq_strategy}
In this strategy there exists a globally synchronized time-flow and in each time-step the simulation iterates through all the agents and updates one agent after another. Messages sent and changes to the environment made by agents are visible immediately, meaning that if an agent sends messages to other agents or changes the environment, agents which are executed after this agent will see these changes within the same time-step. There is no source of randomness and non-determinism, rendering this strategy to be completely deterministic in each step. Messages can be processed either immediately or queued depending on the semantics of the model. If the model requires to process the messages immediately the model must be free of potential infinite-loops. Often in such models, the agents are shuffled when the model semantics require to average out the advantage of being executed as first. This strategy is of fundamental importance for event-driven ABS in Chapter \ref{ch:eventdriven}. See Figure \ref{fig:strategy_seq} for a visualisation of the control flow in this strategy.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\textwidth, angle=0]{./fig/implabs/sequential.png}
	\caption{Control flow in the Sequential Strategy.}
	\label{fig:strategy_seq}
\end{figure}

\section{Parallel Strategy}
\label{sub:par_strategy}

This strategy has a globally synchronized time-flow and in each time-step iterates through all the agents and updates them in parallel. Messages sent and changes to the environment made by agents are visible in the next global step. We can think about this strategy in a way that all agents make their moves at the same time.  If one wants to change the environment in a way that it would be visible to other agents this is regarded as a semantic error in this strategy. First, it is not logical because all actions are meant to happen at the same time and second, it would implicitly induce an ordering, violating the semantics of the model, the \textit{happens at the same time} idea.
It does not make a difference if the agents are really executed in parallel or just sequentially - due to the isolation of information, this has the same effect. Also it will make no difference if we iterate over the agents sequentially or randomly, the outcome has to be the same: the strategy is event-ordering invariant as all events and updates happen \textit{virtually at the same time}. This strategy is of fundamental importance for time-driven ABS in Chapter \ref{ch:timedriven}. See Figure \ref{fig:strategy_par} for a visualisation of the control flow in this strategy.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.4\textwidth, angle=0]{./fig/implabs/parallel.png}
	\caption{Control flow in the Parallel Strategy.}
	\label{fig:strategy_par}
\end{figure}

\section{Concurrent Strategy}
This strategy has a globally synchronized time-flow but in each time-step all the agents are updated in parallel with messages sent and changes to the environment are visible immediately. So this strategy can be understood as a more general form of the \textit{parallel strategy}: all agents run at the same time but act concurrently. It is important to realize that when running agents, which are able to see actions by others immediately, in parallel, we arrive at the very definition of concurrency: parallel execution with mutual read/write access to shared data. Of course this shared data-access needs to be synchronized which in turn will introduce event-orderings in the execution of the agents. At this point we have a source of inherent non-determinism: although when one ignores any hardware-model of concurrency, at some point we need arbitration to decide which agent gets first access to a shared resource, arriving at non-deterministic solutions. This has the very important consequence that repeated runs with the same configuration of the agents and the model may lead to different results. This strategy is of fundamental importance for concurrent ABS in Chapter \ref{ch:concurrent_abs}. See Figure \ref{fig:strategy_conc} for a visualisation of the control flow in this strategy.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\textwidth, angle=0]{./fig/implabs/concurrent.png}
	\caption{Control flow in the Concurrent Strategy.}
	\label{fig:strategy_conc}
\end{figure}

\section{Actor Strategy}
This strategy has no globally synchronized time-flow but all the agents run concurrently in parallel, with their own local time-flow. The messages and changes to the environment are visible as soon as the data arrive at the local agents - this can be immediately when running locally on a multi-processor or with a significant delay when running in a cluster over a network. Obviously this is also a non-deterministic strategy and repeated runs with the same agent- and model-configuration may (and will) lead to different results. It is of most importance to note that information and also time in this strategy is always local to an agent as each agent progresses in its own speed through the simulation. In this case one needs to explicitly \textit{observe} an agent when one wants to e.g. visualize it. This observation is then only valid for this current point in time, local to the observer but not to the agent itself, which may have changed immediately after the observation. This implies that we need to sample our agents with observations when wanting to visualize them, which would inherently lead to well known sampling issues. A solution would be to invert the problem and create an observer-agent which is known to all agents where each agent sends a \textit{'I have changed'} message with the necessary information to the observer if it has changed its internal state. This also does not guarantee that the observations will really reflect the actual state the agent is in but is a remedy against the notorious sampling. The concept of Actors was proposed by \cite{hewitt_universal_1973} for which \cite{grief_semantics_1975} and \cite{clinger_foundations_1981} developed semantics of different kinds. These works were very influential in the development of the concepts of agents and and can be regarded as foundational basics for ABS. We come back to this strategy in the context of concurrent ABS in Chapter \ref{ch:concurrent_abs}. See Figure \ref{fig:strategy_act} for a visualisation of the control flow in this strategy.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\textwidth, angle=0]{./fig/implabs/actor.png}
	\caption{Control flow in the Actor Strategy.}
	\label{fig:strategy_act}
\end{figure}

\section{Discussion}
In the following chapters we discuss \textit{how} to implement ABS from a pure functional perspective and \textit{why} one would do so. More specifically, we show how to approach the problems discussed in this using pure functional programming (FP). The \textit{sequential} strategy will be covered in-depth in Chapter \ref{ch:eventdriven} on event-driven ABS, the \textit{parallel} one in Chapter \ref{ch:timedriven} on time-driven ABS and the \textit{concurrent} strategy is used in Chapter \ref{ch:concurrent_abs} on concurrent ABS. The \textit{actor} strategy is not used in this thesis but its implementation follows directly from the Chapters \ref{ch:timedriven} and \ref{ch:parallel_abs}: instead of globally synchronising in the main-thread, a closed feedback-loop is run in every agent thread. 

As already outlined in Chapter \ref{sec:method_abs}, the established approaches implementing ABS use object-oriented programming and thus solve the problems outlined at the start of this chapter from this perspective, which is quite well understood by now, as high quality ABS frameworks like RePast \cite{north_complex_2013} prove. In object-oriented programming an agent is mapped directly onto an object, encapsulating the agents state and providing methods, which implement the agents' actions. Object-orientation allows to expose a well-defined interface using public methods by which one can interact with the agent and query information from it. Agent objects can directly invoke other agents' methods, implicitly mutating the other agents' internal state, which makes direct agent interaction straight forward. Also with object-orientation, agents have global access to an environment e.g. through a Singleton or a simple global variable, and can mutate the environments data by direct method calls.

All these language features are not available in FP and compare to object-orientation we face seemingly severe restrictions like immutable state, recursion and a static type system. Further, we restrict ourselves deliberately to \textit{pure} FP and avoid running in the non-deterministic \textit{IO} context under all costs. The question is then how to solve these problems in FP \textit{and} use the restrictions to our advantage. In the next two chapters we show how to implement both a time-driven ABS  using the agent-based SIR model as example (Chapter \ref{ch:timedriven}) and an event-driven ABS using the Sugarscape model as example (Chapter \ref{ch:eventdriven}). In both we present fundamental concepts of how to engineer an ABS from a pure FP perspective. This will then be used in subsequent chapters to discuss \textit{why} one would follow an FP approach, identifying its benefits, advantages and also drawbacks over object-oriented approaches. 

%An implementation of an ABS must solve two fundamental problems:
%
%\begin{enumerate}
%	\item \textbf{Source of pro-activity} How can an agent initiate actions without the external stimuli of messages?
%	\item \textbf{Semantics of Messaging} When is a message \textit{m}, sent by agent \textit{A} to agent \textit{B}, visible and processed by \textit{B}?
%\end{enumerate}
%
%In computer systems, pro-activity, the ability to initiate actions on its own without external stimuli, is only possible when there is some internal stimulus, most naturally represented by a continuous increasing time-flow. Due to the discrete nature of computer-system, this time-flow must be discretized in steps as well and each step must be made available to the agent, acting as the internal stimulus. This allows the agent then to perceive time and become pro-active depending on time. So we can understand an ABS as a discrete time-simulation where time is broken down into continuous, real-valued or discrete natural-valued time-steps. Independent of the representation of the time-flow we have the two fundamental choices whether the time-flow is local to the agent or whether it is a system-global time-flow. Time-flows in computer-systems can only be created through threads of execution where there are two ways of feeding time-flow into an agent. Either it has its own thread-of-execution or the system creates the illusion of its own thread-of-execution by sharing the global thread sequentially among the agents where an agent has to yield the execution back after it has executed its step. Note the similarity to an operating system with cooperative multitasking in the latter case and real multi-processing in the former.
%
%The semantics of messaging define when sent messages are visible to the receivers and when the receivers process them. Message-processing could happen either immediately or delayed, depending on how message-delivery works. There are two ways of message-delivery: immediate or queued. In the case of immediate message-deliver the message is sent directly to the agent without any queuing in between e.g. a direct method-call. This would allow an agent to immediately react to this message as this call of the method transfers the thread-of-execution to the agent. This is not the case in the queued message-delivery where messages are posted to the message-box of an agent and the agent pro-actively processes the message-box at regular points in time.