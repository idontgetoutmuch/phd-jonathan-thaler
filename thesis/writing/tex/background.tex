\chapter{Background}
\label{ch:background}

\input{./tex/background/literature.tex}

\input{./tex/background/abs.tex}

\input{./tex/background/fp.tex}

\section{Methodology}
%- Methodology is the justification for using a particular research method.
%- make clear what our method is (Method is simply a research tool, a component of research â€“ say for example, a qualitative method such as interviews) and then justify it => this is then the methodology 
%- discussion of methodology is missing: what is the scientific approach we used in our thesis to address the aims and answer hypotheses? Basically we perform use-cases and discuss them\\

In this section we briefly motivate and justify our methods, to point out the scientific approach used in this thesis to address the aims and answer hypotheses put forward in the Introduction Chapter \ref{ch:intro}. Fundamentally, the method we use is developing concepts step-by-step using the two well known agent-based models SIR \ref{sec:sir_model} and Sugarscape \ref{sec:sugarscape}. We put our approach into a broader context of how to implement ABS from a programming language agnostic view, discussed in Chapter \ref{ch:impl_abs} which serves as underlying assumptions and general direction to follow.

The first part of our method is dedicated to develop how to implement ABS in a pure functional way. The aim is to develop a robust, maintainable and extensible solution to existing models at which example we show concepts which can be adopted to ABS in general. The overall goal is a clear representation of agents with their local (immutable) state, a way for the agents to interact with an (active) environment and interactions amongst agents where necessary. It is quite important to state this clearly as we could follow a rather completely data-driven approach, which would have been very easy in pure functional programming: represent all agents and the simulation state as a big data-structure which is passed in and out pure functions (thus read/write). Indeed it would work but we would probably end up in a difficult to understand data-flow (everything is read/write) and what is worse: we don't arrive at very general solutions as we would not abstract out concepts, existing in ABS already which could then be transferred easily. Note that a more data-driven approach has indeed its value, depending on the model! In Chapter \ref{ch:gintis_case} we briefly introduce the field of ACE, where agents are almost always completely represented by data and very simple behaviour and do not interact in a complex way as in Sugarscape. Examples are ZI traders or bilateral traders which are all simply represented by data and interact with each other quite indirectly through a trading and bartering process.

The second part of our method is dedicated to show the benefits of using the previously developed pure functional approach to ABS. It is split into two parts where in the first we investigate the hypothesis that pure functional programming makes it easy to apply parallel computation using parallelism and concurrency to ABS. The second part answers another central hypothesis namely that randomize property-based testing is a good match to test stochastic ABS implementations.

The concepts we derive are driven by the hypotheses and aims from the introduction and we continuously refer back to them, especially in the respective discussions and the final conclusion and discussion. By doing this we are able to qualitatively assess whether we have achieved our aim and answered the hypotheses in a satisfactory way, which is reviewed more in-depth and holistic in the final discussion and conclusion chapters.