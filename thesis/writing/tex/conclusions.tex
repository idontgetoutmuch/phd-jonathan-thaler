\chapter{Conclusions}
\label{ch:conclusions}

We come back to the initial point where we started from: "Agents map naturally to Objects".
oop puts modelling into the Center, fp data. some abs models require more modelling (social science), some more Data (economics), these differences show up in the Implementation: choose oop if modelling is more important, otherwise use fp. but the event driven sugarscape shows Impressively that we can achieve similar abstractions found in oop with fp, thus we can agree: "yes, agents mal naturally onto objects" but throughout the journey of this thesis we have come to a much richer and deeper understanding of the meaning behind those words and we have understood that objects have a variety of representations and need to be thought more abstract than just in their technical reptesentations in java, Python or c++ for example. whether they are newtypes, tuples, GADTs, monads, comonads, arrows, SFs or MSFs: those are all valid ways of representing agents with varying degree of abstraction, flexibility and power. 

%we now know how to engineer time- and event-driven ABS with complex state both in the agent and environment, main difficulty is direct agent-interaction (see macal classification into 4 types of ABS), compile-time guaranteed reproducibility, explicit handling of complex state (read only, read/write), concurrency explicit and limited to STM, very promising concurrency but direct agent-interactions main problem (erlang as a rescue?), main drawbacks: everything is explicit, performance

\section{Further Research}
clearly outline the ideas for further research

\subsection{A general purpose library}
generalise concepts explored into a pure functional ABS library in Haskell (called chimera)

\subsection{Dependent and linear types}
dependent types and linear types are the next big step, towards a stronger formalisation of agents and ABS,
focus on the equilibrium - totality correspondence

\subsection{Concurrent event-driven ABS}
stm based concurrency for event-driven ABS using parallel DES. challenge is the time-warp implementation using monads. in general it should be easy to roll-back agents actions but with monads we have to be careful - for some monads rolling back is not neccessary e.g. rand and reader, for others it is, and for some it is impossible e.g. IO