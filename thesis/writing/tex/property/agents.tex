\chapter{Testing Agents}
\label{ch:prop_agents}

% TODO read / watch
% https://iohk.io/blog/an-in-depth-look-at-quickcheck-state-machine/
% https://wickstrom.tech/programming/2019/03/24/property-based-testing-in-a-screencast-editor-case-study-1.html
% https://jaspervdj.be/posts/2015-03-13-practical-testing-in-haskell.html#the-action-trick
% https://hackage.haskell.org/package/quickcheck-state-machine

% OK
% https://begriffs.com/posts/2017-01-14-design-use-quickcheck.html
% https://blog.ploeh.dk/2019/03/11/an-example-of-state-based-testing-in-haskell/

Agent behaviour - obviously full agent behaviour could be tested with property-tests, using randomly generated agents (with random values in their properties). As it turned out to be quite difficult to derive properties for, in this paper we restricted ourselves to test parts of agent behaviour and also left out testing of agent interactions.

We didn't look into testing full agent and interacting agent behaviour using property-tests due to its complexity which would justify a whole paper alone. Due to its inherent stateful nature with complex dependencies between valid states and agents actions we need a more sophisticated approach as outlined in \cite{de_vries_-depth_2019}, where the authors show how to build a meta-model and commands which allow to specify properties and valid state-transitions which can be generated automatically. We leave this for further research.

What is particularly powerful is that one has complete control and insight over the changed state before and after e.g. a function was called on an agent: thus it is very easy to check if the function just tested has changed the agent-state itself or the environment: the new environment is returned after running the agent and can be checked for equality of the initial one - if the environments are not the same, one simply lets the test fail. This behaviour is very hard to emulate in OOP because one can not exclude side-effect at compile time, which means that some implicit data-change might slip away unnoticed. In FP we get this for free.

\section{Individual Agent behaviour}
We implemented a number of property-tests for agent functions which just cover a part of an agents behaviour: checks whether an agent has died of age or starved to death, the metabolism, immunisation step, check if an agent is a potential borrower or fertile, lookout, trading transactions. We provided custom data-generators for the agents and let QuickCheck generate the random data and us running the agent with the provided data, checking for the properties. 

As an example, provided in listing \ref{alg:prop_test_agent}, we give the property-test of an agent dying from age, which happens when the agents age is greater or equal its maximum age. It might look trivial but property-based testing helps us here to clearly state the invariants (properties) and relieves us from constructing all possible edge-cases because we rely on QuickChecks abilities to cover them for us.

\begin{algorithm}
\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
\Input{Random agent \textit{ag} generated by QuickCheck}
\Input{Random age \textit{randAge} within a specified range generated by QuickCheck}
set age of agent ag to randAge\;
ageLimit = get agents age limit\; 
died = agentDieOfAge ag;\

\eIf{died == (randAge >= ageLimit}{
  PASS\;
} {
  FAIL\;
}
\caption{Property-based test for agent dying of age.}
\end{algorithm}
\label{alg:prop_test_agent}


TODO: sir individual Agent testing: randomly generate events and feed them into agents,susceptible must can never become recovered, infected never susceptible and recovered never susceptible or infected. test propabilities e.g. infected agent recovering schedules event with average illnessduration. susceptible schedules on average contactrate events, recovered schedules no events, an infected replies to each contact

TODO: refine existing Sugarscape quickcheck: look into monadic testing

TODO: sugarscape agent testing: avoid error with ErrorEvent, which is handled individually by the kernel. this makes such cases testable

TODO: look at coverage of the sir testing usinh stack test --coverage

TODO: agent testing: look into statechart quickcheck to get idea and understanding by the example of event-driven SIR, then adopt it to the Sugarscape

\section{Agent interaction}

TODO: sugarscape: individual agent testing works analog to SIR, can we do random testing of synchronous agent-interactions? generate valid sequences e.g. test trading and mating - but what are the properties?