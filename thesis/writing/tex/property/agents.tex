\chapter{Testing Agents}
\label{ch:prop_agents}

TODO read / watch
% https://hackage.haskell.org/package/quickcheck-state-machine
% https://iohk.io/blog/an-in-depth-look-at-quickcheck-state-machine/
% https://www.stackbuilders.com/news/types-versus-tests-two-approaches-for-writing-correct-software
% https://blog.ploeh.dk/2019/03/11/an-example-of-state-based-testing-in-haskell/
% https://sakshamsharma.com/2018/03/haskell-proj-struct/
% https://iohk.io/blog/an-in-depth-look-at-quickcheck-state-machine/
% https://wickstrom.tech/programming/2019/03/24/property-based-testing-in-a-screencast-editor-case-study-1.html

We didn't look into testing full agent and interacting agent behaviour using property-tests due to its complexity which would justify a whole paper alone. Due to its inherent stateful nature with complex dependencies between valid states and agents actions we need a more sophisticated approach as outlined in \cite{de_vries_-depth_2019}, where the authors show how to build a meta-model and commands which allow to specify properties and valid state-transitions which can be generated automatically. We leave this for further research.

\begin{itemize}
	\item Environment behaviour - the Sugarscape environment has its own behaviour which boils down to regrowing of resources. The correct working can be tested using property-tests by generating random environments and checking laws governing the regrowth.
	\item Agent behaviour - obviously full agent behaviour could be tested with property-tests, using randomly generated agents (with random values in their properties). As it turned out to be quite difficult to derive properties for, in this paper we restricted ourselves to test parts of agent behaviour and also left out testing of agent interactions.
\end{itemize}


What is particularly powerful is that one has complete control and insight over the changed state before and after e.g. a function was called on an agent: thus it is very easy to check if the function just tested has changed the agent-state itself or the environment: the new environment is returned after running the agent and can be checked for equality of the initial one - if the environments are not the same, one simply lets the test fail. This behaviour is very hard to emulate in OOP because one can not exclude side-effect at compile time, which means that some implicit data-change might slip away unnoticed. In FP we get this for free.

\section{Environment behaviour}
The environment in the Sugarscape model has some very simple behaviour: each site has a sugar level and when harvested by an agent, it regrows back to the full level over time. Depending on the configuration of the model it either grows back immediately within 1 tick or over multiple ticks. We can construct simple property-tests for these behaviours. In the case the sugar grows back immediately we let QuickCheck generate a random environment and then run the environment behaviour for 1 tick and then check the property that all sites have to be back to their maximum sugar level. In the case of regrow over multiple ticks, we also use QuickCheck to generate a random environment but additionally a random \textit{positive} rate (which is a floating point number) which we then use to calculate the number of ticks until full regrowth. After running the random environment for the given number of ticks all sites have to be back to full sugar level - see \ref{alg:prop_test_rateregwroth} for an algorithm for this case.

Note that QuickCheck initially doesn't know how to generate a random environment because each site consists of a custom data-structure for which QuickCheck is not able to generate random instances by default. This problem is solved by writing a custom data-generator, for which existing QuickCheck functions can be used e.g. picking the current sugar level of a site from a random range.

\begin{algorithm}
\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
\Input{Random environment \textit{env} generated by QuickCheck}
\Input{Regrowth rate \textit{randRate} (positive floating point) generated by QuickCheck}
maxTicks = maxSugarCapacityOnSites / randRate\;
env' = runEnvironmentTicks maxTicks env\;
sites = getEnvironmentSites env'\;

\eIf{all sites maxSugarLevel}{
  PASS\;
} {
  FAIL\;
}
\caption{Property-based test for rate-based regrow of sugar on all sites.}
\end{algorithm}
\label{alg:prop_test_rateregwroth}

The Sugarscape environment is a torus where the coordinates wrap around in both dimensions. To check whether the implementation of the wrapping-calculation is correct we used both unit- and property-tests. With the unit-tests we carefully constructed all possible cases we could think of and came up with 13 test-cases. With the property-based test we simply defined a single test-case where we expressed the property that after wrapping \textit{any} coordinates, supplied by QuickCheck, the wrapped coordinates have to be within bounds. See the algorithm in \ref{alg:prop_test_wrapcoords}.

\begin{algorithm}
\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
\Input{Random 2d discrete coordinate \textit{randCoord} generated by QuickCheck}
(x, y) = wrapCoordinates randCoord\;

\eIf{(x $\geq$ 0 and x $\leq$ environmentDimX) and (y $\geq$ 0 and y $\leq$ environmentDimY)}{
  PASS\;
} {
  FAIL\;
}
\caption{Property-based test for wrap-coordinates functionality.}
\end{algorithm}
\label{alg:prop_test_wrapcoords}

\section{Agent behaviour}
We implemented a number of property-tests for agent functions which just cover a part of an agents behaviour: checks whether an agent has died of age or starved to death, the metabolism, immunisation step, check if an agent is a potential borrower or fertile, lookout, trading transactions. We provided custom data-generators for the agents and let QuickCheck generate the random data and us running the agent with the provided data, checking for the properties. 

As an example, provided in listing \ref{alg:prop_test_agent}, we give the property-test of an agent dying from age, which happens when the agents age is greater or equal its maximum age. It might look trivial but property-based testing helps us here to clearly state the invariants (properties) and relieves us from constructing all possible edge-cases because we rely on QuickChecks abilities to cover them for us.

\begin{algorithm}
\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
\Input{Random agent \textit{ag} generated by QuickCheck}
\Input{Random age \textit{randAge} within a specified range generated by QuickCheck}
set age of agent ag to randAge\;
ageLimit = get agents age limit\; 
died = agentDieOfAge ag;\

\eIf{died == (randAge >= ageLimit}{
  PASS\;
} {
  FAIL\;
}
\caption{Property-based test for agent dying of age.}
\end{algorithm}
\label{alg:prop_test_agent}

\section{Stateless testing}

\section{Stateful testing}