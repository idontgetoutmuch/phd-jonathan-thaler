\chapter{Testing Agent specifications}
\label{ch:agentspec}

In this chapter we are showing how to use QuickCheck to encode full agent-specifications directly in code as property-tests. These properties serve then both as formal specification and tests at the same time - a fundamental strength of property-based testing, not possible with unit-testing in this strong expressive form. Besides the high expressivity, QuickCheck also allows us to state statistical coverage for certain cases, which allows to express statistical properties of the agents behaviour, something also not directly possible with unit-testing. This is a very strong indication that property-based testing is a natural fit to test agent-based simulation. We discuss both time- and event-driven  implementations of the agent-based SIR model as introduced in Chapter \ref{sec:sir_model}.

\input{./tex/property/agentSpecEvent.tex}

\input{./tex/property/agentSpecTime.tex}

\section{Discussion}
In this section we have shown how to express the specifications of both the event- and time-driven agent behaviour directly in code as properties and how to implement property-tests in QuickCheck for them. The approach to event-driven properties was to establish a correspondence between an input-event the current agent-state and the output events and the new agents state. In case of the time-driven agent, the properties are expressed in terms of a potentially infinite stream of agent output-states. Although both implementations follow the same underlying model, the technical details of the properties differ substantially. The reason for this is that although property-based testing is a black-box verification technique, the implementation often requires substantial knowledge of the internal details as can be seen especially in the event-driven case.

The resulting properties are highly expressive due to pattern matching and declarative programming and can be regarded as a kind of formal specification. Together with the properties which check the state-transition probabilities, we claim that the property-tests shown in this chapter fully specify both the event- and time-driven agent behaviour. This is a first example emphasising the usefulness of QuickCheck for testing ABS, providing a first strong evidence for the hypothesis that randomised property-testing is a good match for testing ABS.

%- time-driven is rather straight forward: just feed the population and increment the time, the agents are much more a black-box than in the event-driven approach, where there is much revealed about their inner workings through the events, thus we have to be much more explicit in event-driven. Note that we were not able to state a coverage for the infection of susceptible agents because the distribution is bimodal due to the combined probabliities of the exponential and uniform distriubtion. In event-driven we were able to state a coverage because we decoupled the process of making contact from infection: the makeContact events followed a uniform distribution as well, generated by oureselves, so we could state an expected coverage.

Curiously, the implementation of all the specifications and property-tests is a lot larger than the original implementations. Still, that is not the point here: we showed how to implement a full specification of an ABS model as a property-based test and we succeeded! This is definitely a strong indication that our hypothesis that randomised property-based testing is a suitable tool for testing ABS is valid. With unit tests we would be quite lost here: even for the SIR model, it is hard to enumerate all possible interactions and cases but by stating invariants as properties and generating random test-cases we make sure they are checked.

We have not looked into more complex testing patterns like the synchronous agent-interactions of Sugarscape. We didn't look into testing full agent and interacting agent behaviour using property-tests due to its complexity which would justify a part paper alone. Due to its inherent stateful nature with complex dependencies between valid states and agents actions we need a more sophisticated approach as outlined in \cite{de_vries_-depth_2019}, where the authors show how to build a meta-model and commands which allow to specify properties and valid state-transitions which can be generated automatically. We leave this for further research.

What is particularly powerful is that one has complete control and insight over the changed state before and after e.g. a function was called on an agent: thus it is very easy to check if the function just tested has changed the agent-state itself or the environment: the new environment is returned after running the agent and can be checked for equality of the initial one - if the environments are not the same, one simply lets the test fail. This behaviour is very hard to emulate in OOP because one can not exclude side-effect at compile time, which means that some implicit data-change might slip away unnoticed. In FP we get this for free.

Note that by exploiting lazy evaluation in the time-driven tests we scratch on what is conveniently possible in established approaches to ABS: we can let the simulation run potentially forever as in the case of the infected agent and rely on the correctness of the implementation to terminate in finite step when consuming the potentially infinite stream.

Note that we did not include an explicit environment in our agent specification tests and assumed a full connected network where all agents can make contact with each other. We think that property-based testing is highly useful there as well, especially when dealing with random environment like in Sugarscape or social and random networks \cite{jackson_social_2008, easley_networks_2010}. We leave this for further research but we hypothesise that for the SIR model all properties presented here should still hold under different environments.
