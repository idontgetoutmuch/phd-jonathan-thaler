\chapter{Stateful agent testing}
So far, our tests were stateless: only one computational step of an agent was considered by feeding a single event and ignoring the agent continuation. Also the events didn't contain any notion of time as they would carry within the queue. Feeding follow-up events into the continuation would make testing inherently stateful as we introduce history into the system. Such tests would allow to test the full life-cycle of an agent, which we were not able to model properly with QuickCheck so far due to the libraries stateless nature.

Fortunately there exists the \textit{quickcheck-state-machine} library \footnote{See \url{https://hackage.haskell.org/package/quickcheck-state-machine}}, which allows to let actions depend on the history of the system by using a state-machine approach. This is an ideal match for property-testing ABS as agents almost always have some notion of inner state and very often agents are actually implemented in terms of state-machines. The agents in the event-driven SIR are no exception to this: although their state is not explicit as for the agents in the Sugarscape model, they are state-machines, transitioning from the \textit{Susceptible} to the \textit{Recovered} state, depending on incoming events generated by actions of other agents.

To build a model for property-tests with quickcheck-state-machine we need the following ingredients:

\begin{itemize}
	\item Underlying state - This is the very state of the stateful testing, upon which the tests operate. In our case the state consists of a single agent continuation, the random-number generator, the current simulation time and the list of all agent ids. Note that we are interested in testing a single agent over a longer history, not the interaction of a whole bunch of agents, that is why we only hold a single agent in the state.
	
	\item An API to test against - This is the interface to manipulate the underlying state and present valid actions the test can carry out, generally consisting of a bunch of functions to test. In the stateful approach it is convenient to represent the API as an ADT where the constructors represent API calls. This allows easy enumeration and generation of random API calls with generate arguments following some constraints and interdependencies. In our case of even-driven agents the API is the agent MSF with its monadic context, receiving events, which can already be seen as API calls represented through ADT - the agent simply interprets them. Thus this step is very naturally expressed in event-driven ABS testing and does not require any complicated translation of API calls. Technically it is a bit more subtle: because we talk about history now, instead of representing the API as plain SIREvents, we use QueueItem which holds the receiver, the scheduling time and the SIREvent.
	
	\item A shrinker - reduces the sequence of API calls but which still generate the same error - in other words a shrinker reduces a failing sequence of API calls to the most minimal one in which the test-case still fails. A shrinker depends highly on the state and the API. In our case for example a shrinker can safely remove \textit{Recover} events from the sequence of API calls in case the agent is \textit{Susceptible} or \textit{Recovered} as those events have no effect in these states.
	
	\item Test-cases - We need to come up with some test-cases we want to validate. In state-machine testing the intention is often a verification of a 
\end{itemize}


TODO: can we also implement the existing tests in terms of the state-machine? yes we can but we leave this for further research. Also we don't think it is very useful but disguises things more and hides the detail that the existing tests are stateless.
