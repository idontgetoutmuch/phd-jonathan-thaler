\chapter{Testing event-driven agents}

In this chapter we present how QuickCheck can be used to test event-driven agents by expressing their \textit{specification} as
property-tests. We use the event-driven SIR implementation from chapter (TODO: ref).
In general, testing event-driven agents follows different directions and is more complex than time-driven ones as the interface surface is generally much larger: events form the input to the agents to which they react with new events - the dependencies between those can be quite complex and deep. Using property-based tests we can encode the invariants and end up with an actual specification of their behaviour, acting as documentation, regression test within a TDD and property tests.

Note that the concepts presented here are applicable with slight adjustments to the Sugarscape implementation as well but we focused on the SIR one as its specification is shorter and does not require as much in-depth details - after all we are interested in deriving concepts, not dealing with specific technicalities.

\section{The Susceptible Agent Specification}
With event-driven ABS a good starting point in specifying and then testing the system is simply relating the input events to expected output events. In the SIR implementation we have only 3 events, making it feasible to give a full formal specification - note that the Sugarscape implementation has more than 16 events, which makes it much harder to test it with sufficient coverage, giving a good reason to primarily focus on the SIR implementation. Lets state the input-to-output event correspondence of the Susceptible agent, which forms as our specification:

\begin{enumerate}
	\item \textit{MakeContact} - If the agent receives this event it will output a random number of \textit{Contact ai Susceptible} events, where ai is the agents self id and the random number follows an exponential distribution with $\lambda = \beta (contact rate)$. The events have to be scheduled immediately without delay, thus having a time-step of the current time. The receivers of the events are uniformly randomly chosen from the agent population. The agent doesn't change its state, stays \textit{Susceptible} and does not schedule any other events than the ones mentioned.
	
	\item \textit{Contact * Infected} - If the agent receives this event there is a chance of uniform probability $\gamma$ that the agent becomes \textit{Infected}. If this happens, the agent will schedule a \textit{Recover} event to itself into the future, where the time is drawn randomly from the exponential distribution with $\lambda = \delta (illness duration)$. If the agent does not become infected, it won't change its state, stays \textit{Susceptible} and does not schedule any events.
	
	\item \textit{Contact * *} or \textit{Recover}  - If the agent receives any other events it won't change its state, stays \textit{Susceptible} and does not schedule any events.
\end{enumerate}

The question is now how to put these into a property-test with QuickCheck.

\section{Discussion}
Funnily the implementation of all the specifications and property-tests is longer than the original implementation. Though thats not the point here: we showed how to implement a full specification of an ABS model as a property-based test and we succeeded! This is definitely a strong indication that our hypothesis that randomised property-based testing is a suitable tool for testing ABS is valid.