\section{Time-driven specification}
\label{sec:timedriven_specification}
The time-driven SIR agents have a very small interface: they only receive the agent-population from the previous step and output their state in the current step. We can also assume an implicit forward flow of time, statically guaranteed by Yampas arrowized FRP. Thus a specification in time-driven approach is given in terms of probabilities and timeouts, rather than in events as in the event-driven testing as presented before.

\begin{itemize}
	\item Susceptible agent - makes \textit{on average} contact with $\beta$ (contact rate) agents per time-unit. The distribution follows the exponential distribution with $\lambda = \frac{1}{\beta}$. If a susceptible agents get into contact with an infected agent, it will become infected with a uniform probability of $\gamma$ (infectivity).
	
	\item Infected agent - \textit{will} recover \textit{on average} after $\delta$ (illness duration) time units. The distribution follows the exponential distribution with $\lambda = \delta$.

	\item Recovered agent - stays recovered \textit{forever}.
\end{itemize}

\subsection{Specifications of the susceptible agent}
We start with the susceptible agent. We cannot directly observe that an agent makes contact with other agents like we can in the event-driven approach but only indirectly through its change of state: a susceptible agent \textit{might} become infected if there are infected agents in the population.
Thus when we run a susceptible agent for some time, we have 3 possible outcomes of the agents output stream: 1. the agent did not get infected and thus all elements of the stream are \textit{Susceptible}; 2. the agent got infected thus up to a given index in the stream all elements are \textit{Susceptible} and change to \textit{Infected} after; 3. the agent got infected and then recovered thus the stream is the same as in infected but there is a second index after which all elements change to \textit{Recovered}. Encoding them in code is straightforward:

\begin{HaskellCode}
susceptibleInvariants :: [SIRState] -- ^ The output stream of the susceptible agent 
                      -> Bool       -- ^ The population contains an infected agent
                      -> Bool       -- ^ True in case the invariant holds
susceptibleInvariants aos infInPop
    -- Susceptible became Infected and then Recovered
    | isJust recIdxMay 
      = infIdx < recIdx &&  -- agent has to become infected before recovering
        all (==Susceptible) (take infIdx aos) && 
        all (==Infected) (take (recIdx - infIdx) (drop infIdx aos)) && 
        all (==Recovered) (drop recIdx aos) &&
        infInPop  -- can only happen if there are infected in the population

    -- Susceptible became Infected
    | isJust infIdxMay 
      = all (==Susceptible) (take infIdx aos) &&
        all (==Infected) (drop infIdx aos) &&
        infInPop -- can only happen if there are infected in the population

    -- Susceptible stayed Susceptible
    | otherwise = all (==Susceptible) aos
  where
    -- look for the first element when agent became Infected
    infIdxMay = elemIndex Infected aos
    -- look for the first element when agent became Recovered
    recIdxMay = elemIndex Recovered aos

    infIdx = fromJust infIdxMay
    recIdx = fromJust recIdxMay
\end{HaskellCode}

Putting this into a property-test is also straightforward. We generate a random population of up to 1,000 agents, run a random susceptible agent with a sampling rate of $\Delta t = 0.01$ and check the invariants on its output stream. These invariants all have to hold independently from the (positive) duration we run the random susceptible agent for, thus we run it for a random amount of time units. The invariants also have to hold for arbitrary positive beta (contact rate), gamma (infectivity) and delta (illness duration). At the same time, we want to get an idea of the percentage of agents which stayed susceptible, became infected or made the transition to recovered, thus we label all our tast-cases accordingly.

\begin{HaskellCode}
prop_susceptible_invariants :: Positive Double  -- ^ Random beta, contact rate
                            -> Positive Double  -- ^ Random gamma, infectivity
                            -> Positive Double  -- ^ Random delta, illness duration
                            -> Positive Double  -- ^ Random t, duration 
                            -> Property
prop_susceptible_invariants 
      (Positive t) (Positive cor) (Positive inf) (Positive ild) = property (do  
    -- generate population with size of up to 1000
    as <- resize 1000 (listOf genSIRState)
    -- population contains an infected agent True/False
    let infInPop = Infected `elem` as

    -- run a random susceptible agent for random time-units with 
    -- sampling rate dt 0.01 and return its stream of output
    aos <- genSusceptible cor inf ild as t 0.01

    return 
        -- label all test-cases
        (label (labelTestCase aos) 
        -- check invariants on output stream
        (property (susceptibleInvariants aos infInPop)))
  where
    labelTestCase :: [SIRState] -> String
    labelTestCase aos
      | Recovered `elem` aos = "Susceptible -> Infected -> Recovered"
      | Infected `elem` aos  = "Susceptible -> Infected"
      | otherwise            = "Susceptible -> Susceptible"
\end{HaskellCode}

This test so far did not state anything about the probability of a susceptible agent getting infected. The probability for it is bi-modal due to the combined probabilities of the exponential distribution of the contact rate and the uniform distribution of the infectivity. Unfortunately, the bi-modality makes it not possible to compute a coverage percentage of infected in this case, as we did in the event-driven test because the bi-modal distribution can only be described in terms of a distribution and not a single probability. This was possible in the even-driven approach because we decoupled the production of the \textit{MakeContact} event from the infection: both were uniform distributed, thus we could compute a coverage percentage. Thus we see that different approaches also allow different explicitness of testing.

\subsection{Probabilities of the infected agent}
Lets look at the infected agent now. An infected agent \textit{will} recover after \textit{finite} time, thus we assume that there exists an index in the output stream, where the elements will change to \textit{Recovered}. From the index we can compute the time of recovery, knowing the fixed sampling rate $\Delta t$.

\begin{HaskellCode}
infectedInvariant :: [SIRState]     -- ^ The stream of outputs from the infected agent
                  -> Double         -- ^ Sampling rate dt
                  -> Maybe Double   -- ^ Just recovery time, or Nothing if not recovered
infectedInvariant aos dt  = do
  -- search for the index of the first Recovery element
  recIdx <- elemIndex Recovered aos
  -- all elements up to the index need to be Infected,
  -- because the agent cannot go back to Susceptible
  if all (==Infected) (take recIdx aos)
    then Just (dt * recIdx)
    else Nothing
\end{HaskellCode}

To put this into a property-test, we follow a similar approach as in the event-driven case of the infected agents invariants. We employ the CDF of the exponential distribution to get the probability of an agent recovering within $\delta$ (illness duration) time steps. We then run a random infected agent for an \textit{unlimited} time with a sampling rate o f $\Delta t = 0.01$ and search in its potentially infinite output stream for the first occurrence of an \textit{Infected} element to compute the recovery time, as shown in the invariant above.

\begin{HaskellCode}
prop_infected_invariants :: Property
prop_infected_invariants = checkCoverage (do
   -- delta, illness duration
  let illnessDuration = 15.0
  -- compute percentage of agents which recover in less or equal 
  -- illnessDuration time-units. Follows the exponential distribution
  -- thus we use the CDF to compute the probability.
  let perc = 100 * expCDF (1 / illnessDuration) illnessDuration
  -- fixed sampling rate
  let dt = 0.01
  
  -- generate population with size of up to 1000
  as <- resize 1000 (listOf genSIRState)

  -- run a random infected agent without time-limit (0) and sampling rate
  -- of 0.01 and return its infinite output stream 
  aos <- genInfected illnessDuration as 0 dt

  -- compute the recovery time
  let durMay = infectedInvariant aos dt

  return (cover perc (fromJust durMay <= illnessDuration)
            ("infected agents have an illness duration of  " ++ show illnessDuration ++
            " or less, expected " ++ printf "\%.2f" perc)
            -- test passes if the agent recovered
            (isJust durMay))
\end{HaskellCode}

The fact that we run the random infected agent without time-limit explicitly expresses the invariant that an infected agent \textit{will} recover in \textit{finite} time-steps: a correct implementation will produce a stream which contains an index from which on elements are all \textit{Infected}, thus resulting in \textit{Just} recovery time. This is a direct expression of the fact that the CDF of the exponential distribution reaches 100\% at infinity. An approach which would guarantee the termination would be to limit the time to run the infected agent to \textit{illnessDuration} and evaluate the property always to True. This approach guarantees termination but removes an important part of the specification - we decided to follow the initial approach to make the specification really clear, and in practise it has turned out to terminate within a very short time (see below).

\subsection{The non-computability of the recovered agent test}
The property-test for the recovered agent is trivial: we run a random recovered agent for a random number of time-units with $\Delta t = 0.01$ and require that all elements in the output stream are \textit{Recovered}. Of course this is no proof that the recovered agent stays recovered \textit{forever} as this would take \textit{forever} to test and is thus not computable.  Here we are hitting the limits of what is possible with random black-box testing: without looking at the actual implementation it is not possible to proof that the recovered agent is really behaving as specified. We made this fact very clear at the beginning of this section: property-based testing is not a proof for the correctness but only supports one in raising the confidence in the correctness by constructing cases which show that the behaviour is not incorrect.

To be really sure that the recovered agent behaves as specified we need to employ white-box verification and look at the actual implementation. It is immediately obvious that the implementation follows the specification and actually \textit{is} the specification, and we can even regard it as a very concise proof that it will stay recovered \textit{forever}:

\begin{HaskellCode}
recoveredAgent :: SIRAgent
recoveredAgent = constant Recovered
\end{HaskellCode}

The signal function \textit{constant} is the \textit{const} function lifted into an arrow: \textit{constant b = arr (const b)}. This should be proof enough that a recovered agent will stay recovered \textit{forever}. We will come back to the topic of computability in pure functional ABS in a slightly different context in Chapter \ref{ch:equilibrium_totality}.

\subsection{Running the tests}
Due to the high dimensionality of the random sampling space, especially in the susceptible invariant property-test we run 10,000 tests. All succeed as expected and there is no surprise in their output.

\begin{verbatim}
SIR Agent Specifications Tests
  Susceptible agents invariants: OK (12.72s)
    +++ OK, passed 10000 tests:
    55.78% Susceptible -> Infected -> Recovered
    37.19% Susceptible -> Infected
     7.03% Susceptible
  Infected agent invariants:     OK (0.43s)
    +++ OK, passed 3200 tests (62.28% infected agents have an illness 
        duration of 15.0 or less, expected 63.21).
  Recovered agent invariants:    OK (0.09s)
    +++ OK, passed 10000 tests.
\end{verbatim}
