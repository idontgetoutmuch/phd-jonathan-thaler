\chapter{Testing time-driven agents}

TODO WEAK ARGUMENT: discussion of time-delta is completely missing, but its a very important concept here! investigate it!

In this chapter we present how QuickCheck can be used to test time-driven agents from the time-driven SIR implementation (TODO ref to chapter). More specifically, we show how to test isolated agent behaviour by deriving invariant properties, encoding them directly in code and running them. 
In general, testing isolated agent behaviour in the time-driven approach is quiet straightforward as the interface surface is quite small, leading to not much options what you can do with them. Basically the only options we have is to run a given agent for a given number of steps with a given time-delta, population and model parameters. Lets start with the \textit{susceptible} agent.

\section{Susceptible agent}
The main concept behind the susceptible agent is, that it might become infected, depending on its contact rate, the infectivity of the disease and the number of infected agents in the population. Let's derive a formula for the probability of a \textit{susceptible} agent to become infected given the above mentioned parameters. This probability will then act as an invariant for a QuickCheck test into which we encode this property. Note that we are talking here about probabilities - the challenge will be to encode them into a hard PASS/FAIL property-test.

\subsection{Deriving a property}
We assume the following parameters:

\begin{enumerate}
	\item The contact rate $\beta$. Per time-unit a \textit{susceptible} agent makes \textit{on average} contact with $\beta$ agents from the population. The distribution follows the exponential distribution with $\lambda = \frac{1}{\beta}$.
	\item The infectivity of the disease $\gamma$. If a \textit{susceptible} agents get into contact with an \textit{infected} agent, it will become infected with a uniform probability of $\gamma$. 
	\item The population size $N$.
	\item The number of \textit{infected} agents $I$ in the population.
\end{enumerate}

First we need to know the probability of an agent making contact with $\beta$ agents per time-unit. Note that this is \textit{not} the mean of the exponential distribution but we need to use the cumulative distribution (CDF) function to get this value. We define this value as $p_{cont} = CDF_{e{\frac{1}{\beta}}} (\beta)$ which is the probability of the CDF of the exponential distribution with $\lambda = \frac{1}{\beta}$ and $x = \beta$.
Next we need to incorporate the probability of an agent getting into contact with an infected agent which is simply the ratio of the number of infected agents to total population size: $ir = \frac{I}{N}$. Finally to arrive at the total probability we multiply these probabilities including the infectivity $\gamma$, arriving at the following formula for a susceptible agent to become infected \textit{on average}: $Sus_{inf} = p_{cont} * \frac{I}{N} * \gamma$.

\subsection{Encoding the property}
Now lets encode this into a property-test. The encoding of the probabilities is straightforward: we assume fixed parameters for $\beta$, $\gamma$ and the population and simply encode the formulas into Haskell code. Then we run a random \textit{susceptible} agent for 1 time-unit with the given parameters using a \textit{Generator} which returns true in case the agent got infected. 

The question is now: how do we check the agent got infected with the computed probability \textit{on average}? We use the coverage features of QuickCheck. The library offers the \textit{cover :: Double $\rightarrow$ Bool $\rightarrow$ String $\rightarrow$ property} function, which works as follows: The first parameter specifies the expected percentage of test-cases belonging to the class which have to succeed, the second parameter indicates if a test-case belongs to the class, the third parameter is a label for the class and the fourth parameter is the test indicating success or failure. We pass the computed probability as the expected percentage and make the test-case belong to the class if the agent got infected. We provide a label and we make \textit{all} tests succeed. The later might be weird, after all, why should all tests succeed? We want to have some measure of failure. QuickCheck provides the \textit{checkCoverage} function, which checks the coverage requirements defined with a \textit{cover} and uses a statistically sound test to check if the encoded cover assumption holds or not - in other words: instead of fixing the number of test-cases, when using \textit{checkCoverage}, QuickCheck runs as many test-cases as necessary until it is convinced that coverage holds, in which case the property-test passes, or fails if this becomes statistically not possible.

\begin{HaskellCode}
prop_susceptible_infected :: Property
prop_susceptible_infected = checkCoverage (do  
  -- define the parameters
  let contactRate = 5     -- beta
      infectivity = 0.05  -- gamma
      population  = [Susceptible, Infected, Recovered]
      n           = length population
      i           = length (filter (==Infected) population)
      	  
  -- compute the probabilities
  let pcont = 100 * expCDF (1 / contactRate) contactRate
      ir    = i / n
    
  -- compute the expected probability
  let susInf = pcont * ir * infectivity

  -- run a random susceptible agent for 1.0 time-unit return true if infected
  infected <- genSusceptibleInfected contactRate infectivity population

  -- expect given percentage of susceptible agents to have become infected
  return (cover susInf infected
          ("susceptible agents became infected, expected at least " ++ show susInf)) True)
\end{HaskellCode}

Note that all the parameters can be varied arbitrarily and the test will still work. Also note that we have to fix the population instead of taking a random one, otherwise percentage of coverage would change in every test-case, which would not make sense and will make the property-test fail.
TODO: why cant we randomize the population?

\subsection{Testing the property}
When running the property-test repeatedly we see that the encoded property holds:

\begin{verbatim}
Susceptible agents become infected:   OK (0.09s)
  +++ OK, passed 6400 tests (1.72% susceptible agents became infected, 
      expected at least 1.05).
Susceptible agents become infected:   OK (0.17s)
  +++ OK, passed 12800 tests (1.539% susceptible agents became infected, 
      expected at least 1.05).
Susceptible agents become infected:   OK (0.04s)
  +++ OK, passed 3200 tests (2.12% susceptible agents became infected, 
      expected at least 1.05).
Susceptible agents become infected:   OK (0.17s)
  +++ OK, passed 12800 tests (1.617% susceptible agents became infected,
      expected at least 1.05).    
\end{verbatim}

It is arguably questionable that we accept a higher percentage than we expected but we argue that we are close enough. TODO: can we really argue like that? also if we decrease the dt to e.g. 0.01 we get higher percentage of recovery... something seems to be not right here...

\section{Infected agent}
The main concept behind the \textit{infected} agent is that it \textit{will} recover \textit{on average} after the illness duration, specified as $\delta$ in the model.

\subsection{Deriving the property}
The idea is to run an infected agent until it recovers and measure the time it has stayed infected, resulting in the illness duration. The time until recovery follows an exponential distribution with $\lambda = \delta$. To make this a property, we need to average the illness duration of multiple random infected agents which we will then compare to an expected value $\delta$, using of a two-tailed t-test with confidence of $\alpha = 0.05$.
 
\subsection{Encoding the property}
We follow the exact same approach as in the susceptible using \textit{cover} and \textit{checkCoverage} but the decision whether the test belongs to the class is now made depending on whether the t-test fails or succeeds. Instead of computing the expected coverage we expect 95\% of all agents recovering within the given time.

\begin{HaskellCode}
prop_infected_meanIllnessDuration :: Property
prop_infected_meanIllnessDuration = checkCoverage (do
  let illnessDuration = 15.0 -- delta
  
  -- run 100 random infected agents until they recover and return the 
  -- duration they were ill
  ids <- vectorOf 100 (genInfectedIllnessDuration illnessDuration)
    
  let confidence = 0.95
      idsTTest   = tTestSamples TwoTail illnessDuration (1 - confidence) ids

  return (cover 95 idsTTest
         ("infected agents have a mean illness duration of " ++ show illnessDuration) True))
\end{HaskellCode}

\subsection{Testing the property}

When running the property-test repeatedly we see that the encoded property holds:

\begin{verbatim}
Infected agent mean illness duration: OK (4.85s)
  +++ OK, passed 800 tests (94.4% infected agents have a 
      mean illness duration of 15.0).
Infected agent mean illness duration: OK (4.79s)
  +++ OK, passed 800 tests (95.0% infected agents have a 
      mean illness duration of 15.0).
Infected agent mean illness duration: OK (4.84s)
  +++ OK, passed 800 tests (93.2% infected agents have a 
      mean illness duration of 15.0).
Infected agent mean illness duration: OK (4.79s)
  +++ OK, passed 800 tests (94.8% infected agents have a 
      mean illness duration of 15.0).
\end{verbatim}

Although we don't hit the 95\% in every case, QuickChecks statistical tests are convinced enough that the coverage of 95\% is sound and thus deems the property-test to be successful.

\section{Discussion}
Testing time-driven agents seems to be quite forward if one can derive properties for them. A crucial thing to get right in time-driven ABS is $\Delta t$ - property-tests can be of help here by stating properties which have to hold and then refining $\Delta t$ until the property holds.