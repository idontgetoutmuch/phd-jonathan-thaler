\chapter{Pure Functional ABS}
\label{ch:fp_abs}

In this chapter we discuss \textit{how} to implement ABS from a pure functional perspective. More specifically, we show how to approach the problems discussed in the previous Chapter \ref{ch:impl_abs} using pure functional programming (FP).

The established approaches to implementing ABS follow the object-oriented paradigm (OOP) and solve these problems from this perspective, which is quite well understood by now, as high quality ABS frameworks like RePast \cite{north_complex_2013} prove. In OOP an agent is mapped directly onto an object, encapsulating the agents state and providing methods, which implement the agents' actions. OOP allows to expose a well-defined interface using public methods by which one can interact with the agent and query information from  it. Agent objects can directly invoke other agents' methods, implicitly mutating the other agents' internal state, which makes direct agent interaction straight forward. Also with OOP, agents have global access to an environment e.g. through a Singleton or a simple global variable, and can mutate the environments data by direct method calls.

All these language features are not available in FP and we face seemingly severely restrictions like immutable state, recursion, a static type-system. Further we restrict ourselves deliberately to \textit{pure} FP and avoid running in \textit{IO} under all costs. The question is then to solve these problems in FP \textit{and} use the restrictions to our advantage. Depending on the type and model of the ABS we approach these problems slightly different. In the next two sections we show how to implement both a time-driven ABS using the agent-based SIR model as example and an event-driven ABS using the Sugarscape model as example. In both sections we present fundamental concepts of how to engineer an ABS from a pure FP perspective. This will then be used in subequent chapters to discuss \textit{why} one would follow an FP approach, identifying its benefits and advantages over OOP approaches.

\input{./tex/fpabs/timedriven.tex}

\input{./tex/fpabs/eventdriven.tex}

\section{Generalising}
TODO: can we derive an agent-monad?

TODO: what about comonads? read essence dataflow paper \cite{uustalu_essence_2006}: monads not capable of stream-based programming and arrows too general therefor comonads, we are using msfs for abs therefore streambased so maybe applicable to our approach/agents=comonads. comonads structure notions of context-dependent computation or streams, which ABS can be seen as of. this paper says that monads are not capable of doing stream functions, maybe this is the reason why i fail in my attempt of defining an ABS in idris because i always tried to implement a monad family. TODO: stopped at comonad section, continue from there. TODO understand comonads: https://www.schoolofhaskell.com/user/edwardk/cellular-automata and https://kukuruku.co/post/cellular-automata-using-comonads/

independent of time-driven or event-driven, our agents are MSFs.