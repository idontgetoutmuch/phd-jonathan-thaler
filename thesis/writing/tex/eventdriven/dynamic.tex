\subsection{Dynamic agent creation and removal}
Some models of ABS in general and Sugarscape in particular require the dynamic creation and removal of agents during simulation. The specific requirements here are that the agents themselves must be able to both remove themselves from the simulation and create new agents with given attributes. To achieve that, in such a simulation the output type of an agent must be richer than the one in the event-driven SIR. First, we define the output of an agent:

\begin{HaskellCode}
data AgentOut m e o = AgentOut
  { aoKill   :: Any              -- True if this agent should be removed 
  , aoCreate :: [AgentDef m e o] -- a list of agents to create
  , aoEvents :: [(AgentId, e)]   -- a list of events (receiver, event)
  }
\end{HaskellCode}

Note that \textit{AgentOut} contains already the list of scheduled events, which makes it clear that scheduling of events in this approach is implemented different than in the event-driven SIR, where the agents Monad stack had a \textit{WriterT} to write events to. The reason for that is that we treat agent-local abstractions different here because of the need to encapsulate local agent state as explained in subsequent sections.

If the agent wants to remove itself from the simulation, it simply sets \textit{aoKill} to True; it it wants to create new agents it adds an agent definition \textit{AgentDef} to the \textit{aoCreate} list. The agent definition \textit{AgentDef} holds the new id of the agent (note that an agent-controlled id makes it possible to re-use ids in case an agent dies and in case ids have no other purposes than identifying event receivers in a model), the MSF of the agent to create and the initial output of the new agent, so it has a representation in the visual or textual output.

\begin{HaskellCode}
data AgentDef m e o = AgentDef
  { adId      :: AgentId         -- unique agent-id
  , adMSF     :: AgentMSF m e o  -- the agent behaviour function
  , adInitOut :: o               -- the value of the initial output
  }
\end{HaskellCode}

Further, the simulation must provide a \textit{global} mechanism to create new, unique \textit{AgentId} for the newly created agents. The generating of ids for the new agents have to occur within the parent agents themselves because in some models they might need this very id to communicate with their children - an indirection through the kernel would only complicate matters. We thus start with a data definition, holding the next agent id - if an agent creates a new agent it simply reads that value and increments it by 1.

\begin{HaskellCode}
data ABSState = ABSState { absNextId :: AgentId }
\end{HaskellCode}

To make it \textit{globally} available to all agents a \textit{StateT ABSState} Monad transformer is used, which is also the innermost Monad of the Monad stack of Sugarscape \footnote{In the Sugarscape implementation, \textit{ABSState} also holds the current simulation time, which is omitted here for clarity reasons.}.

\begin{HaskellCode}
type AgentMonad m = StateT ABSState m
\end{HaskellCode}

Finally, we can define the polymorphic type of the agent MSF, as it is used in Sugarscape, where it is parametrised with model specific types (see next sections). It is similar to the event-driven SIR, where the agent takes the \textit{ABSEvent} as input but the output is now a tuple of \textit{AgentOut} and the polymorphic agent output type \textit{o}. The reason why the output type \textit{o} is not part of \textit{AgentOut} is to keep \textit{AgentOut} a Monoid, which allows accumulative / iterative change to \textit{AgentOut}, which is important for scheduling events, as explained in the agent-local abstractions below.

\begin{HaskellCode}
type AgentMSF m e o = MSF (AgentMonad m) (ABSEvent e) (AgentOut m e o, o)
\end{HaskellCode}