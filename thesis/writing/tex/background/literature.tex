\section{Related Research and Literature}
\label{sec:literature}
The amount of research on using pure functional programming with Haskell in the field of ABS has been moderate so far. Most of the papers are related to the field of Multi-Agent Systems and look into how agents can be specified using the belief-desire-intention paradigm \cite{de_jong_suitability_2014,jankovic_functional_2007,sulzmann_specifying_2007}.

A multi-method simulation library in Haskell called \textit{Aivika 3} is described in the technical report \cite{sorokin_aivika_2015}. It supports implementing Discrete Event Simulations, System Dynamics and comes with basic features for event-driven ABS which is realised using Discrete Event Simulation under the hood. Additionally, it provides functionality for adding GPSS to models and supports parallel and distributed simulations. It runs within the \texttt{IO} Monad for realising parallel and distributed simulation, but also discusses generalising their approach to avoid running in \texttt{IO}.

In his master thesis \cite{bezirgiannis_improving_2013} the author investigates Haskells' parallel and concurrency features to implement (amongst others) \textit{HLogo} a Haskell clone of the NetLogo \cite{wilensky_introduction_2015} simulation software, focusing on using Software Transactional Memory for a limited form of agent interactions. \textit{HLogo} is a reimplementation of NetLogos API in Haskell, where agents run within \texttt{IO} and can thus make use of Software Transactional Memory functionality. The benchmarks show that this approach does indeed result in a speedup, especially under larger agent populations. The authors' thesis is one of the first on ABS using Haskell. Despite the concurrency and parallel aspect, this thesis approach is rather different: it avoids \texttt{IO} within the agents under all costs and explores the use of Software Transactional Memory more on a conceptual level and compares case studies with lock-based implementations.

Some research does exist \cite{di_stefano_using_2005, sher_agent-based_2013, varela_modelling_2004} using the functional programming language Erlang \cite{armstrong_erlang_2010} to implement concurrent ABS. The language is inspired by the Actor Model \cite{agha_actors:_1986} and was created in 1986 by Joe Armstrong for Eriksson, for developing distributed high reliability software in telecommunications. The Actor Model can be seen as quite influential to the development of the concept of agents in ABS, which borrowed it from Multi-Agent Systems \cite{wooldridge_introduction_2009}. It emphasises message-passing concurrency with shared-nothing semantics (no shared state between agents), which maps nicely to functional programming concepts. The mentioned papers investigate how the actor model can be used to close the conceptual gap between agent specifications. Furthermore, they show that using this kind of concurrency allows for overcoming some problems of low level concurrent programming.
Also \cite{bezirgiannis_improving_2013} ported NetLogos API to Erlang mapping agents to concurrently running processes, which interact with each other by message passing. With some restrictions on the agent interactions the author could deliver a working implementation of the model. This shows that using concurrent message passing for parallel ABS is at least \textit{conceptually} feasible. Despite the natural mapping of ABS concepts to such an actor language, it leads to simulations, where due to concurrency, despite same initial starting conditions, repeated runs might result in different dynamics.

The work \cite{lysenko_framework_2008} discusses a framework, which allows to run ABS on a GPU. Amongst others, they use the Sugarscape model and scale it up to millions of agents on very large environment grids. They reported an impressive speedup of a factor of 9,000. Although their work is conceptually very different, this thesis draws inspiration from their work in terms of performance measurement and comparison to the Sugarscape model.

Using functional programming for Discrete Event Simulation was discussed in \cite{jankovic_functional_2007} where the authors explicitly mention the paradigm of Functional Reactive Programming to be very suitable to Discrete Event Simulation.

A domain-specific language for developing functional reactive ABS was presented in \cite{schneider_towards_2012,vendrov_frabjous_2014}. This language called FRABJOUS is human readable and easily understandable by domain experts. It is not directly implemented in Functional Reactive Programming in Haskell but is compiled to Haskell code, which the authors claim is also readable. This supports that Functional Reactive Programming is a suitable approach to implement ABS in Haskell. Unfortunately, the authors do not discuss their mapping of ABS to Functional Reactive Programming on a technical level, which would be of most interest to functional programmers.

Object-oriented programming and simulation have a long history together as the former one emereged out of Simula 67 \cite{dahl_birth_2002}, which was created for simulation purposes. Simula 67 already supported Discrete Event Simulation and was highly influential for today's object-oriented languages. Although the language was important and influential, in our research we look into different approaches, orthogonal to the existing object-oriented concepts.

Lustre is a formally defined, declarative and synchronous dataflow programming language for programming reactive systems \cite{halbwachs_synchronous_1991}. While it has solved some issues related to implementing ABS in Haskell, it still lacks a few important features necessary for ABS. There seems to be no way of implementing an environment in Lustre as it is done in Chapters \ref{ch:timedriven} and \ref{ch:eventdriven}. Also, the language does not seem to come with stochastic functions, which are the very building blocks of ABS. Finally, Lustre only supports static networks, which is clearly a drawback in ABS, where agents can be created and terminated dynamically during simulation.

In \cite{botta_time_2010}, the authors discuss the problem of advancing time in message-driven agent-based socio-economic models. They formulate pure functional definitions for agents and their interactions through messages.

The authors of \cite{botta_functional_2011} use functional programming as a specification for an agent-based model of exchange markets, but leave the implementation for further research where they claim that it requires dependent types.

In his talk \cite{sweeney_next_2006}, Tim Sweeney, CTO of Epic Games, discussed programming languages in the development of game engines and scripting of game logic. Although the fields of games and ABS seem to be very different, Gregory \cite{gregory_game_2018} defines computer games as \textit{"[..] soft real-time interactive agent-based computer simulations"} (p. 9). Indeed, they have striking similarities. Both are simulations which perform numerical computations and update objects in a loop either concurrently or sequentially. In games these objects are called \textit{game objects} and in ABS they are called \textit{agents}, but they are conceptually the same thing.  Sweeney reports that reliability suffers from dynamic failure in languages like C++. For example, random memory overwrites, memory leaks, out-of-bounds access of arrays, dereferencing null pointers, integer overflow, and accessing uninitialized variables all have a negative affect on reliability. He reports that 50\% of all bugs in the game engine middleware \textit{Unreal} can be traced back to such problems and presents dependent types as a potential rescue to those problems. The two main points Sweeney made were that dependent types could solve most of the run-time failures and that parallelism is the future for performance improvement in games. Further, he distinguishes between pure functional algorithms, which can be parallelised easily in a pure functional language, and updating game objects concurrently using Software Transactional Memory.