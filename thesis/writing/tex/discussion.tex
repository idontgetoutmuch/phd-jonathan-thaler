\chapter{Discussion}
\label{ch:discussion}
% starting point
This thesis started out by challenging the established views that \textit{"[..] object-oriented programming to be a particularly natural development environment for Sugarscape specifically and artificial societies generally [..]"} \cite{epstein_growing_1996} (p. 179) and that \textit{agents map naturally to objects} \cite{north_managing_2007}. As an alternative, a radical different approach to implementing ABS was proposed, using the pure functional programming paradigm. As language of choice, Haskell was motivated due to its  pure functional features, matureness and increasing relevance to real-world applications. 

% motivation
The conjecture was that by using Haskell, one can directly transfer the promises made by pure functional programming to ABS as well, directly gaining a few highly important benefits.  The relevance of each of these promises to ABS was already pointed out in the respective chapters and it is quite obvious that these benefits would clearly be of immense value in ABS. The common baseline is that all those benefits support making implementations of ABS which are more likely to be correct, something of fundamental value in simulation.

\begin{enumerate}
	\item The static strong type system allows to remove a substantial number and classes of bugs at run-time and if one programs careful one can even guarantee that no bugs as in crashes or exceptions will occur at run-time. This is particularly the case for purely computational problems, without IO \footnote{Obviously IO is involved in all ABS, otherwise the results are not observable. By purely computational, we identify lack of IO in the agents, as fundamental part of the model, other than visualisation and exporting to an output file.}, as ABS almost always are. 
	
	\item Explicit handling and control of side effects delivers even more static guarantees at compile time and allows to deal with deterministic side effects (random-number streams, read-/write only contexts, state) in a referential transparent way. In combination with strong static typing this allows to reduce logical bugs (subject to the domain of the problem) by dramatically reducing available, valid operations on data - after all stateful applications are a fact, the challenge is how to deal with state. As ABS is an inherently stateful problem due to agents and the environment, this should  theincrease correctness of an ABS implementation as well. Further, this should allow to produce an implementation which is guaranteed to reproducible (runs with same initial conditions \textit{will} result in same dynamics) at compile time.
	
	\item Parallel and concurrent programming is claimed to be lot easier, less painful and less error prone in functional programming in general and in Haskell in particular due to immutable data and the explicit handling of side effects. The concept of Software Transactional Memory, which allows to express a problem as a data-flow problem is highly promising. Besides, data-parallel programming promises to speed up code without the need for changing any of the logic or types. This seemed to offer a straightforward way of speeding up ABS implementations either through data-parallelism or concurrency. This has always been quite difficult to achieve in traditional object-oriented ABS and pure functional programming seems to offer a solution.
	
	\item The data-centric declarative style, referential transparency and immutability of data makes testing substantially easier due to composability: functions can be easily tested in isolation from each other even if they involve side effects. This opens the door for (randomised) property-based testing which intuitively seemed to be a perfect match to test ABS implementations which are (almost) always stochastic in nature.
\end{enumerate}

TODO: add a "look back" part, where the whole thesis is re-visited a bit more in detail
The central question which needed to be answered first was \textit{how} ABS could be done pure functionally, as there didn't exist any research which offered a systematic solution to that problem. More specifically, it was unclear how to represent agents, how to express agent identity, local agents state, changing behaviour and interactions amongst agents and the environment. After all, this is straightforward in object-oriented programming due to method calls and mutable shared state encapsulated in objects.
% the answer
The solution was to use arrowized FRP both in the pure implementation of Yampa and the monadic version as in the library Dunai. Building on top of them allowed us to implement pro-activity of agents, encapsulation of local agent state, an environment as shared mutable state and synchronous agent-interactions based on an event-driven approach. The central concept behind these approaches are Signal Functions (SF), generalised in Dunai to Monadic Stream Functions (MSF), which are implemented using closures and continuations, fundamental building blocks and concepts of pure functional programming. 


We argue that the thesis has successfully demonstrated in the respective chapters that all promises successfully transfer to pure functional ABS implementations in a reasonable, robust and maintainable way. Below we discuss respective points more in-depth and give a holistic reflection and critique of our pure functional approach in general.

\input{./tex/discussion/benefits.tex}

\input{./tex/discussion/drawbacks.tex}

\input{./tex/discussion/gintisCase.tex}

\input{./tex/discussion/generalising.tex}

\input{./tex/discussion/whenNot.tex}

\input{./tex/discussion/objects.tex}