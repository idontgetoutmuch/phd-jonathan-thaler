\chapter{Methodology}
\label{ch:methodology}
% PEER: Research Methodology (or Research Design) should be a separate chapter. It should include aim / objectives. It describes how you are planning to do the research.

%- Methodology is the justification for using a particular research method.
%- make clear what our method is (Method is simply a research tool, a component of research â€“ say for example, a qualitative method such as interviews) and then justify it => this is then the methodology 
%- discussion of methodology is missing: what is the scientific approach we used in our thesis to address the aims and answer hypotheses? Basically we perform use-cases and discuss them

In this section we briefly motivate and justify our methods, to point out the scientific approach used in this thesis to address the aims and answer hypotheses put forward in Chapter \ref{ch:motivation}.

Fundamentally, the method we use is developing concepts step-by-step using the two well-known agent-based models SIR, introduced in Chapter \ref{sec:sir_model} and Sugarscape, introduced in Chapter \ref{sec:sugarscape}. We put our approach into the broader context of how to implement ABS from a programming language agnostic view, discussed in Chapter \ref{ch:impl_abs}, which serve as underlying assumptions and a general direction to follow.

The first part of our method is dedicated to answering the question of how to implement ABS in a pure functional way, following a time-driven approach in Chapter \ref{ch:timedriven} and an event-driven approach in Chapter \ref{ch:eventdriven}. The reason for including these two techniques is that both are equally important in ABS. Additionally, the concepts of event-driven ABS build on the ones developed in the preceding time-driven approach.

Generally, in both approaches, the aim is to develop a robust, maintainable and extensible implementation of the use-case models through which we develop concepts which can be adopted to ABS in general. The overall goal is a clear representation of agents with their local (immutable) state, a way for the agents to interact with an (active) environment and one-directional and synchronous interactions between agents. 

In the process of researching the pure functional event-driven approach to ABS, we also undertook a full and validated implementation of the Sugarscape model. This in itself, together with the concepts developed, is already sufficient proof that using a pure functional language to implement non-trivial ABS models is possible in a robust and maintainable way.

%It is quite important to state this clearly as we could follow a rather completely data-driven approach, which would have been very easy in pure functional programming: represent all agents and the simulation state as a big data-structure which is passed in and out pure functions (thus read/write). Indeed it would work but we would probably end up in a difficult to understand data-flow (everything is read/write) and what is worse: we don't arrive at very general solutions as we would not abstract out concepts, existing in ABS already which could then be transferred easily. Note that a more data-driven approach has indeed its value, depending on the model! In Chapter \ref{ch:gintis_case} we briefly introduce the field of ACE, where agents are almost always completely represented by data and very simple behaviour and do not interact in a complex way as in Sugarscape. Examples are ZI traders or bilateral traders which are all simply represented by data and interact with each other quite indirectly through a trading and bartering process.

The second part of our method is dedicated to showing the benefits of using the previously developed pure functional approach to ABS. It is split into two parts, where in the first we investigate the hypothesis that pure functional programming makes it easy to apply parallel computation using parallelism and concurrency to ABS. The second part answers another central hypothesis, namely that randomised property-based testing is a good match to test stochastic ABS implementations. In both parts we apply the concepts in questions directly to the implementations developed in the previous part. Then we look at the resulting code, performance and implications to judge whether the outcome has the expected benefit or not as stated in the hypotheses.

Generally, all concepts we derive are driven by the hypotheses and aims from the Introduction. We continuously refer back to these concepts, especially in the respective discussions and the final conclusion and discussion chapters. By taking this methodical approach, we are able to qualitatively assess whether the thesis has achieved the initial aims and answered the hypotheses in a satisfactory way.