\chapter{The equilibrium-totality correspondence}
\label{app:equilibrium_totality}

In the property-tests of Chapter \ref{sec:prop_invariants_dynamics} and \ref{sec:timedriven_specification} we limited the time an individual simulation is run to a random range between 0 and 50. In this context, the decision to do so was for practical reasons to guarantee termination as both the event- and time-driven implementations would run forever if no time- and/or event-limit is specified \footnote{Note that the event-driven implementation would terminate if the event-queue is empty but in the case of the SIR this will never be the case due to susceptible agents keep scheduling \textit{MakeContact}, resulting in an infinite stream of events.}.

However, restricting the simulation to a time- and/or event-limit is not necessary in a correct SIR implementation because it  \textit{will} reach an equilibrium \textit{within finite time} at which point the simulation can be terminated. This is the case as soon as there are no more infected agents: intuitively this is clear because only infected agents can lead to infections of susceptible agents. They make the transition to recovered after having gone through the infection phase and will never go back to susceptible, thus also the pool of susceptible agents is finite. The infected agents themselves \textit{will} recover within finite time. Thus we can conclude that a correct implementation of the SIR model must enter an equilibrium, a steady state in finite time.

Using this informal reasoning, we change the property-test from Chapter \ref{sec:prop_invariants_dynamics} to encode this property implicitly.

\begin{HaskellCode}
prop_sir_invariants :: Positive Int    -- ^ beta, contact rate
                    -> Property        -- ^ gamma, infectivity in range (0,1)
                    -> Positive Double -- ^ delta, illness duration
                    -> [SIRState]      -- ^ population
                    -> Property
prop_sir_invariants 
    (Positive cor) (P inf) (Positive ild) as  = property (do
  -- CHANGED: run the SIR simulation with UNRESTRICTED time
  ret <- genSimulationSIR ss cor inf ild 0
  -- CHANGED: take data as long as not in equilibrium
  let ret' = takeWhile ((>0).snd3.snd) ret
  -- check invariants and return result
  return (sirInvariants (length as) ret')
\end{HaskellCode}

Unfortunately this code is dangerous: generally, we cannot distinguish between a very long or infinitely running simulation. It might be the case that there is a bug in our implementation, violating the property that all infected agents eventually recover, in which case \textit{takeWhile} might run forever. This means that we cannot write a property-test, which could tell us whether this property holds or not for both our time- and event-driven implementations - it is in general not computable. Obviously this is nothing new and was established in the 1930s through the work of Turing \cite{turing_computable_1937}. The question is now: what can we do about it?

One solution is to abandon the power of general recursion and Turing-completeness and switch to a different kind of pure functional programming language in which programs can be checked for totality by the compiler. These languages have a different kind of type system, called dependent types. Generally, dependent types add the following concepts to pure functional programming:

\begin{enumerate}
	\item Totality and termination - A total function terminates with a well-typed result or produces a non-empty finite prefix of a well-typed infinite result in finite time \cite{brady_type-driven_2017}. In dependently typed languages, which abandon Turing completeness, this can be checked at compile time under certain circumstances.
	
	\item Types are first-class citizen - In dependently typed languages, types can depend on any \textit{values}, and can be \textit{computed} at compile time, which makes them first-class citizen. This allows to compute the return type of a function depending on its input values. Note that this requires totality, otherwise type-checking would be not decidable and potentially non-terminating.
	
	\item Types as \textit{constructive} proofs - Because types can depend on any values and can be computed at compile time, they can be used as constructive proofs, which must terminate. This means a well-typed program, which in itself is a proof, is always terminating, which in turn means that it must consist out of total functions.
\end{enumerate}

Thus it should become clear that there exists a strong relation between property-based tests and dependent types: in property-based testing we express specifications / properties / laws in code and test their invariance at run-time by random sampling the space. In dependent-types it is possible to express such properties already statically in types. So far no research using dependent types in agent-based simulation exists at all. We hypothesise that dependent types allow to push the correctness of ABS to a new, unprecedented level by narrowing the gap between model specification and implementation even further.

%Idris is Turing-complete but is able to check the totality of a function under some circumstances but not in general as it would imply that it can solve the halting problem.

\section{Constructivism}
The main theoretical and philosophical foundations of dependent types are Martin-L\"of intuitionistic type theory. The view of dependently typed programs to be proofs is rooted in a deep philosophical discussion on the foundations of mathematics, which evolve around the existence of mathematical objects, with two conflicting positions known as classic vs. constructive \footnote{We follow the excellent introduction on constructive mathematics \cite{thompson_type_1991}, chapter 3.}. In general, the constructive position has been identified with realism and empirical computational content, where the classical one with idealism and pragmatism.

In the classical view, the position is that to prove $\exists x. P(x)$ it is sufficient to prove that $\forall x. \neg P(x)$ leads to a contradiction. The constructive view would claim that only the contradiction is established but that a proof of existence has to supply an evidence of an $x$ and show that $P(x)$ is provable. In the end this boils down whether to use proof by contradiction or not, which is sanctioned by the law of the excluded middle which says that $A \lor \neg A$ must hold. The classic position accepts that it does and such proofs of existential statements as above, which follow directly out of the law of the excluded middle, abound in mathematics (Polynomial of degree n has n complex roots; continuous functions which change sign over a compact real interval have a zero in that interval,...). The constructive view rejects the law of the excluded middle and thus the position that every statement is seen as true or false, independently of any evidence either way. \cite{thompson_type_1991} (p. 61): \textit{The constructive view of logic concentrates on what it means to prove or to demonstrate convincingly the validity of a statement, rather than concentrating on the abstract truth conditions which constitute the semantic foundation of classical logic}.

To prove a conjunction $A \land B$ we need prove both $A$ and $B$, to prove $A \lor B$ we need to prove one of $A, B$ and know which we have proved. This shows that the law of the excluded middle can not hold in a constructive approach because we have no means of going from a proof to its negation. Implication $A \Rightarrow B$ in constructive position is a transformation of a proof $A$ into a proof $B$: it is a function which transforms proofs of $A$ into proofs of $B$. The constructive approach also forces us to rethink negation, which is now an implication from some proof to an absurd proposition (bottom): $A \Rightarrow \perp$. Thus a negated formula has no computational context and the classical tautology $\neg \neg A \Rightarrow A$ is then obviously no longer valid.  Constructively solving this would require us to be able to effectively compute / decide whether a proposition is true or false - which amounts to solving the halting problem, which is not possible in general.

A very important concept in constructivism is that of finitary representation / description. Objects which are infinite e.g. infinite sets as in classic mathematics, fail to have computational representation, they are not computable. This leads to a fundamental tenet in constructive mathematics: \cite{thompson_type_1991} (p. 62): \textit{Every object in constructive mathematics is either finite [..] or has a finitary description}

Concluding, we can say that constructive mathematics is based on principles quite different from classical mathematics, with the idealistic aspects of the latter replaced by a finitary system with computational content. Objects like functions are given by rules, and the validity of an assertion is guaranteed by a proof from which we can extract relevant computational information, rather than on idealist semantic principles. 

This short section only touched on the very basics and omitted dependently typed programming concepts altogether, For an in-depth introduction to dependent types and programming languages with dependent type systems we refer to: \cite{brady_type-driven_2017, pierce_programming_2018, program_homotopy_2013, stump_verified_2016, thompson_type_1991}.

%All this is directly reflected in dependently typed programs as we introduced above: functions need to be total (finitary) and produce proofs like in \textit{checkEqNat} which allows the compiler to extract additional relevant computational information. Also the way we described the (infinite) natural numbers was in an finitary way. In the case of decidable equality, the case where it is not equal, we need to provide an actual proof of contradiction, with the type of Void which is Idris representation of $\perp$. 

\section{Dependent types in ABS}
\label{sec:dep_vav_deptypes}
ABS as \textit{constructive and exploratory} science \cite{epstein_chapter_2006, epstein_generative_2012}, follows the Popperian approach of falsification: the aim is to construct a model which explains a real-world (empirical) phenomenon. If validation shows that the generated dynamics match the ones of the real-world sufficiently enough, we can say that we have found \textit{a} hypothesis, the model, with emergent properties explaining the real-world phenomenon sufficiently enough. %This is not a proof but only one possible explanation which holds for now and might be falsified in the future.
Epstein describes this process with \cite{epstein_chapter_2006}: \textit{"If you can't grow it, you can't explain it"}. Thus, an agent-based model and the simulated dynamics can be understood as a constructive proof which explain a real-world phenomenon sufficiently enough. Although Epstein certainly was not talking about a constructive proof in any mathematical sense in this context (he was using the word \textit{generative}), dependent types \textit{might} be a perfect match and correspondence between the constructive nature of ABS and programs as proofs.

When we talk about dependently typed programs to be proofs, then we also must attribute the same to dependently typed ABS, which are then constructive proofs as well. The question is then: a constructive proof of what? It is not entirely clear \textit{what we are proving} when we are constructing dependently typed ABS. Probably the answer might be that a dependently typed ABS is then indeed a constructive proof in a mathematical sense, explaining a real-world phenomenon sufficiently well - we have closed the gap between a rather informal constructivism as mentioned above when citing Epstein who certainly didn't mean it in a constructive mathematical sense, and a formal constructivism, made possible by the use of dependent types.

\medskip

Models like Sugarscape (Chapter \ref{sec:sugarscape}) are exploratory in nature and don't have a formal ground truth where one could derive equilibria or dynamics from and validate with. In such models the researchers work with informal hypotheses which they express before running the model and then compare them informally against the resulting dynamics or more formally with property-based tests (see Appendix \ref{app:validating_sugarscape}). It would be of interest if dependent types could be made of use in encoding hypotheses on a more constructive and formal level directly into the implementation code. So far we have no idea how this could be done but it might be a very interesting application as it allows for a more formal and automatic testable approach to hypothesis checking.

Often, Agent-Based Models define their agents in terms of state-machines. It is easy to make wrong state-transitions e.g. in the SIR model when an infected agent should recover, the compiler does not prevent one from making the transition back to susceptible. Using dependent types it might be possible to encode invariants and state-machines on the type level which can prevent such invalid transitions already at compile time. This would be a huge benefit for ABS because of the popularity of state-machines in ABS.

State-machines often have timed transitions e.g. in the SIR model, an infected agent recovers after a given time. Nothing prevents us from introducing a bug and \textit{never} doing the transition at all. With dependent types we might be able to encode the passing of time in the types and guarantee on a type level that an infected agent has to recover after a finite number of time steps. Also, it would be interesting to use dependent types to encode the strong monotonic increasing flow of time.
	
In more sophisticated models agents interact in more complex ways with each other e.g. through message exchange using agent ids to identify target agents. The existence of an agent is not guaranteed and depends on the simulation time because agents can be created or terminated at any point during simulation. Dependent types could be used to implement agent ids as a proof that an agent with the given id exists \textit{at the current time step}. This also implies that such a proof cannot be used in the future, which is prevented by the type system as it is not safe to assume that the agent will still exist in the next step. %So it is a proof of the existence of an agent: holds always only for the current time-step or for all time, depending on the model. e.g. in the SIR model no agents are removed from / added to the system thus a proof holds for all time. 

%In case of an SD this will take forever to reach 0 due to the dynamics of the equations and floating point arithmetic is another difficulty. On the other hand, due to ABS discrete nature this is not an issue anymore: agents are discrete and as soon as we hit 0 infected agents - which, due to Integer representation, can be exact - an equilibrium is reached.

%Note that there exists a SIR+S model, which adds a cycle back from Recovered to Susceptible - if we add this cycle in our total implementation, this should make it immediately non-total as an important criteria for totality gets violated: the source of susceptible is not finite anymore and we might run in non-stationary cycles like in a prey-predator model with Lotka-Volterra equations.

Coming back to the original problem of the totality of the SIR model, dependent types in general and Idris' ability for totality- and termination-checking in particular, should theoretically allow us to prove that an agent-based SIR implementation terminates after finite time. If an implementation of the agent-based SIR model in Idris is total it is a formal proof by construction. Such an implementation should not run for a limited virtual time but run unrestricted of the time and the simulation should terminate as soon as there are no more infected agents, returning the termination time as an output. Also if we find a total implementation of the SIR model and extend it to the SIR+S model, which adds a cycle from recovered back to susceptible, then the simulation should become again as the pool of susceptible agents becomes potentially infinite.

The HOTT book \cite{program_homotopy_2013} states that lists, trees,... are inductive types/inductively defined structures where each of them is characterized by a corresponding \textit{induction principle}. Thus, for a constructive proof of the totality of the agent-based SIR model we need to find the induction principle of it. This leaves us with the question of what the inductive, defining structure of the agent-based SIR model is? Is it a tree where a path through the tree is one way through the simulation or is it something else? It seems that such a tree would grow and then shrink again e.g. infected agents. Can we then apply this further to (agent-based) simulation in general?

A central question in tackling this is whether to follow a model- or an agent-centric approach. The former one looks at the model and its specifications as a whole and encodes them e.g. one tries to directly find a total implementation of an agent-based model. The latter one looks only at the agent level and encodes that as dependently typed as possible and hopes that model guarantees emerge on a meta-level - put otherwise: does the totality of an implementation emerge when we follow an agent-centric approach? 

%Dependent types allow to encode specifications on an unprecedented level, narrowing the gap between specification and implementation - ideally the code becomes the specification, making it correct-by-construction. The question is ultimately how far we can formulate model specifications in types - how far we can close the gap in the domain of ABS. Unless we cannot close that gap completely, to arrive at a sufficiently confidence in correctness, we still need to test all properties at run-time which we cannot encode at compile-time in types.

%Nonetheless, dependent types should allow to substantially reduce the amount of testing which is of immense benefit when testing is costly. Especially in simulations, testing and validating a simulation can often take many hours - thus guaranteeing properties and correctness already at compile time can reduce that bottleneck substantially by reducing the number of test-runs to make.

%Ultimately this leads to a very different development process than in the established object-oriented approaches, which follow a test-driven process. There one defines the necessary interface of an object with empty implementations for a given use-case first, then writes tests which cover all possible cases for the given use-case. Obviously all tests should fail because the functionality behind it was not implemented yet. Then one starts to implement the functionality behind it  step-by-step until no test-case fails. This means that one runs all tests repeatedly to both check if the test-case one is working on is not failing anymore and to make sure that old test-cases are not broken by new code. The resulting software is then trusted to be correct because no counter examples through test hypotheses, could be found. The problem is: we could forget / not think of cases, which is the easier the more complex the software becomes (and simulations are quite complex beasts). Thus in the end this is a deductive approach.

%With pure functional programming and dependent types the process is now mostly constructive, type-driven (see \cite{brady_type-driven_2017}). In that approach one defines types first and is then guided by these types and the compiler in an interactive fashion towards a correct implementation, ensured at compile-time. As already noted, the ABS methodology is constructive in nature but the established object-oriented test-driven implementation approach not as much, creating an impedance mismatch. We expect that a type-driven approach using dependent types reduces that mismatch by a substantial amount.

%Note that \textit{validation} is a different matter here: independent of our implementation approach we still need to validate the simulation against the real-world / ground-truth. This obviously requires to run the full simulation which could take up hours in either programming paradigm, making them absolutely equal in this respect. Also the comparison of the output to the real-world / ground-truth is completely independent to the paradigm. The fundamental difference happens in case of changes made to the code during validation: in case of the established test-driven object-oriented approach for every minor change one (should) re-run all tests, which could take up a substantial amount of additional time. Using a constructive, type-driven approach this is dramatically reduced and can often be completely omitted because the correctness of the change can be either guaranteed in the type or by informally reasoning about the code.

%TODO: not sure where to put this

%When we implement our simulation things change a bit as we add another layer: the conceptual model, describing the phenomenon, which is an abstraction of reality. This description can be of many forms but can be regarded on a line between completely formal (economic models) to informal (sociology) but the implementation will follow that description. The fundamental difference here is that in this case we want our implementation to be exactly the same as the conceptual model. Contrary to the real-world, where it is not possible to find a \textit{true} model (as was argued by Popper), on this level we actually can construct an implementation which matches the conceptual model exactly because we have a description of the conceptual model. In the end we transform the conceptual model description in code, which is itself a formal description. In this translation process (speak: implementation / programming), one can make an endless number of mistakes. Generally we can distinguish between two classes of mistakes: 
%1) conceptual mistakes - wrong translation of the model specifications into code due to various reasons e.g. imprecise description, human error. The more precise an unambiguous a model description is, the less probable conceptual mistakes will be.
%2) internal mistakes - normal programming mistakes e.g. access of arrays out of bounds, ... also using correlated Random Number generators.
%%
%Level 0: Real-World phenomenon
%Level 1: Conceptual model of the real-world phenomenon
%Level 2: Implementation of the conceptual model
%%
%Note that we must speak of falsification and constructiveness on two different levels:
%- validation level: do the results of the conceptual model match the real-world phenomenon? the conceptual model is the hypothesis which says that its mechanics are sufficient to generate / construct the real-world phenomenon. At this level we are not interested in the implementation level anymore - the implemented model \textit{is} (seen as) the conceptual model, and one only compares its output to the real-world. If the dynamics match, then we got a valid hypothesis which works for now. If the dynamics do NOT match, then the hypothesis (the model) is falsified and one needs to adjust / change the hypothesis (model). The validation will happen by tests, there is no other way, we have no formal specification of the real-world, we can only observe empirically the phenomena, so we run tests which try to falsify the outputs of the model: assuming it will generate phenomena of the real-world and test if it does.
%- implementation \& verficiation level: in this step we are matching the code to the conceptual model. Here we are not only restricted to a test-driven approach because we have a more or less formal description of the conceptual model which we directly encode in our programming language. If the language allows to express model specifications already at compile-time then this means that the implementation narrows the gap between model specification and implementation which means it does not need to be tested at run-time because it is guaranteed for all inputs for all time. 
%
%

%TODO: \url{https://stackoverflow.com/questions/19642921/assisting-agdas-termination-checker/39591118}

%The authors of \cite{ionescu_dependently-typed_2012} discuss how to use dependent types to specify fundamental theorems of economics, unfortunately they are not computable and thus not constructive, thus leaving it more to a theoretical, specification side.
%Ionesus talk on dependently typed programming in scientific computing
%https://www.pik-potsdam.de/members/ionescu/cezar-ifl2012-slides.pdf
%Ionescus talk on Increasingly Correct Scientific Computing
%%https://www.cicm-conference.org/2012/slides/CezarIonescu.pdf
%Ionescus talk on Economic Equilibria in Type Theory
%https://www.pik-potsdam.de/members/ionescu/cezar-types11-slides.pdf
%Ionescus talk on Dependently-Typed Programming in Economic Modelling
%https://www.pik-potsdam.de/members/ionescu/ee-tt.pdf

\section{Discussion}
In this appendix we briefly discussed the \textit{correspondence between the equilibrium of a simulation and the totality of its implementation}. We have shown by informal reasoning that the SIR implementation will reach an equilibrium within finite time, thus it is not necessary to limit the simulation to a finite number of steps but terminate it when this equilibrium is reached. Unfortunately, using property-based tests we cannot prove that an implementation actually will terminate, which is in general not computable. However, when abandoning Turing completeness, by using pure functional programming languages with dependent types this actually becomes possible where one can write \textit{total} programs, which are guaranteed to terminate, checked by the compiler.

We briefly introduced the concept of dependent types, their underlying philosophical foundations and discussed their potential use in ABS. As language of choice, for conducting research on dependent types in ABS, we propose Idris \cite{brady_idris_2013} as it is very close to Haskell with focus on real-world application and running programs as opposed to other languages with dependent types e.g. Agda and Coq which serve primarily as proof assistants.

Concluding, we see this thesis on pure functional programming without dependent types as a first step towards a more structural understanding of ABS implementations, where dependent types should allow us to develop this even further. A full treatment of dependent types in ABS are beyond the scope of this thesis and would justify a thesis in itself, thus we leave it for further research.