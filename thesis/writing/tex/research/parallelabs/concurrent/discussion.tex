\section{Discussion}
In this chapter we have shown how to apply concurrency to monadic ABS to gain a substantially speedup. We developed a novel approach, using STM, which to our best knowledge has not been discussed systematically in the context of ABS so far. This new approach outperforms a traditional lock-based implementation running in the \texttt{IO} Monad \textit{and} guarantees that the differences between runs with same initial conditions stem from the non-determinism of STM, \textit{but nothing else}. The latter point can't be guaranteed by the lock-based approach as it runs in the \texttt{IO} Monad, which allows literally anything from reading from a file, to launching a missile. Additionally, with STM, concurrency becomes more of a control-flow oriented concern. So, using STM allows us to treat the concurrent problem within an agent as a data-flow oriented one, without cluttering the model code with operational details of concurrency. This gives strong evidence that STM should be favoured over lock-based approaches in general for implementing concurrent ABS in Haskell.

Also, STM primitives map nicely to ABS concepts. When having a shared environment, it is natural to use either \texttt{TVar} or \texttt{TArray}, depending on the environment's nature. What is more, the \texttt{TChan} primitive exists, which can be seen as a persistent message box for agents, underlining the message-oriented approach found in many agent-based models \cite{agha_actors:_1986, wooldridge_introduction_2009}. Moreover, \texttt{TChan} offers a broadcast transactional channel, which supports broadcasting to listeners and maps nicely to a proactive environment or a central auctioneer upon which agents need to synchronize. The benefits of these natural mappings are that using STM takes a big portion of the burden from the modeller, as one can think in STM primitives instead of low level locks and concurrent operational details. 

We assumed that concurrent execution has no qualitative influence on the dynamics. Although repeated runs with same initial conditions might lead to different results due to non-determinism, we assumed that the dynamics still follow the same distribution as the one from the sequential implementation. To verify this, we can make use the techniques of property-based testing as shown in Chapters \ref{ch:agentspec} and \ref{ch:sir_invariants} of this thesis, but we leave it for further research.

The next step would be to add synchronous agent interactions as they occur in the Sugarscape model and use cases of mating, trading and lending. We have started to do work on this already and could implement one-directional agent interactions as well, as they occur in the disease transmission, payback of loans and notification of inheritance upon the death of a parent agent. We use the \texttt{TQueue} primitive to emulate the behaviour of mailboxes through which agents can post events to each other. The result is promising, but needs more investigation. We have also started looking into synchronous agent interactions using STM which is a lot trickier and is very susceptible to deadlocks, which are still possible in STM! We have yet to prove how to implement reliable synchronous agent interactions without deadlocks in STM. It might be very well the case that a truly concurrent approach is doomed due to the following \cite{marlow_parallel_2013} (Chapter 10. Software Transactional Memory, "What Can We Not Do with STM?"): \textit{"In general, the class of operations that STM cannot express are those that involve multi-way communication between threads. The simplest example is a synchronous channel, in which both the reader and the writer must be present simultaneously for the operation to go ahead. We cannot implement this in STM, at least compositionally [..]: the operations need to block and have a visible effect — advertise that there is a blocked thread — simultaneously."}. 

Furthermore, STM is not fair because \textit{all} threads, which block on a transactional primitive, have to be woken up. Thus, a FIFO guarantee cannot be given. We hypothesise that for most models, where the STM approach is applicable, this has no qualitative influence on the dynamics as agents are assumed to act conceptually at the same time and no fairness is needed. We leave the test of this hypothesis for future research.

Depending on the nature of the transactions, retries could become a bottle neck, resulting in a live lock in extreme cases. The central problem of STM is to keep the retries low, which is directly influenced by the read/writes on the STM primitives. By choosing more fine-grained and suitable data structures such as using a \texttt{TArray} instead of an indexed array within a \texttt{TVar}, one can reduce retries and increase performance significantly and avoid the problem of live locks as we have shown.

We did not look into applying distributed computation to our approach. One direction to follow would be to use the \textit{Cloud Haskell} library, which is very similar to the concurrency model in Erlang. We leave this for further research as it is beyond the scope of this thesis.

%further research: the approach of executing dependent functions in different layers \url{https://academic.oup.com/bib/article/11/3/334/225993} might allow even further speed-up, also the same paper: "Mobile discrete simulations consisting of agents navigating a grid like environment are less well-suited to a GPU implementation as they are traditionally implemented in sequential environments. Parallel implementations of discrete mobile systems on the GPU must explicitly handle collision conditions which result from agents simultaneously moving to the same discrete location."