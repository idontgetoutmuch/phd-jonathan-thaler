\subsection{Sugarscape}
As already shown in the case of the monadic SIR implementation from the previous section, running agents in parallel within a monadic context does not bring us any speedup. On the contrary, we get penalised with a substantial performance loss due to the overhead incurred by adding parallelism. Furthermore, running the agents in the \texttt{Par} Monad alone also incurs a substantial overhead. Consequently, these roads are dead ends for our Sugarscape implementation as well.

However, there is one direction for parallelism left that we did not explore so far: the behaviour of the environment. It consists of a pure computation, using maps and folds over an \texttt{IntMap}. It might look like we are out of luck as it seem that we cannot parallelise the updating of an \texttt{IntMap} \footnote{In general, folds can be parallelized only when the operation being folded is associative, where the linear fold can be turned into a tree. Although applicable, we don't follow that approach here and leave it for further research}. Nevertheless, the work of \cite{marlow_parallel_2013} shows that it is indeed possible through a combination of the \texttt{Par} Monad and the Applicative type class. The \texttt{IntMap} provides the function \texttt{traverseWithKey :: Applicative t $\Rightarrow$ (Key $\rightarrow$ a $\rightarrow$ t b) $\rightarrow$ IntMap a $\rightarrow$ t (IntMap b)}. We can use this function whenever we need to traverse the whole \texttt{IntMap} to update every cell in the list. The obvious use case for this is the regrowing of resources (sugar and spice) in every step.

Unfortunately, measurements quickly reveal that this parallelism makes the performance worse than the sequential example. It seems that the regrowing of resources is not computation heavy and the parallelism incurs more overhead than the speedup it provides.

Another thing we can parallelise is the computation of the pollution diffusion. This computation uses \texttt{map} to compute the new pollution level of each cell. \texttt{'withStrategy (parList rseq)'} is then applied to the list of all cells, but the parallelism is too fine-grained and we get worse performance than without it.

Thus, we end up with the same conclusion as with the monadic SIR implementations. There is practically no opportunity to parallelise the implementation. We refer to the concurrency chapter where we show how to achieve substantial performance improvements when we employ concurrency instead of parallelism.