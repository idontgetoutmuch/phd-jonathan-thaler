\chapter{Concurrency in ABS}
\label{ch:concurrent_abs}
In an ideal world, we would like to solve all our problems using parallelism but unfortunately, it can't be applied to all parallel problems and ABS is no exception. As soon as there are data dependencies, like we have them in the Sugarscape model in the form of the mutable environment and synchronous agent interactions, and to a lesser extent in the monadic SIR with the \texttt{Rand} Monad, we cannot avoid concurrency. More general, this is due to the fact that agents are executed within a monadic context, from which the  sequencing of effectful computations immediately follows, the very meaning of the Monad abstraction. Indeed, we have shown both by argument and measurement in the previous chapter the very fact that parallelism is simply not applicable to monadic execution of agents due to sequencing of effects, which renders all attempts of running monadic agents in parallel void. In this chapter we discuss the use of concurrency to run agents with a monadic context in parallel, which is the only way we can execute monadic agents at the same time.

\medskip

Traditional approaches to concurrency follow a lock-based approach, where sections which access shared data are synchronised through synchronisation primitives like mutexes, semaphores or monitors. The lock-based path is a well trodden one, with most problems and benefits well established. In this chapter we follow a different path and look into using Software Transactional Memory (STM) for implementing concurrent ABS, which promises to overcome the problems of lock-based approaches. Although STM exists in other languages as well, Haskell was one of the first to natively build it into its core, thus it is a natural choice to follow that direction when already investigating pure functional ABS.

The idea of applying transactional memory to simulation was already explored in the work \cite{hay_experiments_2015}, where the authors looked into how to apply Intelâ€™s \textit{hardware} transactional memory to simulations in the context of a Time Warp Parallel Discrete Event Simulation (PDES). The results showed that their approach generally outperformed traditional locking mechanisms. Although PDES is a different problem than ABS, they are related as both deal with events (in case of an event-driven ABS) and PDES has been successfully adopted to simulate parallel ABS \cite{suryanarayanan_pdes-mas_2013}.

The paper \cite{discolo_lock_2006} gives a good indication how difficult and complex constructing a correct concurrent program is and shows how much easier, concise and less error prone an STM implementation is over traditional locking with mutexes and semaphores. More important, it shows that STM consistently outperforms the lock-based implementations. We follow this work and compare the performance of lock-based and STM implementations and hypothesise that the reduced complexity and increased performance will be directly applicable to ABS as well.

We present two case studies using the already introduced SIR (Chapter \ref{sec:sir_model}) and Sugarscape (Chapter \ref{sec:sugarscape}) models. We compare the performance of lock-based and STM implementations in each case where we investigate both the scaling performance under increasing number of CPUs and agents. We show that the STM implementations consistently outperform the lock-based ones and scale much better to increasing number of CPUs both on local machines and on Amazon Cloud Services.

Unfortunately, as soon as we employ concurrency, we lose all static guarantees about reproducibility and the use of STM is no exception. Still, STM has the unique benefit that it can guarantee the lack of persistent side effects at compile time, allowing unproblematic retries of transactions, something of fundamental importance in STM as will be described below. This implies also another \textit{very} compelling advantage of STM over unrestricted lock-based approaches. By using STM, we can reduce the side effects allowed substantially and guarantee at compile time, that the differences between runs of same initial conditions will only stem from the fact that we run the simulation concurrently, \textit{and from nothing else}. All this makes the use of STM very compelling and to our best knowledge we are the very first to investigate the use of STM for implementing concurrent ABS in a systematic way.

%Note that there exists also the actor model of concurrency, which is especially well suited to implement concurrent applications in functional languages. We give a short overview over it, existing research and its use in ABS in the section \ref{sec:actors} but leave it for further research as it has very different implications, which are beyond the focus of this thesis.

\input{./tex/research/parallelabs/concurrent/stm.tex}

\input{./tex/research/parallelabs/concurrent/stmabs.tex}

\input{./tex/research/parallelabs/concurrent/sir.tex}

\input{./tex/research/parallelabs/concurrent/sugarscape.tex}

\input{./tex/research/parallelabs/concurrent/discussion.tex}