\subsection{An Event-Driven Sugarscape}
The event-driven approach of Sugarscape alters slightly from the event-driven SIR, discussed before. In the SIR, the dynamics are driven by the pro-activity of the agents through the \texttt{MakeContact} and \texttt{Recover} events. The agents (re-)schedule these events to themselves and thus drive time and the dynamics forward as a group without central authority. In Sugarscape, the semantics of the model are different, where in each time step all agents are executed in random order where they perform their actions and interact with each other. Time is advanced discretely in natural numbers, centrally through the simulation kernel, by scheduling a \texttt{Tick} event to each of the agents in random order. Thus, events have no associated timestamp as there is no need for scheduling of events into the future. Indeed, beside the simulation kernel-specific \texttt{Tick} event, the model-specific events in Sugarscape are used solely for the purpose of agent interactions as will be discussed below. This follows the same approach of the event-driven SIR, where agent interactions between the susceptible and infected are implemented by scheduling events with a time delay of 0. The Sugarscape implementation follows the same idea but does that without the use of time delays as model specific events are scheduled immediately within the same \texttt{Tick} event.

The polymorphic event definition in Sugarscape is thus split into two parts: \texttt{Tick}, which is scheduled by the simulation kernel and indicates to the agent the start of a new time step. Secondly, \texttt{DomainEvent}, which is scheduled by other agents to a specific receiver within a given \texttt{Tick} and received by the target agent within the same \texttt{Tick}. The \texttt{Tick} event carries the time delta between steps to avoid the necessity of hardcoding it into the agent; \texttt{DomainEvent} also carries the sender of the event, to support easy replying to events which avoids the need to add the sender to the actual event type as was done in the event-driven SIR. Due to the discrete time semantics of Sugarscape, where time is advanced in natural numbered steps, time and time delta between steps are represented both as \texttt{Int}.

\begin{HaskellCode}
type Time       = Int
type DTime      = Int
type AgentId    = Int
data ABSEvent e = Tick DTime 
                | DomainEvent AgentId e
\end{HaskellCode}

The fact that Sugarscape schedules events without timestamps also has implications for the simulation kernel, which does not require a priority queue. Although the Sugarscape kernel also keeps track of the agents using an \texttt{IntMap} for the agent mappings, it uses a list to keep track of the events. Processing of events is implemented in the pure function \texttt{processEvents}, which takes the \texttt{EventList} and the simulation state, which contains the agent mappings amongst others, and returns the new simulation state as soon as the event list is empty, indicating that all events in the current \texttt{Tick} have been processed and agents are idle.

\begin{HaskellCode}
type EventList e = [(AgentId, ABSEvent e)] -- (receiver, ABSEvent)
processEvents :: EventList e -> SimulationState g -> SimulationState g
\end{HaskellCode}

In each call, the function extracts the event at the front of the \texttt{EventList}. In case the list is empty, it returns the simulation state unchanged, otherwise looks up the receiver and runs it with the given event. The newly scheduled events of the receiver are prepended at the front of the \texttt{EventList} through a recursive call. The initial \texttt{EventList} passed to \texttt{processEvents} is a list with \texttt{Tick} events scheduled for every agent, in random order. The fact that the events an agent schedules are prepended to the front of the \texttt{EventList}, ensures that those events are processed next, which is of utmost importance for a correct working of the synchronous agent interactions discussed below. The implication is then that \texttt{processEvents} is a potentially non-terminating function, in case there is at least one agent which produces at least one event for every event it receives.