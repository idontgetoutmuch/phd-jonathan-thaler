{-# LANGUAGE InstanceSigs #-}
module Main where

import Text.Printf

import Control.Monad.Random
import Control.Monad.Reader
import Control.Monad.Writer
import Data.MonadicStreamFunction.InternalCore
import Test.Tasty
import Test.Tasty.QuickCheck as QC

import SIR.Model
import SIR.Event
import Utils.GenEventSIR
import Utils.GenSIR

-- --quickcheck-replay=557780
-- --quickcheck-tests=1000
-- --quickcheck-verbose
-- --test-arguments=""
-- clear & stack test sir:sir-event-tests

main :: IO ()
main = do
  let t = testGroup "SIR Agent Specifications Tests" 
          [ 
            QC.testProperty "Susceptible invariants" prop_susceptible_invariants
          , QC.testProperty "Infected invariants" prop_infected_invariants
          , QC.testProperty "Recovered agent invariants" prop_recovered_invariant
          ]

  defaultMain t
    
--------------------------------------------------------------------------------
-- INVARIANT PROPERTIES

-- SUSCEPTIBLE INVARIANTS WHEN RECEIVING EVENTS
-- MakeContact: 
--    - replies with random number of Contact Susceptible events with senderId 
--      being the agentid itself and the receiver one from the existing agents
--      and the time being the same time (immediate scheduling)
--    - doesn't schedule any other events than Contact 
--    - output is Susceptible
-- Contact _ Infected:
--    - when getting infected, schedules Recover to itself 
--      into future and output is Infected
--    - when not infected, output is Susceptible
--    - doesn't schedule other events 
-- Recover:
--    - output is Susceptible
--    - doesn't schedule other events
-- NOTE: this specification implicitly covers that a susceptible agent never 
-- goes to recovered with 1 event - it either stays Susceptible or becomes
-- infected. This becomes clear from observing the output and making sure
-- that we have covered all cases
prop_susceptible_invariants :: Property
prop_susceptible_invariants = checkCoverage $ do
    let contactRate = 5
        infectivity = 0.05
        illnessDuration = 15.0

    let mkEvtFreq = 1
        -- will never happen as Recover will never be sent to a Susceptible
        -- agent, thus it can be set to 0, but setting it to > 1 ensures that 
        -- also the edge case is handled
        recEvtFreq = 0
        contEvtFreq = 5
        contSusEvtFreq = 1
        contInfEvtFreq = 3
        -- will never happen, as a Recovered agent does not send any event,
        -- thus it can be set to 0, but setting it to > 1 ensures that also
        -- the edge case is handled
        contRecEvtFreq = 0
        sirFreq = (contSusEvtFreq, contInfEvtFreq, contRecEvtFreq)
        sirFreqSum = contSusEvtFreq + contInfEvtFreq + contRecEvtFreq
        evtFreqSum = mkEvtFreq + recEvtFreq + contEvtFreq

    -- need a random number generator
    g <- genStdGen
    -- generate non-empty list of agent ids, we have at least one agent
    -- the susceptible agent itself
    ais <- genNonEmptyAgentIds
    -- generate positive time
    (Positive t) <- arbitrary
    -- the susceptible agents id is picked randomly from all empty agent ids
    ai <- elements ais 
    -- generate a random event, increased probability for Infected
    evt <- genEventFreq mkEvtFreq contEvtFreq recEvtFreq sirFreq ais

    -- compute probability for any Contac Event 
    let contEvtSplitProb = 100 * (fromIntegral contEvtFreq / fromIntegral evtFreqSum) 

    -- create susceptible agent with agen id
    let a = susceptibleAgent ai contactRate infectivity illnessDuration
    -- run agent with given event and configuration
    let (_g', _a', ao, es) = runAgent g a evt t ais

    case evt of
      Recover -> do
        let cp = 100 * (fromIntegral recEvtFreq / fromIntegral evtFreqSum)
        return $ cover cp True "Susceptible receives Recover"
                    (null es && ao == Susceptible)

      MakeContact -> do
        let cp = 100 * (fromIntegral mkEvtFreq / fromIntegral evtFreqSum)
        let ret = checkMakeContactInvariants ai ais t es contactRate
        return $ cover cp True "Susceptible receives MakeContact" (ret && ao == Susceptible)

      Contact _ s -> 
        case s of
          -- this event is never be generated by genEventFreq because it never happens
          Recovered -> do
            let cp = contEvtSplitProb * (fromIntegral contRecEvtFreq / fromIntegral sirFreqSum)
            return $ cover cp True "Susceptible receives Contact * Recovered" 
                      (null es && ao == Susceptible)
          -- Susceptible does not reply to this
          Susceptible -> do
            let cp = contEvtSplitProb * (fromIntegral contSusEvtFreq / fromIntegral sirFreqSum)
            return $ cover cp True "Susceptible receives Contact * Susceptible" 
                            (null es && ao == Susceptible)
          -- might become infected
          Infected -> do
            let contInfProb = contEvtSplitProb * (fromIntegral contInfEvtFreq / fromIntegral sirFreqSum)
            let infProb = contInfProb * infectivity

            if ao /= Infected
              -- not infected, nothing happens
              then return $ 
                    cover (contInfProb - infProb) True "Susceptible receives Contact * Infected, stays Susceptible" 
                      (null es && ao == Susceptible) 
              -- infected, check invariants
              else return $ 
                    cover infProb True ("Susceptible receives Contact * Infected, becomes Infected with prob " ++ printf "%.2f" infProb)
                      (checkInfectedInvariants ai t es)
  where
    checkInfectedInvariants :: AgentId
                            -> Time
                            -> [QueueItem SIREvent]
                            -> Bool
    checkInfectedInvariants sender t 
        [QueueItem receiver (Event Recover) t'] -- expect exactly one Recovery event
      = sender == receiver && t' >= t -- receiver is sender (self) and scheduled into the future
    checkInfectedInvariants _ _ _ = False

    checkMakeContactInvariants :: AgentId
                               -> [AgentId]
                               -> Time
                               -> [QueueItem SIREvent]
                               -> Int
                               -> Bool
    checkMakeContactInvariants sender ais t es contactRate
        -- make sure there has to be exactly one MakeContact event
        = invOK && hasMakeCont && numCont == contactRate
      where
        (invOK, hasMakeCont, numCont) = foldr checkMakeContactInvariantsAux (True, False, 0) es

        checkMakeContactInvariantsAux :: QueueItem SIREvent 
                                      -> (Bool, Bool, Int)
                                      -> (Bool, Bool, Int)
        checkMakeContactInvariantsAux 
            (QueueItem receiver (Event (Contact sender' Susceptible)) t') (b, mkb, n)
          = (b && sender == sender'    -- the sender in Contact must be the Susceptible agent
               && receiver `elem` ais  -- the receiver of Contact must be in the agent ids
               && t == t', mkb, n+1)   -- the Contact event is scheduled immediately
        checkMakeContactInvariantsAux 
            (QueueItem receiver (Event MakeContact) t') (b, mkb, n) 
          = (b && receiver == sender   -- the receiver of MakeContact is the Susceptible agent itself
               && t' == t + 1.0        -- the MakeContact event is scheduled 1 time-unit into the future
               &&  not mkb, True, n)   -- there can only be one MakeContact event
        checkMakeContactInvariantsAux evt (_, mkb, _) = error ("failure " ++ show evt) (False, mkb)

-- INFECTED INVARIANTS WHEN RECEIVING EVENTS
-- MakeContact: 
--    - doesn't schedule any events 
--    - output Infected
-- Contact _ Susceptible:
--    - schedules Contact Infected event back to the receiver with self agent id
--    - doesn't schedule other events 
--    - output Infected
-- Contact _ _:
--    - doesn't schedule any events 
--    - output Infected
-- Recover:
--    - doesn't schedule any events 
--    - output Recovered
-- NOTE: this specification implicitly covers that an infected agent never 
-- goes back to susceptible 
prop_infected_invariants :: Property
prop_infected_invariants = property $ do
    -- need a random number generator
    g  <- genStdGen
    -- generate non-empty list of agent ids, we have at least one agent
    -- the susceptible agent itself
    ais <- genNonEmptyAgentIds
    -- generate positive time
    (Positive t) <- arbitrary
    -- the infected agents id is picked randomly from all empty agent ids
    ai <- elements ais 
    -- generate a random event
    evt <- genEvent ais

    -- create susceptible agent with agent id
    let a = infectedAgent ai
    -- run agent with given event and configuration
    let (_g', _a', ao, es) = runAgent g a evt t ais

    case evt of
      Recover -> return (null es && ao == Recovered)
      
      (Contact sender Susceptible) ->
        return $ checkContactInvariants ai sender t es
      
      _ -> return (null es && ao == Infected)

  where
    checkContactInvariants :: AgentId
                           -> AgentId
                           -> Time
                           -> [QueueItem SIREvent]
                           -> Bool
    checkContactInvariants ai sender t 
        [QueueItem receiver (Event (Contact ai' Infected)) t'] -- expect exactly one Contact * Infected event
      = sender == receiver && -- receiver is the sender of the initial Contact event
        ai     == ai'      && -- agent id in Contact is the Infected agent
        t'     == t           -- scheduled immediately
    checkContactInvariants _ _ _ _  = False -- no other events expected

-- RECOVERED INVARIANTS WHEN RECEIVING EVENTS
-- MakeContact: 
--    - doesn't schedule any events 
--    - output Recovered
-- Contact _ _:
--    - doesn't schedule other events 
--    - output Recovered
-- Recover:
--    - doesn't schedule any events 
--    - output Recovered
-- NOTE: this specification implicitly covers that the recovered agent will
-- stay recovered forever.
prop_recovered_invariant :: Property
prop_recovered_invariant = property $ do
  g            <- genStdGen
  -- must be non-empty because we have at least one agent in the simulation:
  -- the recovered itself
  ais          <- genNonEmptyAgentIds 
  (Positive t) <- arbitrary
  evt          <- genEvent ais

  let a = recoveredAgent
      (_g', _a', ao, es) = runAgent g a evt t ais

  return (null es && ao == Recovered)

--------------------------------------------------------------------------------
-- AGENT RUNNER
--------------------------------------------------------------------------------
runAgent :: RandomGen g
         => g
         -> SIRAgentCont g
         -> SIREvent
         -> Time
         -> [AgentId]
         -> (g, SIRAgentCont g, SIRState, [QueueItem SIREvent])
runAgent g a e t ais  = (g', a', ao, es)
  where
    aMsf       = unMSF a e
    aEvtWriter = runReaderT aMsf t
    aAisReader = runWriterT aEvtWriter
    aRand      = runReaderT aAisReader ais

    (((ao, a'), es), g') = runRand aRand g

--------------------------------------------------------------------------------
-- OBSOLETE TESTS
--------------------------------------------------------------------------------
-- infected agent recovering schedules event with average illnessduration
-- NOTE: not really useful, we showed the concept of coverage already 
-- prop_infected_meanIllnessDuration :: Property
-- prop_infected_meanIllnessDuration = checkCoverage $ do
--   let ild = 15.0
  
--   -- infectivity of 1 and higher contact rate to make sure high number of infections
--   durMay <- genSusceptibleAgentInfected 10 1 ild

--   let prob = 100 * expCDF (1 / ild) ild

--   return $ isJust durMay ==>
--       cover prob (fromJust durMay <= ild) 
--         ("infected have an illness duration of up to " ++ show ild ++ 
--         ", expected " ++ printf "%.2f" prob)  True

-- genSusceptibleAgentInfected :: Int
--                             -> Double
--                             -> Double
--                             -> Gen (Maybe Double)
-- genSusceptibleAgentInfected cor inf ild = do
--   g             <- genStdGen
--   (Positive t)  <- arbitrary
--   ais           <- genAgentIds
--   (Positive ai) <- arbitrary

--   let a = susceptibleAgent ai cor inf ild
--       (_g', _ag', ao, es) = runAgent g a (Contact ai Infected) t ais

--   case ao of
--     Infected -> do
--       -- in case it become infected, the agent only schedules a single 
--       -- event: recovery, to itself
--       let [QueueItem _ (Event Recover) t'] = es
--       return $ Just (t' - t)
--     _        -> return Nothing


-- recovered stays recovered never susceptible or infected
-- NOTE: already covered in recovered invariants!
-- prop_recovered_forever :: Gen Bool
-- prop_recovered_forever = do
--   g   <- genStdGen
--   ais <- genAgentIds
--   es  <- vectorOf 1000 (genEvent ais)
--   (Positive t) <- arbitrary

--   let a   = recoveredAgent
--       aos = runAgentEventsOut es g a t ais

--   return (all (==Recovered) aos)

-- -- infected never back to susceptible 
-- -- NOTE: already covered in infected invariants!
-- prop_infected_neversusceptible :: Gen Bool
-- prop_infected_neversusceptible = do
--   g   <- genStdGen
--   ais <- genAgentIds
--   es  <- vectorOf 1000 (genEvent ais) 
--   (Positive ai) <- arbitrary
--   (Positive t)  <- arbitrary

--   let a   = infectedAgent ai
--       aos = runAgentEventsOut es g a t ais

--   return (not $ any (==Susceptible) aos)


-- susceptible becomes infected on average with infectivity
-- NOTE: already covered in susceptible invariants!
-- prop_susceptible_meanInfectivity :: Property
-- prop_susceptible_meanInfectivity = checkCoverage $ do
--     let repls = 100
--     is <- vectorOf repls genMeanInfectivity

--     let confidence = 0.95
--         csTTest    = tTestSamples TwoTail infectivity (1 - confidence) is

--     return $ cover 95 (fromMaybe True csTTest) "mean infectivity" True
--   where
--     genMeanInfectivity :: Gen Double
--     genMeanInfectivity = do
--       let repls = 100
--       is <- catMaybes <$> vectorOf repls genSusceptibleAgentInfected

--       let infectedCount = length is
--           infectedRatio = (fromIntegral infectedCount / fromIntegral repls) :: Double

--       return infectedRatio

-- infected agent recovering schedules event with average illnessduration
-- NOTE: covered already by the much faster prop_infected_meanIllnessDuration test
-- prop_infected_meanIllnessDuration_ttest :: Property
-- prop_infected_meanIllnessDuration_ttest = checkCoverage $ do
--   let ild   = 15.0
--       repls = 1000

--   -- infectivity of 1 and higher contact rate to make sure high number of infections
--   is <- catMaybes <$> vectorOf repls (genSusceptibleAgentInfected 10 1 ild)

--   let confidence = 0.95
--       csTTest    = tTestSamples TwoTail ild (1 - confidence) is

--   return $ 
--     cover 95 (fromMaybe True csTTest) 
--       ("infected have a mean illness duration of " ++ show ild) True
