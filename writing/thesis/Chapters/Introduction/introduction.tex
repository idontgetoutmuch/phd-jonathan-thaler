%*******************************************************************************
%*********************************** First Chapter *****************************
%*******************************************************************************

\chapter{Introduction}  %Title of the First Chapter
I noticed that it is pretty hard to convince an agent-based economics specialist who is not a computer scientist about a pure functional approach. My conjecture is that the implementation technique and method does not matter much to them because they have very little knowledge about programming and are almost always self-taught - they don't know about software-engineering, nothing about proper software-design and architecture, nothing about software-maintenance, nothing about unit-testing,... In the end they just "hack" the simulation in whatever language they are able to: C++, Visual Basic, Java or toolboxes like Netlogo. For them it is all about to \textit{get things done somehow} and not to get things done the right way or in a beautiful way - the way and the method doesn't matter, its just a necessary evil which needs to be done. Thus if functional programming could make their lives easier, then they will definitely welcome it. But functional programming is, i think, harder to learn and harder to understand - so one needs to provide an abstraction through EDSL. So I REALLY need to come up with convincing arguments why to use pure functional approaches in ACE THEY can understand, otherwise I will be lost and not heard (not published,...). \\

What ACE economists care for:

\begin{itemize}
\item Very: Qualitative modelling with quantitative results
\item Yes: Easy reproducibility
\item Likely: Reasoning about convergence?
\item Likely: EDSL
\end{itemize}

My contributions are: pure functional framework, functional agent-model for market-simulations, EDSL for market-simulations, qualitative / implicit modelling with quanitative results, reasoning in my framework about convergence \\

IDEA: could I develop non-causal modelling (models are expressed in terms of non-directed equations, modelled in signal-relations) to allow for qualitative modelling for the agent-based economists? See hybrid modelling paper of Yampa. \textbf{THIS WOULD BE A HUGE NOVEL CONTRIBUTION TO ACE ESPECIALLY WHEN COMBINED WITH AN EDSL AND PROVIDING FULL REFERENTIAL TRANSPARENCY TO KEEP THE ABILITY TO REASON ABOUT CONVERGENCE}. This should be covered in the "EDSL"-paper.

TODO: maybe i should really focus only on market models? otherwise too much? \\

central novelty of my PhD: model specification = runnable code. possible through EDSL. but only in specific subfield of ACE: market-models. need a functional description of the model, then translate it to model specification in EDSL and then run it to see dynamics. But: model specification moves closer to functional programming languages. \\

another novelty approach: model specification through qualitative instead of quantiative approaches. is this possible? \\

WHY FUNCTIONAL? "because its the ultimate approach to scientific computing": fewer bugs due to mutable state (why? is thos shown obkectively by someone?), shorter (again as above, productivity), more expressive and closer to math, EDSL, EDSL=model=simulation, better parallelising due to referental transparency, reasoning \\

scientific results need to be reproduced, especially when they have high impact. a more formal approach of specifying the model and the simulation (model=simulation) could lead to easier sharing and easier reporduction without ambigouites \\

pure functional agent-model \& theory, EDSL framework in Haskell for ACE

\begin{enumerate}
\item Which kind of problem do we have?
\item What aim is there? Solving the problem? 
\item How the aim is achieved by enumerating VERY CLEAR objectives.
\item What the impact one expects (hypothesis) and what it is (after results).
\end{enumerate}

Note: It is not in the interest of the researcher to develop new economic theories but to research the use of functional methods (programming and specification) in agent-based computational economics (ACE).

NOTE: Get the reader’s attention early in the introduction: motivation, significance, originality and novelty.

\section{Methods}
Methods need to be selected to implement the simulations. Special emphasis will be put on functional ones which will then be compared to established methods in the field of ABM/S and ACE. \\

Claim: non-programming environments are considered to be not powerful enough to capture the complexity of ACE implementations thus a programming approach to ACE will be always required.

\section{Scenarios}
To apply and test functional methods in ACE, four scenarios of ACE are selected and then the methods applied and compared with each other to see how each of them perform in comparison. The 4 selected scenarios represent a selection of the challenges posed in ACE: from very abstract ones to very operational ones.

\section{Comparison}
Each of the selected scenarios is then implemented using the selected methods where each solution is then compared against the following criteria: 

\begin{enumerate}
\item suitability for scientific computation
\item robustness
\item error-sources
\item testability
\item stability
\item extendability
\item size of code
\item maintainability
\item time taken for development
\item verification \& correctness
\item replications \& parallelism
\item EDSL
\end{enumerate}

This will then allow to compare the different methods against each other and to show under which circumstances functional methods shine and when they should not be used.

\section{Agent-Based Modelling and Simulation (ABM/S)}
ABM/S is a method of modelling and simulating a system where the global behaviour may be unknown but the behaviour and interactions of the parts making up the system is of knowledge (Wooldrige, M. (2009). An Introduction to MultiAgent Systems. John Wiley & Sons). Those parts, called agents, are modelled and simulated out of which then the aggregate global behaviour of the whole system emerges. Thus the central aspect of ABM/S is the concept of an Agent which can be understood as a metaphor for a pro-active unit, able to spawn new Agents, and interacting with other Agents in a network of neighbours by exchange of messages. The implementation of Agents can vary and strongly depends on the programming language and the kind of domain the simulation and model is situated in.

\section{Agent-Based Economics (ACE)}
According to Leigh Tesfatsion (Tesfatsion, L. (2006). Agent-based computational economics: A constructive approach to economic theory. In Tesfatsion, L. and Judd, K. L., editors, Handbook of Computational Economics, volume 2, chapter 16, pages 831–880. Elsevier, 1 edition.), one of the leading figures, ACE is "[...] computational modelling of economic processes (including whole economies) as open-ended dynamic systems of interacting agents." - thus lending perfectly to the use of ABM/S as already the name suggests. Whereas classical economic models fall short by only looking at the average, pure rational, individual interacting in anonymous markets, the ACE approach looks at heterogeneous, non-rational individuals interacting with each other in networks (Kirman, A. (2010). Complex Economics: Individual and Collective Rationality. Routledge, London ; New York, NY.). Thus ACE can be understood as a combination of computer-science, cognitive/social science and evolutionary economics.

\section{Functional programming}
TODO: read \cite{Backus1978}

The state-of-the-art approach to implementing Agents are object-oriented methods and programming as the metaphor of an Agent as presented above lends itself very naturally to object-orientation (OO). The author of this thesis claims that OO in the hands of inexperienced or ignorant programmers is dangerous, leading to bugs and hardly maintainable and extensible code. The reason for this is that OO provides very powerful techniques of organising and structuring programs through Classes, Type Hierarchies and Objects, which, when misused, lead to the above mentioned problems. Also major problems, which experts face as well as beginners are 1. state is highly scattered across the program which disguises the flow of data in complex simulations and 2. objects don’t compose as well as functions. The reason for this is that objects always carry around some internal state which makes it obviously much more complicated as complex dependencies can be introduced according to the internal state.
All this is tackled by (pure) functional programming which abandons the concept of global state, Objects and Classes and makes data-flow explicit. This then allows to reason about correctness, termination and other properties of the program e.g. if a given function exhibits side-effects or not. Other benefits are fewer lines of code, easier maintainability and ultimately fewer bugs thus making functional programming the ideal choice for scientific computing and simulation and thus also for ACE. A very powerful feature of functional programming is Lazy evaluation. It allows to describe infinite data-structures and functions producing an infinite stream of output but which are only computed as currently needed. Thus the decision of how many is decoupled from how to (Hughes, J. (1989). Why functional programming matters. Comput. J., 32(2):98–107.).
The most powerful aspect using pure functional programming however is that it allows the design of embedded domain specific languages (EDSL). In this case one develops and programs primitives e.g. types and functions in a host language (embed) in a way that they can be combined. The combination of these primitives then looks like a language specific to a given domain, in the case of this thesis ACE. The ease of development of EDSLs in pure functional programming is also a proof of the superior extensibility and composability of pure functional languages over OO (Henderson P. (1982). Functional Geometry. Proceedings of the 1982 ACM Symposium on LISP and Functional Programming.).
One of the most compelling example to utilize pure functional programming is the reporting of Hudak (Hudak P., Jones M. (1994). Haskell vs. Ada vs. C++ vs. Awk vs. ... An Experiment in Software Prototyping Productivity. Department of Computer Science, Yale University.)  where in a prototyping contest of DARPA the Haskell prototype was by far the shortest with 85 lines of code. Also the Jury mistook the code as specification because the prototype did actually implement a small EDSL which is a perfect proof how close EDSL can get to and look like a specification.

Functional languages can best be characterized by their way computation works: instead of \textit{how} something is computed, \textit{what} is computed is described. Thus functional programming follows a declarative instead of an imperative style of programming. The key points are:
\begin{itemize}
\item No assignment statements - variables values can never change once given a value.
\item Function calls have no side-effect and will only compute the results - this makes order of execution irrelevant, as due to the lack of side-effects the logical point in \textit{time} when the function is calculated within the program-execution does not matter.
\item higher-order functions
\item lazy evaluation
\item Looping is achieved using recursion, mostly through the use of the general fold or the more specific map.
\item Pattern-matching
\end{itemize}

This alone does not really explain the \textit{real} advantages of functional programming and one must look for better motivations using functional programming languages. One motivation is given in \cite{Hughes1989} which is a great paper explaining to non-functional programmers what the significance of functional programming is and helping functional programmers putting functional languages to maximum use by showing the real power and advantages of functional languages. The main conclusion is that \textit{modularity}, which is the key to successful programming, can be achieved best using higher-order functions and lazy evaluation provided in functional languages like Haskell. \cite{Hughes1989} argues that the ability to divide problems into sub-problems depends on the ability to glue the sub-problems together which depends strongly on the programming-language and \cite{Hughes1989} argues that in this ability functional languages are superior to structured programming.

TODO: comparison of functional and object-oriented programming. My points are:
\begin{itemize}
\item The way state can be changed and treated - distributed over multiple objects - is often very difficult to understand.
\item Inheritance is a dangerous thing if not used with care because inheritance introduces very strong dependencies which cannot be changed during runtime anymore.
\item Objects don't compose very well: \url{http://zeroturnaround.com/rebellabs/why-the-debate-on-object-oriented-vs-functional-programming-is-all-about-composition/}
\item (Nearly) impossible to reason about programs
\end{itemize}

In conclusion the upsides of functional programming as opposed to OO are:
\begin{itemize}
\item Much more explicit flow of data \& control
\item Much better compose-able
\item Much better parallelism
\end{itemize}

\section{Related Research}
Tim Sweeney, CTO of Epic Games gave an invited talk about how "future programming languages could help us write better code" by "supplying stronger typing, reduce run-time failures;  and the need for pervasive concurrency support, both implicit and explicit, to effectively exploit the several forms of parallelism present in games and graphics." \cite{Sweeney2006}. Although the fields of games and agent-based simulations seem to be very different in the end, they have also very important similarities: both are simulations which perform numerical computations and update objects - in games they are called "game-objects" and in abm they are called agents but they are in fact the same thing - in a loop either concurrently or sequential. His key-points were:

\begin{itemize}
\item Dependent types as the remedy of most of the run-time failures.
\item Parallelism for numerical computation: these are pure functional algorithms, operate locally on mutable state. Haskell ST, STRef solution enables encapsulating local heaps and mutability within referentially transparent code.
\item Updating game-objects (agents) concurrently using STM: update all objects concurrently in arbitrary order, with each update wrapped in atomic block - depends on collisions if performance goes up.
\end{itemize}