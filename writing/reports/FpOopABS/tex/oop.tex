\chapter{Object-Oriented Programming}
- OO has not a generally accepted theory behind it although there have been attempts to establish one \cite{abadi_theory_1996}
- OO is thus a bunch of concepts and terms and methods that make up this methodology - this methodology was inspired from AI and human-computer interaction (alan kay, sutherland) and has grown and matured in the 90s. Its development was driven mainly by the software-industry which painfully has learned how to best use OO over the time of a decade.
- here we focus on imperative OOP (there are mixed-paradigm oo / functional with oo languages: F\#, OCAML, Scala?) because imperative OOP is primarily used in implementing ABS
- there are concepts which show up both in OO and functional languages e.g. type-classes and inheritance of type-classes in haskell, but that does not make haskell an OO language - rather it shows that there are type-theoretic concepts which are not unique to OO.
- we also focus on 'modern' OOP as it is implemented and used in the languages Java, C\# and C++. There are fundamental differences between these implementations of OO and the original ideas alan kay had (no references, messages no mutable state). Some languages are much closer to the original version (e.g. Smalltalk) but are not widely used anymore.
- cite critics of OO
- study \cite{abadi_theory_1996} to derive the concepts of OOP from a theoretical point-of-view
- important terms / concepts of OOP
	-> Liskov substitution principle
	-> Dynamic dispatch
	-> Encapsulation
	-> Subtype polymorphism
	-> object inheritance 
	-> Open recursion