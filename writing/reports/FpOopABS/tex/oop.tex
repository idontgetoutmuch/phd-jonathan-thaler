\chapter{Object-Oriented Programming}
- OO has not a generally accepted theory behind it although there have been attempts to establish one \cite{abadi_theory_1996}
- OO is thus a bunch of concepts and terms and methods that make up this methodology - this methodology was inspired from AI and human-computer interaction (alan kay, sutherland) and has grown and matured in the 90s. Its development was driven mainly by the software-industry which painfully has learned how to best use OO over the time of a decade.
- here we focus on imperative OOP (there are mixed-paradigm oo / functional with oo languages: F\#, OCAML, Scala?) because imperative OOP is primarily used in implementing ABS
- there are concepts which show up both in OO and functional languages e.g. type-classes and inheritance of type-classes in haskell, but that does not make haskell an OO language - rather it shows that there are type-theoretic concepts which are not unique to OO.
- we also focus on 'modern' OOP as it is implemented and used in the languages Java, C\# and C++. There are fundamental differences between these implementations of OO and the original ideas alan kay had (no references, messages no mutable state). Some languages are much closer to the original version (e.g. Smalltalk) but are not widely used anymore.
- cite critics of OO
- study \cite{abadi_theory_1996} to derive the concepts of OOP from a theoretical point-of-view
- important terms / concepts of OOP
	-> Liskov substitution principle
	-> Dynamic dispatch
	-> Encapsulation
	-> Subtype polymorphism
	-> object inheritance 
	-> Open recursion
	


\section{Theoretical Foundation}
There is no direct theoretical foundation for Object-Oriented Programming because it is rather a modelling and engineering approach but it builds heavily on the imperative style in turn builds directly on the Turing Machine. Still there have been attempts on developing a theory for OOP as in \cite{abadi_theory_1996}, which we will discuss briefly below.

\subsection{Turing Machine}
\cite{webber_formal_2008}

\subsection{Types}
We already introduced the basics of a type system in Chapter \ref{ch:fp} and discussed the terms of static / dynamic and strong / weak typing. Due to the nature of the paradigm oo type systems tend to be dynamically weakly typed. TODO: is this true? e.g. what with Smalltalk? other exotic languages? Java is definitely weak dynamically typed with some amount of static type-checking during compile time.

\cite{abadi_theory_1996}

\subsection{An Example: arithmetic operations }
TODO: addition and multiplication in the turing machine

\section{Java}
TODO: discuss applicative- and functional programming constructs provided in java, investigate lambdas in java
[ ] java lambdas are syntactic sugar for anonymous classes to resemble a more functional style of programming. sideeffects still possible
[ ] look into the aggregate functions of java. also support functional style of programming.
[ ] same for method references as above: it is impressive how much bulk was added to the language to introduce these concepts which work out of the box in Haskell with higher order functions, currying and lambdas 
make it clear that just because java has now lambdas does not make it functional. 

As the language of choice for discussing the object-oriented paradigm in implementing ABS is Java. The reason for this is that it is a very popular language widely in use implementing ABS and the basis for ABS libraries and frameworks as Repast Simphony and AnyLogic. Other options would have been C++ which we abandoned due to its high inherent complexity and C\# which can be seen as roughly equivalent to Java.