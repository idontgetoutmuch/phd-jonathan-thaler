\chapter{Introduction}

TODO: line of argumentation and structure of the report
computation to language paradigms to concrete languages to libraries: turing machine and lambda to functional and imperative / operational to haskell and java to frabs and repast. on all levels can we identify the parallels to ABS or do they only show up in the very end? i think we can trace them to the paradigms 

[ ] start with the question: all these programming languages are turing complete, why then not implement directly in turing machine or lambda calculus and why bother about different paradigms? the power is there isnt it?
[ ] then look into the very foundations of conputation: turing model vs. lambda calculu denotational
[ ] then make it clear that we dont program in a turing machine or lambda calculus (actually haskell is much much closer to lambda calculus than e.g. java or even is to a turing machine) because the raw power becomes unmanagable, we loose control. why? because we think problems which are more complex than operations on natural numbers very different and these lowlevel computational languages dont allow us to express this - they are not very expressive: too abstract.
[ ] thus we arrive at a first conclusion: TM in theory yes but its not practical because we think about problems different and TM does not allow us directly to express in the way we think, we need to build  more mechanisms on top of this concept. so we have introduced the concept of expressivity. how can we express e.g. an if statement or a loop in a TM? 
[ ] for the lambda calculus it is about the same with the difference that it is much more expressive than a TM
[ ] so then the argumentation continues: we build up more and more levels of abstractions where each depends on preceeding ones. the point is that some languages stop at some level of abstraction and others continue.
[ ] also there are different types of abstraction depending if we come either from lambda or turing direction 
[ ] the question is then: which level of abstraction is necessary for ABS? how provide FP and OOP these?

\section{Programming Paradigms}
define what is functional programming
define what is imperative programming
define what is object-oriented programming

make it clear that just because java has now lambdas does not make it functional. 
distinguish between functional style and functional programming. when using a specific style one abuses language features to emulate a different paradigm than the one of the host language - so it is also possible to emulate oop in C or Haskell but this does not make them oop languages, one just emulate a programming-style (with potentially disastrous consequences as the code will probably become quite unreadable)

[ ] java lambdas are syntactic sugar for anonymous classes to resemble a more functional style of programming. sideeffects still possible
[ ] look into the aggregate functions of java. also support functional style of programming.
[ ] same for method references as above: it is impressive how much bulk was added to the language to introduce these concepts which work out of the box in Haskell with higher order functions, currying and lambdas 

TODO: investigate lambdas in java

TODO: there is already a low-level haskell/java comparison there: in the code of the update-strategies paper. Also make direct use of this paper as it discusses some of the fundamental challenges implementing ABS in an language- and paradigm-agnostic way

haskells real power: side-effect polymorph. enabled through monadic progranming which becomes possible through type parameters, typeclasses, higher-order functions, lambdas and pattern matching

\section{Object Oriented Programming (OOP)}
- OO has not a generally accepted theory behind it although there have been attempts to establish one \cite{abadi_theory_1996}
- OO is thus a bunch of concepts and terms and methods that make up this methodology - this methodology was inspired from AI and human-computer interaction (alan kay, sutherland) and has grown and matured in the 90s. Its development was driven mainly by the software-industry which painfully has learned how to best use OO over the time of a decade.
- here we focus on imperative OOP (there are mixed-paradigm oo / functional with oo languages: F\#, OCAML, Scala?) because imperative OOP is primarily used in implementing ABS
- there are concepts which show up both in OO and functional languages e.g. type-classes and inheritance of type-classes in haskell, but that does not make haskell an OO language - rather it shows that there are type-theoretic concepts which are not unique to OO.
- we also focus on 'modern' OOP as it is implemented and used in the languages Java, C\# and C++. There are fundamental differences between these implementations of OO and the original ideas alan kay had (no references, messages no mutable state). Some languages are much closer to the original version (e.g. Smalltalk) but are not widely used anymore.
- cite critics of OO
- study \cite{abadi_theory_1996} to derive the concepts of OOP from a theoretical point-of-view
- important terms / concepts of OOP
	-> Liskov substitution principle
	-> Dynamic dispatch
	-> Encapsulation
	-> Subtype polymorphism
	-> object inheritance 
	-> Open recursion
	
\section{Functional Programming (FP)}
MacLennan \cite{maclennan_functional_1990} defines Functional Programming as a methodology and identifies it with the following properties:

\begin{enumerate}
	\item It is programming without the assignment-operator.
	\item It allows for higher levels of abstraction.
	\item It allows to develop executable specifications and prototype implementations.
	\item It is connected to computer science theory.
	\item Parallel Programming.
	\item Suitable for AI.
\end{enumerate}

The last two points don't weight as heavy today as back in 1990 as other languages came up with features for better parallel programming but they all do it by introducing functional features.

MacLennan \cite{maclennan_functional_1990} defines properties of pure expressions 
\begin{itemize}
	\item Value is independent of the evaluation order.
	\item Expressions can be evaluated in parallel.
	\item Referential transparency.
	\item No side effects.
	\item Inputs to an operation are obvious from the written form.
	\item Effects to an operation are obvious from the written form.
\end{itemize}

TODO: The question is then if we could implement in a functional style in an imperative object-oriented programming language? Or put otherwise: are these properties unique to functional programming or can we program functional in an imperative language (be it OO or not)?

Thus functional programming is identified as programming without the assignment operator and with pure expressions instead. Further characteristics are the missing of orderings as in imperative programming, caused by assignments: in functional programming the style is applicative which means we apply values to functions. The fundamental theoretical root is in the lambda calculus.

TODO: make distinction between 'applicative programming (style)', which is easily possible in imperative languages as well and 'functional programming' which is not possible in procedural languages. The question is if it is possible in OO by using some OO features to work around the limitations of procedural languages.

- cite critics