\chapter{Introduction}
\label{chap:intro}
In the first half of the Ph.D. I have investigated \textit{how} to do agent-based simulation in functional programming. This step was necessary because there didn't exist any research, implementation or anything which could be used. Also it served to develop a very deep understanding of functional programming and its combination with agent-based simulation (ABS).

In this process, it became apparent that there are a few unique benefits over the established, state-of-the-art object-oriented approaches which can be subsumed under the common category of \textit{increasing the correctness of the software / simulation}. This insight didn't come as a surprise as this is what the functional programming paradigm is known for and this was also the hypothesis with which we started with: \textit{Functional programming will allow us to write ABS which is more likely to be correct}. Note that, strictly speaking, a software / simulation is either correct or not but we cannot decide this generally for software unless we are willing to pour in an extreme amount of formalisms and tests, so when we say 'increasing the correctness' or 'more likely to be correct' we mean that we can guarantee less bugs and less sources of potential bugs.

We commit the next year of the Ph.D. to explore this insight in a rigorous way and push it to new levels. We hypothesise that this will allow us to write simulations which are \textit{very} likely to be correct and allow a much deeper level of formal and informal reasoning, something not possible with the established object-oriented approaches of the field yet. Because correctness is of paramount importance in scientific computing, our research is a valuable contribution to the field and can be regarded as high impact work.

In the next section of this chapter we will briefly discuss our approach of \textit{how} agent-based simulation can be done with the functional paradigm and its benefits and drawbacks. Then we will give a short overview of \textit{why} this is of benefit and introduce concepts which will outline the research for the next 10 months. Also we will shortly discuss what this research is \textit{not} doing and we give a short overview of the (intended) contributions of this research. 

In the following chapters we will give an in-depth introduction to the concepts used in the research of the following year, namely Verification \& Validation in Chapter \ref{chap:v_and_v} and Dependent Types in Chapter \ref{chap:dependent_types}. We also believe that although our research is conducted in the field of ABS, part of it is transferable to simulation in general and possibly other fields, closely related to ABS. We discuss this shortly in Chapter \ref{chap:generalising}. We also have included updated chapters on Aims \& Objectives \ref{chap:aimsObj}, Work to Date \ref{chap:work_to_date} and Future Work Plan \ref{chap:future}.

\section{How}
The essence of \textit{how} to do agent-based simulation using the functional programming paradigm, as in the language Haskell, is described in the paper found in Appendix \ref{app:pfe}. The approach we developed is based on Functional Reactive Programming which allows to express discrete- and continuous-time systems in functional programming. Following the conclusions of the paper, we got the following benefits, which support directly our initial hypothesis:
\begin{enumerate}
	\item Run-Time robustness - we can restrict the classes of bugs which occur at run-time by a substantial amount due to Haskells strong and static type system. Note that we can still have run-time bugs in Haskell when our functions are partial.
	\item Compile-Time guarantees - express stronger guarantees already at compile time (TODO: need examples).
	\item Purity - explicit in the types about side-effects and can handle side-effects explicitly in a controlled way - no non-deterministic side-effects, also can control side-effects much better e.g. Random-Numbers and State
	\item Explicit Data-Flow - no implicit data-dependencies because we are excluding IO. This makes reasoning of data-dependencies and data-flow much easier as compared to traditional oo approaches which utilize pointers or references.
	\item Declarative - describing WHAT a system is, instead of HOW (imperative) it works - in this way it is much easier to reason about a system and its (expected) behaviour 
\end{enumerate}

Following the conclusions of the paper, we also found drawbacks. The most fundamental one is that agent-agent and agent-environment interactions work very different because method calls and mutable data are not available. While this is the backbone of the advantages, it also is the backbone of the disadvantages: we had to invent new techniques for these kind of interactions which makes functional agent-based simulation conceptually more difficult to understand and implement models with. Despite these difficulties, it also makes those interactions more expressive and explicit and separates them into different categories which are conceptually different but are almost always implemented the same way in object-oriented approaches.

Another drawback is performance. So far, performance is not comparable to object-oriented approaches, but that was not the main focus of the research. Also functional programming in general can exploit parallelism nearly for free which should allow speeding up of simulations very easily, and if it is just running multiple replications in parallel. We leave this for further research as investigating this is worth a Ph.D. on its own.

\section{Why}
%line of argument
%1. established methods need extensive unit-testing for establishing correctness of software, which only increases the likelihood of correctness and doesnt guarantee it because they are inherent dynamic, testing run-time behaviour, because of the different type system.
%2. functional programming as in haskell has a strong static type system which allows to shift much much more guarantees towards static, compile-time, making many run-time tests obsolete and can guarantee a few things already at compile-time which makes tests to cover that completely obsolete
%3. dependent types can push these guarantees even further and theoretically should allow to express guarantees at compile time to an arbitrary complex level which in theory should allow us to abandon run-time testing of bugs altogether. This does not mean that we don't need any tests anymore, as will be outlined in the chapter on Verification \& Validation \ref{chap:v_and_v}.
%4. with shifting more towards compile-time guarantees we automatically gain more confidence into the correctness of our simulation and reduce the implementation overhead of writing tests for those cases. Also some properties are simply not testable with run-time tests e.g. that some property holds forever - this is only possible to guarantee by looking at the code directly (where functional programming shines) or expressing it through compile-time guarantees.

The established approach to implement ABS falls into three categories:
\begin{enumerate}
	\item Programming from scratch using object-oriented languages where Java and Python are the most popular ones.
	\item Programming using a 3rd party ABS library using object-oriented languages where RePast and DesmoJ both in Java are the most popular one.
	\item Using a high-level ABS toolkit for non-programmers, which allow customization through programming. By far the most popular ones is NetLogo with an imperative programming approach followed by AnyLogic with an object-oriented Java approach.
\end{enumerate}

In general one can say that those approaches (especially the 3rd one) support fast prototyping of simulations which allow quick iteration times to explore the dynamics of a model. All of them ultimately suffer from same problems when it comes to verifying the correctness of the implemented simulation. The established way to test software in traditional object-oriented approaches is writing unit-tests which cover all possible cases. This is possible in approach 1 and 2 but very hard or even impossible when using an ABS toolkit as in 3 which is why this approach basically employs manual testing. In general writing those tests or conducting manual tests is necessary because one cannot guarantee the correct working at compile-time which means testing ultimately tests the correct behaviour of code at run-time. The reason why this is not possible is due to the very different type-systems and paradigm of those approaches. Java has a strong but very dynamic type-system whereas python is completely dynamic not requiring the programmer to put types on data or variables at all - this means that due to type-errors and data-dependencies run-time errors can occur which origins are very difficult to track down.

It is no coincidence that JavaScript, the most widely used language for programming client-side web-applications, originally a completely dynamically typed language like Python, got additions for type-checking / type-checkers developed by the industry and added a type-system in its last version (TODO cite). This is a sign that the industry acknowledges types as something important as they allow to rule out certain classes of bugs at run-time and express guarantees already at compile-time. We expect similar things to happen with Python as it is popularity is surging and more and more people become aware of that problem. Still due to the highly dynamic nature of the type-system, run-time errors are still possible both in Python and Java (and JavaScript). 

In general, Types guide us in program construction by restricting the operations we can perform on the data. This means that by choosing types this reveals already a lot of our program and data and prevents us from making mistakes e.g. interpreting some binary data as text instead of a number. In strongly statically typed languages the types can do this already at compile time which allows to rule out certain bugs already at compile time. In general, we can say that for all bugs which can be ruled out at compile time, we don't need to write property- or unit-tests for them, because those bugs cannot - per definition - occur at run-time, so it won't make sense to test their absence at run-time. Also, as Dijkstra famously put it: "Testing shows the presence, not the absence of bugs" - thus by induction we can say that compile time guarantees save us from a potentially infinite amount of testing.

In general it is well established, that pure functional programming as in Haskell, allows to express much stronger guarantees about the correctness of a program \textit{already at compile-time}. This is in fundamental contrast to imperative object-oriented languages like Java or Python where only primitive guarantees about types - mostly relationships between type-hierarchies - can be expressed at compile time which directly implies that one needs to perform much more testing (user testing or unit testing) at \textit{run-time} to check whether the model is sufficiently correct. Thus guaranteeing properties already at compile-time frees us from writing unit tests which cover these cases or test them at run time because they are \textit{guaranteed to be correct under all circumstances, for all inputs}. In this regards we see pure functional programming as truly superior to the traditional object oriented approaches: they lead to implementations of models which are more likely correct because we can express more guarantees already at compile time which directly leads to less bugs which directly increases the probability of the software being a correct implementation of the model.

Having established this was only the first step in our paper in Appendix \ref{app:pfe}. The next step which follows directly, is to move towards dependent types using the language Idris. Generally speaking, dependent types allow to push compile-time guarantees to a new level where we can express nearly arbitrary complex guarantees at compile-time because we can \textit{compute types at compile time}. This means that types are first-class citizen of the language and go as far as being formal proofs of the correctness of an implementation. We hypothesise that the use of dependent types allows us to push the judgement of the correctness of a simulation to new, unprecedented level, not possible with the established object-oriented approaches so far.

\section{What Not}
Because our research focuses on new implementation techniques and paradigms in agent-based simulation, there is always the question of "Why would you do that, what is wrong with the established way?". Thus new techniques and paradigms always have to justify themselves in terms of benefits and drawbacks and our research is no exception to that. The way we approach this is not on a low technical level but on very broad conceptual levels which have been already established for object-oriented and functional programming paradigms in general. Thus we will \textit{not} compare object-oriented to functional implementations of a same model and go into lengthy debates over Lines Of Code, maintainability, extensibility, readability,... because many of those properties are highly subjective and depend very much on experience. In short: we want to avoid discussions over "which programming language is better" under all circumstances because they lead to nowhere (just take a look in any technical forum / reddit / youtube and you will see the emotions going high like in religious debates). This also means that we are \textit{not} comparing the general approach of pure functional programming in the instance of Haskell and object-oriented programming in the instance of Java to implement ABS.

We have the position that one has to pick the \textit{right} programming language for the \textit{right} task e.g. for web-development one would probably never pick Assembly and for embedded systems programming probably not Haskell. Our research is to find out what the \textit{right} task for functional programming and dependent types is in agent-based simulation - we believe it is correctness. So despite challenging the metaphor that \textit{agents map naturally to objects}, we still think object-oriented programming is great for implementing ABS because we think it is the \textit{easiest} way to go for teaching and low-impact models, not used in far reaching policy decisions because for those, correctness is not the primary objective.

\section{Contributions}
Although I am just half-way through the Ph.D. I anticipate and project the contributions of it:

\begin{enumerate}
	\item This research is the first to \textit{systematically} investigate the application of functional programming paradigm, as in Haskell, to Agent-Based Simulation, identifying its benefits and drawbacks.
	\item This research is the first to apply \textit{dependent types} to Agent-Based Simulation to investigate its usefulness for increasing the correctness of a simulation.
\end{enumerate}