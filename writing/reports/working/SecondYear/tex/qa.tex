\chapter{Questions \& Answers}
\label{chap:qa}

In this chapter I give answers to anticipated questions and objections about my research direction and vision of doing pure functional ABS \footnote{They are not always posed in a dead-serious way but as it is a quite controversial topic - ABS should be done object-orientated after all huh? - I think it is appropriate. Also some objections were raised in exactly this way.}.

\paragraph{So you had this hypothesis, that pure functional programming and dependent types lead to simulation software which is more likely to be correct and is easier to verify and validate, right from the beginning?}
Not at all. I even had no deep knowledge of functional programming at the start of my PhD, I've just worked through the 1st edition of Grahams book "Programming in Haskell" and that's it. I had no clear understanding of purity, side-effects and Monads and I didn't know a bit about functional reactive programming. I knew that something like Dependent Types exist because Thorsten (2nd Supervisor) has sent me an email before the start of my PhD in which he pointed at Agda, so I started reading a bit about intuitionistic / constructivistic math, tried out a little bit of Agda but quickly gave up because it was way too far away (without really having mastered pure functional programming in Haskell, I believe it is nearly impossible / too difficult / makes no sense going into dependent types).
So in the beginning there was pure \textit{curiosity} about functional programming in combination with ABS because I knew nothing of FP at all and wanted to understand it (after getting bored by OO) and applying FP to ABS seemed so crazy (because everyone claims OO to be 'natural' for it) that it must be an extremely interesting challenge. I guess this is very often the case with research: there is 'just' curiosity in the beginning and then during the research process a hypothesis falls into place. Also to \textit{sell} the research, curiosity is \textit{not} enough, one needs to come up with a more sellable argument (I really don't like that aspect of research, but I guess that is how the modern world works...).

\paragraph{What is it with these weird dependent types? Why should we use them? Why are you so obsessed with strongly statically typed languages? How can we benefit from types? Aren't they just in our way?}
I understand that in the beginning when one learns a strong statically typed language, types seem often to get in ones way of doing things - it happened to me when I was learning Haskell and it is now the same issue as I am getting into Idris: types seem to restrict ones freedom instead of 'just letting one do' things one know are correct or work anyway.

The restriction 'complaint' is correct, types \textit{do} restrict one and this is their main purpose because when these restrictions are used in a clever and appropriate way, they can be seen as an additional ingredient to programming which guide one in the program construction process by directing one and telling what is allowed and what is not. Well constructed programs and good libraries in strongly statically typed languages use types in exactly that way: to guide the programmer towards a better solution - by just looking at the types of a function one can derive very much about its intended use. It is almost always the case that when you are trying to work around the types, you are making a mistake.

In general, types guide us in program construction by restricting the operations we can perform on the data. This means that by choosing types this reveals already a lot of our program and data and prevents us from making mistakes e.g. interpreting some binary data as text instead of a number. In strongly statically typed languages the types can do this already at compile time which allows to rule out certain bugs already at compile time. In general, we can say that for all bugs which can be ruled out at compile time, we don't need to write property- or unit-tests for them, because those bugs cannot - per definition - occur at run-time, so it won't make sense to test their absence at run-time. Also, as Dijkstra famously put it: "Testing shows the presence, not the absence of bugs" - thus by induction we can claim that compile time guarantees save us from a potentially infinite amount of testing.

Dependent types allow to push these guarantees to a new extreme where we can express nearly arbitrary complex guarantees at compile time because we can \textit{compute types at compile time}. The main requirement here is, that the computation is total. So dependent types go as far as seen as equivalent to mathematical proofs, which in the end allows to guarantee so much properties at compile time so as to make it unnecessary to run the program because the compilation already shows its correctness.

So short answer: types allow us to guarantee things at compile time which reduces the amount of testing considerably.

\paragraph{You said by implementing a few different models with your functional approach showed you that it is very possible. You didn't say how hard or weird it was to achieve this - have you compared it to the object-oriented approach?}
No I haven't compared it and I won't because there are hardly objective measures of how hard something is to implement in a paradigm. One could use the length of the program (Lines Of Code LoC) as a measure but then clearly the functional approach would win as functional code tends to be much shorter than object-oriented one with up to an order of magnitude.

Also I can pose a fundamentally challenging view: why should the object-oriented be regarded as the easier/better one? Just because oo is the established method doesn't make it the easier one, it hasn't really proved itself on an objective level that it is easier / less weird. Also I claim that some object-oriented constructs are VERY weird and VERY hard to get right (patterns, data-dependencies, inheritance, is-a vs. has-a, composition) without lots of experience.

\paragraph{So I am a bit confused... what is then your PhDs unique contribution to knowledge?}
I see my unique contribution as two-fold. First, I did systematic research on \textit{how} to implement agent-based simulation in functional programming. Second I did systematic research on \textit{why} this approach is of benefit and should be used. The first step was necessary because there existed barely no research systematically investigating functional programming in agent-based simulation \footnote{There exist a few papers, see my paper in Appendix \ref{app:pfe}, but all just scratched the surface without really doing an in-depth systematic research like I did.}. This meant I had to kind of \textit{lay down the field} and during this work the benefits and drawbacks became apparent, which are directly related to the functional programming paradigm. 
The second step followed natural out of the benefits which can be subsumed under the common category of \textit{increasing the correctness of the simulation}. I saw in the first step, that just by using the functional programming paradigm and by staying pure, we automatically got a number of benefits which made the simulation more likely to be correct. In this second step I wanted to explore this more in-depth and the obvious next step there was to bring in dependent types. 

So the first unique contribution was to systematically research \textit{how} to do pure functional agent-based simulation and its benefits and drawbacks - I basically \textit{laid down the field} as the first one.
The second unique contribution is to apply dependent types to ABS which brings very interesting benefits and additional correctness guarantees and reasoning capabilities - again I was the very first as well there.

\paragraph{To bring in dependent types doesn't seem as striking to me. Why didn't you stay in Haskell and pushed further there?}
Why isn't it striking? To me this was \textit{very} striking as dependent types are so very close to pure functional programming and a few concepts pop up already through language extensions in Haskell (e.g. GADTs). The whole story of selling pure functional programming to ABS is that we can guarantee much more at compile-time and reason about our code due to its declarativeness - dependent types allow to push this very much further, so it is the \textit{very} natural next step. Also to my joy absolutely no one has looked into using dependent types in ABS at all - literally no one, I couldn't find a single paper \footnote{No, the paper \cite{botta_functional_2011} doesn't count, although a very interesting idea and approach it is doing something very different than what I am doing.}.

\paragraph{So you say that dependent types make writing unit-/property-tests and testing in general obsolete?}
I never said that, and if you read the chapters on verification \& validation and on dependent types careful it is clear that we can never do without testing. If you need more pointing, then have a look at the very short section \ref{sec:dep_vav_deptypes}.

\paragraph{Why do you say that only languages like Haskell and Idris can deliver this? What about Lustre? What about Scala? What about Scheme?}
I never said that \textit{only} Haskell and Idris support my initial hypothesis but they are the languages I chose (see 1st year report why Haskell). I am sure we can approach ABS from a functional perspective using Lustre, Scala or Scheme as well but I am sure the approaches will be very different in each case and also as far as I know none of them (maybe except from Lustre) supports the concept of purity as Haskell and Idris does. Also none of them supports dependent types, which makes Idris superior \textit{in the context of my hypothesis}.

\paragraph{You always mention that object-orientation cannot to what you are doing with Haskell and Idris! C++ templates are a very powerful tool, and there is language \textit{fill in language of choice} which you haven't considered.}
First, I always addressed the \textit{established, state-of-the-art} object-oriented approaches used to implement agent-based simulation, which are without any doubt Java and Python. Especially Python is gaining huge momentum in the field of scientific computing because of its ease of use many people can learn it quickly. Second, my Ph.D. was never about comparing object-oriented to functional, this would be a waste of time. Yes sure, I am, somehow comparing the established way of ABS to my new functional approach but only conceptually and not on a technical level. Maybe we can achieve some of what functional programming can easily do with object-oriented techniques like templates and patterns but according to my experience (15yrs+ in various oo languages with 10+ years industry experience) it will be much more verbose and complex. And then there are things so far simply no object-oriented language can do: purity and dependent types. Period.

\paragraph{Why are you so critical about Phython? It is a great language and it is gaining momentum in the scientific computing community as you said! Surely it must be a good language if it is gaining popularity.}
Let me be crystal clear: I think Python is a detour for scientific computing. Also just because a language is popular doesn't mean its a good language - we know that companies can push languages as has been done with Java. Also I think it is quite ironic that a dynamically typed language which is quick and easy to use is gaining momentum in the field of scientific computing - to me that questions the aims of scientific computing: deliver correct results. For that we need good programmers, not many. For that we need programming languages in which we can reason about correctness and which allows us to encode guarantees already at compile time - something Python doesn't even have. This means that we need a high entry barrier to scientific computing: keep out the bad programmers and invite the good ones - Python is breaking down that barrier. Python for quick prototyping: Yes! for scientific computing: No!

\paragraph{Closing the gap between the model specification and its implementation? In ABS? Are you insane?}
Not at all. I believe that dependent types could allow us to do that. The question is whether we can really \textit{close} it in case of ABS, for now I am happy with just \textit{narrowing} the gap, and that is also formulated in the hypothesis of my Ph.D.