\chapter{Questions \& Answers}
\label{chap:qa}

TODO: update and adopt to 2nd year

In this chapter I give answers to anticipated questions and objections about my research direction and vision of doing pure functional ABS \footnote{They are not always posed in a dead-serious way but as it is a quite controversial topic - ABS should be done object-orientated after all huh? - I think it is appropriate. Also some objections were raised in exactly this way.}.

\paragraph{So you had this hypothesis, that pure functional programming and dependent types lead to simulation software which is more likely correct and is easier to verify and validate, right from the beginning?}
Not at all. I even had no deep knowledge of functional programming at the start of my PhD, I've just worked through the 1st edition of Grahams book "Programming in Haskell" and that's it. I had no clear understanding of purity, side-effects and Monads and I didn't know a bit about functional reactive programming. I knew that something like Dependent Types exist because Thorsten (2nd Supervisor) has sent me an email before the start of my PhD in which he pointed at Agda, so I started reading a bit about intuitionistic / constructivistic math, tried out a little bit of Agda but quickly gave up because it was way too far away (without really having mastered pure functional programming in Haskell, I believe it is nearly impossible / too difficult / makes no sense going into dependent types).
So in the beginning there was pure \textit{curiosity} about functional programming in combination with ABS because I knew nothing of FP at all and wanted to understand it (after getting bored by OO) and applying FP to ABS seemed so crazy (because everyone claims OO to be 'natural' for it) that it must be an extremely interesting challenge. I guess this is very often the case with research: there is 'just' curiosity in the beginning and then during the research process a hypothesis falls into place.

\paragraph{What is it with these weird dependent types? Why should we use them? Why are you so obsessed with strongly statically typed languages? How can we benefit from types? Aren't they just in our way?}
I understand that in the beginning when one learns a strong statically typed language, types seem often to get in ones way of doing things - it happened to me when I was learning Haskell and it is now the same issue as I am getting into Idris: types seem to restrict ones freedom instead of 'just letting one do' things one know are correct or work anyway.

The restriction 'complaint' is correct, types \textit{do} restrict one and this is their main purpose because when these restrictions are used in a clever and appropriate way, they can be seen as an additional ingredient to programming which guide one in the program construction process by directing one and telling what is allowed and what is not. Well constructed programs and good libraries in strongly statically typed languages use types in exactly that way: to guide the programmer towards a better solution - by just looking at the types of a function one can derive very much about its intended use. It is almost always the case that when you are trying to work around the types, you are making a mistake.

In general, Types guide us in program construction by restricting the operations we can perform on the data. This means that by choosing types this reveals already a lot of our program and data and prevents us from making mistakes e.g. interpreting some binary data as text instead of a number. In strongly statically typed languages the types can do this already at compile time which allows to rule out certain bugs already at compile time. In general, we can say that for all bugs which can be ruled out at compile time, we don't need to write property- or unit-tests for them, because those bugs cannot - per definition - occur at run-time, so it won't make sense to test their absence at run-time. Also, as Dijkstra famously put it: "Testing shows the presence, not the absence of bugs" - thus by induction we can claim that compile time guarantees save us from a potentially infinite amount of testing.

Dependent types allow to push these guarantees to a new extreme where we can express nearly arbitrary complex guarantees at compile time because we can \textit{compute types at compile time}. The main requirement here is, that the computation is total. So dependent types go as far as seen as equivalent to mathematical proofs, which in the end allows to guarantee so much properties at compile time so as to make it unnecessary to run the program because the compilation already shows its correctness.

So short answer: types allow us to guarantee things at compile time which reduces the amount of testing considerably.