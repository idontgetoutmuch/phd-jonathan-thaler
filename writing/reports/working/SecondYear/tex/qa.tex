\chapter{Questions \& Answers}
\label{chap:qa}

In this chapter I give answers to anticipated questions and objections about my research direction and vision of doing pure functional ABS \footnote{They are not always posed in a dead-serious way but as it is a quite controversial topic - ABS should be done object-orientated after all huh? - I think it is appropriate. Also some objections were raised in exactly this way.}.

\paragraph{So you had this hypothesis, that pure functional programming and dependent types lead to simulation software which is more likely correct and is easier to verify and validate, right from the beginning?}
Not at all. I even had no deep knowledge of functional programming at the start of my PhD, I've just worked through the 1st edition of Grahams book "Programming in Haskell" and that's it. I had no clear understanding of purity, side-effects and Monads and I didn't know a bit about functional reactive programming. I knew that something like Dependent Types exist because Thorsten (2nd Supervisor) has sent me an email before the start of my PhD in which he pointed at Agda, so I started reading a bit about intuitionistic / constructivistic math, tried out a little bit of Agda but quickly gave up because it was way too far away (without really having mastered pure functional programming in Haskell, I believe it is nearly impossible / too difficult / makes no sense going into dependent types).
So in the beginning there was pure \textit{curiosity} about functional programming in combination with ABS because I knew nothing of FP at all and wanted to understand it (after getting bored by OO) and applying FP to ABS seemed so crazy (because everyone claims OO to be 'natural' for it) that it must be an extremely interesting challenge. I guess this is very often the case with research: there is 'just' curiosity in the beginning and then during the research process a hypothesis falls into place.

\paragraph{What is it with these weird dependent types? Why should we use them? Why are you so obsessed with strongly statically typed languages? How can we benefit from types? Aren't they just in our way?}
I understand that in the beginning when one learns a strong statically typed language, types seem often to get in ones way of doing things - it happened to me when I was learning Haskell and it is now the same issue as I am getting into Idris: types seem to restrict ones freedom instead of 'just letting one do' things one know are correct or work anyway.

The restriction 'complaint' is correct, types \textit{do} restrict one and this is their main purpose because when these restrictions are used in a clever and appropriate way, they can be seen as an additional ingredient to programming which guide one in the program construction process by directing one and telling what is allowed and what is not. Well constructed programs and good libraries in strongly statically typed languages use types in exactly that way: to guide the programmer towards a better solution - by just looking at the types of a function one can derive very much about its intended use. It is almost always the case that when you are trying to work around the types, you are making a mistake.

In general, Types guide us in program construction by restricting the operations we can perform on the data. This means that by choosing types this reveals already a lot of our program and data and prevents us from making mistakes e.g. interpreting some binary data as text instead of a number. In strongly statically typed languages the types can do this already at compile time which allows to rule out certain bugs already at compile time. In general, we can say that for all bugs which can be ruled out at compile time, we don't need to write property- or unit-tests for them, because those bugs cannot - per definition - occur at run-time, so it won't make sense to test their absence at run-time. Also, as Dijkstra famously put it: "Testing shows the presence, not the absence of bugs" - thus by induction we can claim that compile time guarantees save us from a potentially infinite amount of testing.

Dependent types allow to push these guarantees to a new extreme where we can express nearly arbitrary complex guarantees at compile time because we can \textit{compute types at compile time}. The main requirement here is, that the computation is total. So dependent types go as far as seen as equivalent to mathematical proofs, which in the end allows to guarantee so much properties at compile time so as to make it unnecessary to run the program because the compilation already shows its correctness.

So short answer: types allow us to guarantee things at compile time which reduces the amount of testing considerably.

\paragraph{You said by implementing a few different models with your functional approach showed you that it is very possible. You didn't say how hard or weird it was to achieve this - have you compared it to the object-oriented approach?}
No I haven't compared it and I won't because there are hardly objective measures of how hard something is to implement in a paradigm. One could use the length of the program (Lines Of Code LoC) as a measure but then clearly the functional approach would win as functional code tends to be much shorter than object-oriented one with up to an order of magnitude.

Also I can pose a fundamentally challenging view: why should the object-oriented be regarded as the easier/better one? Just because oo is the established method doesn't make it the easier one, it hasn't really proved itself on an objective level that it is easier / less weird. Also I claim that some object-oriented constructs are VERY weird and VERY hard to get right (patterns, data-dependencies, inheritance, is-a vs. has-a, composition) without lots of experience.

\paragraph{So I am a bit confused... what is then your PhDs unique contribution to knowledge?}
I see my unique contribution as two-fold. First, I did systematic research on \textit{how} to implement agent-based simulation in functional programming. Second I did systematic research on \textit{why} this approach is of benefit and should be used. The first step was necessary because there existed barely no research systematically investigating functional programming in agent-based simulation \footnote{There exist a few papers, see my paper in \ref{app:pfe}, but all just scratched the surface without really doing an in-depth systematic research like I did.}. This meant I had to kind of \textit{lay down the field} and during this work the benefits and drawbacks became apparent, which are directly related to the functional programming paradigm. 
The second step followed natural out of the benefits which can be subsumed under the common category of \textit{increasing the correctness of the simulation}. I saw in the first step, that just by using the functional programming paradigm and by staying pure, we automatically got a number of benefits which made the simulation more likely to be correct. In this second step I wanted to explore this more in-depth and the obvious next step there was to bring in dependent types. 

So the first unique contribution was to systematically research \textit{how} to do pure functional agent-based simulation and its benefits and drawbacks - I basically \textit{laid down the field} as the first one.
The second unique contribution was to apply dependent types to ABS which brings very interesting benefits and additional correctness guarantees and reasoning capabilities - again I was the very first as well there.

\paragraph{To bring in dependent types doesn't seem as striking to me. Why didn't you stay in Haskell and pushed further there?}
Why isn't it striking? To me this was \textit{very} striking as dependent types are so very close to pure functional programming and a few concepts pop up already through language extensions in Haskell (e.g. GADTs). The whole story of selling pure functional programming to ABS is that we can guarantee much more at compile-time and reason about our code due to its declarativeness - dependent types allow to push this very much further, so it is the \textit{very} natural next step. Also to my joy absolutely no one has looked into using dependent types in ABS at all - literally no one, I couldn't find a single paper \footnote{No, the paper \cite{botta_functional_2011} doesn't count, although a very interesting idea and approach it is doing something very different than what I am doing.}.