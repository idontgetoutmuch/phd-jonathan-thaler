\chapter{Introduction}
\label{chap:intro}

\section{Background}
Computer simulation is the means of imitating real-world processes over time through computational means \cite{banks_discrete-event_2013}. It is used for a vast number of purposes, most prominently to study effects of varying conditions when testing a real system is not feasible either because it is too dangerous or the system does not exist under such isolated circumstances or the analytical solution is not tractable \cite{sokolowski_principles_2009}. Naturally there are many different types of simulations and we focus in this thesis on Agent-Based Modelling and Simulation (ABMS \footnote{This abbreviation incorporates both the Modelling and Simulation aspect. When focusing only on the simulation the abbreviation ABS is used and when focusing on modelling ABM is used.}) which is a method for simulating the emergent behaviour of a system by modelling and simulating the interactions of its sub-parts, called agents \cite{siebers_introduction_2008}, \cite{axelrod_guide_2006}, \cite{wilensky_introduction_2015}. Examples for an ABS is simulating the spread of an epidemic throughout a population or simulating the dynamics of segregation within a city. Epstein \cite{epstein_generative_2012} identifies ABS to be especially applicable for analysing \textit{"spatially distributed systems of heterogeneous autonomous actors with bounded information and computing capacity"}. Central to ABS is the concept of an agent who needs to be updated in regular intervals during the simulation so it can interact with other agents and its environment.
We understand ABS as a method of modelling and simulating a system where the global behaviour may be unknown but the behaviour and interactions of the parts making up the system is known. Those parts, called agents, are modelled and simulated out of which then the aggregate global behaviour of the whole system emerges. So the central aspect of ABS is the concept of an agent which can be understood as a metaphor for a pro-active unit, situated in an environment, able to spawn new agents and interacting with other agents in a network of neighbours by exchange of messages \cite{wooldridge_introduction_2009}.

We informally assume the following about our agents \cite{wooldridge_intelligent_1995}:

\begin{itemize}
	\item They are uniquely addressable entities with some internal state.
	\item They can initiate actions on their own e.g. change their internal state, send messages, create new agents, kill themselves.
	\item They can react to messages they receive with actions as above.
	\item They can interact with an environment they are situated in.
\end{itemize} 

It is important to note that we focus our understanding of ABS on a very specific kind of agents where the focus is on communicating entities with individual, localized behaviour from out of which the global behaviour of the system emerges. This explicit distinction is necessary as to not confuse our concept of \textit{agent} with those of the field of Multi-Agent Systems (MAS). ABS and MAS influence each other in the way that the basic concept of an agent is very similar but the areas of application are fundamentally different. MAS is primarily used as an engineering approach to organize large software-systems \cite{weiss_multiagent_2013} where ABS is primarily used for the simulation of collective behaviour of agents to gain insight into the dynamics of a system \cite{dawson_opening_2014}.

ABS is a method and thus always applied in a very specific domain in which phenomenon are being researched which can be mapped to collective behaviour. This implies that we need to select a specific domain in which we want to advance the methodology of ABS. Being a vastly diverse, and inherently interdisciplinary research domain \cite{niazi_agent-based_2011}, for our PhD we pick the fields of Agent-Based Social Sciences (ABSS) and Agent-Based Computational Economics (ACE). The former one is traditionally a highly interdisciplinary field \cite{axelrod_chapter_2006}, drawing on lots of different other areas like economics, epidemology, genetics, neurocognition, biology. It is still a young field, having emerged in the 1990's but is constantly growing and gaining significance \cite{axelrod_advancing_1997}. It offers the new approach of \textit{generative} social sciences in which one tries to generate phenomenon by e.g. constructing artificial societies or introducing neurocognition to test hypotheses \cite{epstein_growing_1996}, \cite{epstein_agent_zero:_2014}.
ACE follows basically the same approach but in the field of economics to study economic processes as dynamic systems of interacting agents \cite{tesfatsion_agent-based_2006}. ACE is regarded to offer a new approach to economics, much closer to reality as compared to neo-classical economics which today forms much of the underlying theory of economy. The neo-classical approach follows a top-down approach by postulating equilibrium-properties about systems and trying to fit the agents into this framework. This generally leads to agents as being homogenous, having perfect information and acting rational \cite{kirman_complex_2010}. On the one hand this approach allows to treat the problems analytically but on the other hand poses little resemblance to reality. A major critique to neo-classical economics is that it is both non-constructive and uncomputable \cite{velupillai_unreasonable_2005}.
ACE on the other hand allows a constructive approach and is computable by its very nature, by following a bottom-up process in which the agents are heterogenous, have only local information at hand, act with bounded rationality and interact continuously with each other \cite{tesfatsion_modeling_2017}, \cite{kirman_complex_2010}. This allows ACE to study economic systems which are not in equilibrium and makes it possible to investigate whether they reach equilibrium or not and under which conditions the equilibrium is reached. This shows, that the study of out-of-equilibrium models is also one of the main fields ACE, and ABS in general is suited for \cite{epstein_generative_2012}.

\section{Problem}
The challenges one faces when specifying and implementing an ABS are manifold:

\begin{itemize}
	\item How is an agent represented?
	\item How do agents pro-actively act?
	\item How do agents interact?
	\item How is the environment represented?
	\item How can agents act on the environment?
	\item How to handle structural dynamism: creation and removal of agents?
\end{itemize}

Epstein \& Axtell explicitly advocate object-oriented programming in \cite{epstein_growing_1996} as "a particularly natural development environment for Sugarscape \cite{epstein_growing_1996} specifically and artificial societies generally." and report about 20.000 lines of code which includes GUI, graphs and plotting. They implemented their Sugarscape software in Object Pascal and C where they used the former for programming the agents and the latter for low-level graphics \cite{axtell_aligning_1996}. Axelrod \cite{axelrod_advancing_1997} recommends Java for experienced programmers and Visual Basic for beginners. Up until now most of ABS seems to have followed this suggestion and are implemented using programming languages which follow the object-oriented imperative paradigm.
The main concept in this paradigm are objects which provide abstraction, hiding implementation details and expose an abstract interface to the user of the object who does not (and should not) make any assumptions about implementation details. So in this paradigm the program consists of an implicit, global mutable state which is spread across multiple objects. 

Although object-oriented programming was invented to give programmers a better way of composing their code, strangely objects ultimately do \textit{not} compose \cite{bill_what_2017}, \cite{erkki_lindpere_why_2013}. The reason for this is that objects hide both \textit{mutation} and \textit{sharing through pointers or references} of object-internal data. This makes data-flow mostly implicit due to the side-effects on the mutable data which is globally scattered across objects. To deal with the problem of composability and implicit data-flow the seminal work \cite{gamma_design_1994} put forward the use of \textit{patterns} to organize objects and their interaction. Other concepts, trying to address the problems, were the SOLID principles and Dependency Injection. Although a huge step in the right direction, these concepts come with a very heavy overhead, are often difficult to understand and to apply and don't solve the fundamental problem \cite{lawrence_krubner_object_2014}. To put it short: even for experienced programmers, proper object-oriented programming \textit{is hard}. The difficulty arises from how to split up a problem into objects and their interactions and controlling the implicit mutation of state which is spread across all objects. Still if one masters the technique of object-oriented program-design and implementation, due to the implicit global mutable state bugs due to side-effects are the daily life of a programmer as shown below. Note that this critique of object-oriented programming addresses the deficits of this paradigm as it is implemented and in use today in languages likes Java and C++. The original idea of object-orientation, invented by Alan Kay \footnote{\url{http://wiki.c2.com/?AlanKaysDefinitionOfObjectOriented}} was very different than today and has much more common with the Actor Model as will be discussed in the literature-review.
Another serious problem of object-oriented implementations is the blurring of the fundamental difference between agent and object - an agent is first of all a metaphor and \textit{not} an object. In object-oriented programming this distinction is obviously lost as in such languages agents are implemented as objects which leads to the inherent problem that one automatically reasons about agents in a way as they were objects - agents have indeed become objects in this case. The most notable difference between an agent and an object is that the latter one do not encapsulate behaviour activation \cite{jennings_agent-based_2000} - it is passive. Also it is remarkable that \cite{jennings_agent-based_2000} a paper from 1999 claims that object-orientation is not well suited for modelling complex systems because objects behaviour is too fine granular and method invocation a too primitive mechanism.

In \cite{axelrod_chapter_2006} Axelrod reports the vulnerability of ABS to misunderstanding. Due to informal specifications of models and change-requests among members of a research-team bugs are very likely to be introduced. He also reported how difficult it was to reproduce the work of \cite{axelrod_convergence_1995} which took the team four months which was due to inconsistencies between the original code and the published paper. The consequence is that counter-intuitive simulation results can lead to weeks of checking whether the code matches the model and is bug-free as reported in \cite{axelrod_advancing_1997}.
The same problem was reported in \cite{ionescu_dependently-typed_2012} which tried to reproduce the work of Gintis \cite{gintis_emergence_2006}. In his work Gintis claimed to have found a mechanism in bilateral decentralized exchange which resulted in walrasian general equilibrium without the neo-classical approach of a tatonement process through a central auctioneer. This was a major break-through for economics as the theory of walrasian general equilibrium is non-constructive as it only postulates the properties of the equilibrium \cite{colell_microeconomic_1995} but does not explain the process and dynamics through which this equilibrium can be reached or constructed - Gintis seemed to have found just this process. Ionescu et al. \cite{ionescu_dependently-typed_2012} failed and were only able to solve the problem by directly contacting Gintis which provided the code - the definitive formal reference. It was found that there was a bug in the code which led to the "revolutionary" results which were seriously damaged through this error. They also reported ambiguity between the informal model description in Gintis paper and the actual implementation.
This lead to a research in a functional framework for agent-based models of exchange as described in \cite{botta_functional_2011} which tried to give a very formal functional specification of the model which comes very close to an implementation in Haskell.
This was investigated more in-depth in the thesis by \cite{evensen_extensible_2010} who got access to Gintis code of \cite{gintis_emergence_2006}. They found that the code didn't follow good object-oriented design principles (all was public, code duplication) and - in accordance with \cite{ionescu_dependently-typed_2012} - discovered a number of bugs serious enough to invalidate the results. This reporting seems to confirm the above observations that proper object-oriented programming is hard and if not carefully done introduces bugs.
The author of this text can report the same when implementing \cite{epstein_growing_1996}. Although the work tries to be much more clearer in specifying the rules how the agents behave, when implementing them still some minor inconsistencies and ambiguities show up due to an informal specification.
The fundamental problems of these reports can be subsumed under the term of verification which is the checking whether the implementation matches the specification. Informal specifications in natural language or listings of steps of behaviour will notoriously introduce inconsistencies and ambiguities which result in wrong implementations - wrong in the way that the \textit{intended} specification does not match the \textit{actual} implementation. To find out whether this is the case one needs to verify the model-specification against the code. This is a well established process in the software-industry but has not got as much attention and is not nearly as well established and easy in the field of ABS as will become evident in the literature-review.
As ABS is almost always used for scientific research, producing often break-through scientific results as pointed out in \cite{axelrod_chapter_2006}, these ABS need to be \textit{free of bugs}, \textit{verified against their specification}, \textit{validated against hypotheses} and ultimately be \textit{reproducible}. One of the biggest challenges in ABS is the one of validation. In this process one needs to connect the results and dynamics of the simulation to initial hypotheses e.g. \textit{are the emergent properties the ones anticipated? if it is completely different why?}. It is important to understand that we always \textit{must have} a hypothesis regarding the outcome of the simulation, otherwise we leave the path of scientific discovery. We must admit that sometimes it is extremely hard to anticipate \textit{emergent patterns} but still there must be \textit{some} hypothesis regarding the dynamics of the simulation otherwise we drift off into guesswork.

In the concluding remarks of \cite{axelrod_chapter_2006} Axelrod explicitly mentions that the ABS community should converge both on standards for testing the robustness of ABS and on its tools. However as presented above, we can draw the conclusion that there seem to be some problems the way ABS is done so far. We don't say that the current state-of-the-art is flawed, which it is not as proved by influential models which are perfectly sound, but that it always contains some inherent danger of embarrassing failure.

\section{Motivation}
The observations of the problems presented in the previous section leads us to posing fundamental directions and questions which are the basis of the motivation of our thesis.

\begin{enumerate}
	\item \textbf{Alternative approach to object-oriented ABS} - Is there an alternative view to the established object-oriented view to ABS which does treat agents \textit{not} like objects and does not mix the concept of agent and object? Is there an alternative to the established object-oriented implementation approach to ABS which offers composability, explicit data-flow?
	\item \textbf{Verification \& Validation of ABS} - Is there a way for formal specification and verification which is still readable and does not fall back to pure mathematics? What exactly is the meaning of validation in ABS and is there a way to do formal validation in ABS? 
\end{enumerate}