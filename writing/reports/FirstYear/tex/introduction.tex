\chapter{Introduction}
\label{chap:intro}

\section{Background}
Agent-based simulation and modelling (ABS) is a method for simulating the emergent behaviour of a system by modelling and simulating the interactions of its sub-parts, called agents. Examples for an ABS is simulating the spread of an epidemic throughout a population or simulating the dynamics of segregation within a city. Central to ABS is the concept of an agent who needs to be updated in regular intervals during the simulation so it can interact with other agents and its environment.
We understand ABS as a method of modelling and simulating a system where the global behaviour may be unknown but the behaviour and interactions of the parts making up the system is known. Those parts, called agents, are modelled and simulated out of which then the aggregate global behaviour of the whole system emerges. So the central aspect of ABS is the concept of an agent which can be understood as a metaphor for a pro-active unit, situated in an environment, able to spawn new agents and interacting with other agents in a network of neighbours by exchange of messages \cite{wooldridge_introduction_2009}. 

We informally assume the following about our agents:

\begin{itemize}
	\item They are uniquely addressable entities with some internal state.
	\item They can initiate actions on their own e.g. change their internal state, send messages, create new agents, kill themselves.
	\item They can react to messages they receive with actions as above.
	\item They can interact with an environment they are situated in.
\end{itemize} 

It is important to note that we focus our understanding of ABS on a very specific kind of agents where the focus is on communicating entities with individual, localized behaviour from out of which the global behaviour of the system emerges. This explicit distinction is necessary as to not confuse our concept of \textit{agent} with those of other fields like Multi Agent Systems (MAS) and AI \& Kybernetics. Especially ABS and MAS influence each other in the way that the basic concept of an agent is very similar but the areas of application are fundamentally different. MAS is primarily used as an engineering approach to organize large software-systems where ABS is primarily used for the simulation of collective behaviour of agents to gain insight into the dynamics of a system.

ABS is a method and tool and thus always applied in a very specific domain in which phenomenon are being researched which can be mapped to collective behaviour. This implies that we need to select a specific domain in which we want to advance the methodology of ABS. For our PhD we picked the field of Agent-Based Computational Social Sciences (ACS) which is traditionally a highly interdisciplinary field \cite{axelrod_chapter_2006}, drawing on lots of different other areas like economics, epidemology, genetics, neurocognition, biology. As the primary sources we selected the works of Epstein and Axtell in \cite{epstein_growing_1996}, \cite{epstein_generative_2012} and \cite{epstein_agent_zero:_2014} which are fundamentally rooted in ACS but are highly interdisciplinary.
Another field we are particularly interested in, the simulation of decentralized bilateral bartering, which belongs to the field of Agent-Based Computational Economics (ACE) \cite{tesfatsion_agent-based_2006} is covered in one of the cited works \cite{epstein_growing_1996}. This lucky coincidence let us approach both these very special fields together and apply them as the fundamental use cases for developing our new methods as presented in the next section.

\section{Motivation}
Epstein \& Axtell explicitly advocate object-oriented programming in \cite{epstein_growing_1996} as "a particularly natural development environment for Sugarscape specifically and artificial societies generally." and report about 20.00 lines of code which includes GUI, graphs and plotting. The challenges one faces when specifying and implementing an ABS is manifold:

\begin{itemize}
	\item How is an agent represented?
	\item How do agents pro-actively act?
	\item How do agents interact?
	\item How is the environment represented?
	\item How can agents act on the environment?
	\item How to handle structural dynamism: creation and removal of agents?
\end{itemize}

Up until now most of ABS (if not all) is implemented using programming languages which follow the imperative paradigm be it either structural or object-oriented. This implies a global implicit state with functions / methods being called from other functions / objects. 

In \cite{axelrod_chapter_2006} Axelrod reports the vulnerability of ABS to misunderstanding. Due to informal specifications of models and change-requests among members of a research-team bugs are very likely to be introduced. He also reported how difficult it was to reproduce the work of Axtell on cultural transmission which took the team four months which was due to inconsistencies between the original code and the published paper. This is explained in much more detail in \cite{axtell_aligning_1996}, TODO: read


The same problem was reported by ionescou in TODO: cite which tried to reproduce the work of gintis. In his work Gintis claimed to have found a break-through in economics: TODO. When a team tried to reproduce the results in TODO: cite they failed and were only able to solve the problem by directly contacting Gintis which provided the code - the ultimate formal reference. It was found that there was a bug in the code which led to the "revolutionary" results which would have not occured without this bug.  

The author of this text can report the same when implementing \cite{epstein_growing_1996}. Although this work tries to be much more clearer in specifying the rules how the agents behave, when implementing them still some minor inconsistencies and ambiguities show up due to an informal specification.

Specification: how is my model specified?
informal specifications in natural language or listings of steps of behaviour will notoriously introduce inconsistencies and ambiguities which result in wrong implementations: wrong in the way that the \textit{intended} specification does not match the actual implementation. 

Implementation:
object-oriented programming paradigm: the effort to manage implicit global state which can be changed through effectful computations (side-effects) increases exponentially with the complexity of the system one implements. This can only be held at bay through the proper usage of patterns \cite{gamma_design_1994} and experience - to put it short: object-oriented programming is hard where the difficulty arises in how to split up a problem into objects and their interactions. Another serious problem of oo implementations is that a blurring of fundamental difference between agent and object occurs - an agent is first of all a metaphor, it is \textit{not} an object.

Verification:  does my implementation really match my specification? 
To find out this we need to use verification of the model against the code. Verification is an established approach for in software systems and although it is hard it is being done for software which needs to meet high standards e.g. Medicine, Power Plant,... 

Validation: how to connect the results to the hypothesis? are the emergent properties the ones anticipated? if it is completely different why? note: we always MUST HAVE a hypothesis regarding the outcome of the simulation, otherwise we leave the path of scientific discovery. But we must admit that sometimes it is extremely hard to anticipate \textit{emergent patterns}. But anyway there must be \textit{some} hypothesis regarding the dynamics of the simulation.

As ABS is almost always used for scientific research, producing often break-through scientific results as pointed out in \cite{axelrod_chapter_2006}, these ABS need to be \textit{free of bugs}, \textit{verified against their specification}, \textit{validated against hypotheses} and ultimately be \textit{reproducable}. In the concluding remarks of \cite{axelrod_chapter_2006} Axelrod explicitly mentions that the ABS community should converge both on standards for testing the robustness of ABS and on its tools. However as presented above, we can draw the conclusion that there seems to be some problems the way ABS are specified and implemented so far. We don't say that the current approach is completely flawed as proofed by influential modells which are perfectly sound but that it always contains some inherent danger of embarassing failure. In this thesis we want to propose a new tool for both implementing and testing ABS: the one of pure functional programming. We claim that the danger of failure can be reduced considereably or even eliminated by proposing a paradigm-shift towards \textit{pure functional methods} as explained in the next section.

\section{Pure functional Methods in ABS}
TODO: we need to be able to argue that pure functional methods (pure functional programming, EDSL = specification, category-theory as specification / underlying theory) solve or at least diminish the above mentioned problems and propose a real alternative to oo/effectful computation methods. This is one of the major research questions of my thesis: "do pure functional methods improve the ".
TODO: of course our motivation is not only the one of verification/validation/reproduceability but also the one of discovery: so far pure functional programming was not really investigated in the context of ABS. Thus this thesis is also an investigation how ABS can be done in a pure functional language. 

WHY FUNCTIONAL? "because its the ultimate approach to scientific computing": fewer bugs due to mutable state (why? is thos shown obkectively by someone?), shorter (again as above, productivity), more expressive and closer to math, EDSL, EDSL=model=simulation, better parallelising due to referental transparency, reasoning 

The central aspect of this thesis is centred around the main question of \textit{How Agent-Based Simulation can be done using pure functional programming and what the benefits and disadvantages are.}. So far functional programming has not got much attention in the field of ABS and implementations always focus on the object-oriented approach. We claim, based upon the research of the first year that functional programming is very well suited for ABS and that it offers methods which are not directly possible and only very difficult to achieve with object-oriented programming.

We claim that to build large and complex agent-based simulations in functional programming is possible using the functional reactive programming (FRP) paradigm. We applied FRP to implementing ABS and developed a library in Haskell called FrABS. We implemented the quite complex model SugarScape from social simulation using FrABS and proofed by that, that applying FRP to ABS enables ABS to happen in pure functional programming.

After having shown how agent-based simulation can be done in functional programming we claim that the major benefit of using it enabled a new way of \textit{verification \& validation} in agent-based simulation. 

Due to the declarative nature of pure functional programming it is an established method of implementing an EDSL to solve a given problem in a specific domain. We followed this approach in FrABS and developed an EDSL for ABS in pure functional programming. Our intention was to develop an EDSL which can be used both as specification- and implementation-language. We show this by specifying all the rules of SugarScape in our EDSL.

Due to the lack of implicit side-effects and the recursive nature of pure functional programming we claim that it is natural to apply it to a novel method we came up with: MetaABS, which allows recursive simulation.

Finally having such an EDSL at hand this will allow us to reason about the programs. This will be applied to specify and reason about the dynamics and emergent properties of decentralized bilateral trading and bartering in agent-based computational economics (ACE) and social simulations like SugarScape.

Disadvantages
- although the lack of side-effects is also a benefit, it is also a weakness as all data needs to be passed in and out explicitly 
- indirection due to the lack of objects \& method calls.
- When not to use it: 
	- if you are not familiar with functional programming
	- when you can solve your problem without programming in a Tool like NetLogo, AnyLogic,...
	- when you don't need to reason about your program
	
Functional approach to Agent-Based Modelling \& Simulation
Because we left the path of OO and want to develop a completely different method we have fundamentally two problems to solve in our functional method:
1. Specifying the Agent-Based Model (ABM): Category-Theory, Type-Theory, EDSL: all this clearly overlaps with the  implementation-aspect because the theory behind pure functional programming in Haskell is exactly this. This is a very strong indication that functional programming may be able to really close the gap between specification and implementation in ABS.
2. Implementing the ABM into an Agent-Based Simulation (ABS): building on FRP paradigm

We show that the implicit assumption that an Agent is \textit{about equal to} an object is not correct and leads to many implicit assumptions in OO implementations of an ABS. When implementing ABS in Haskell these implicit assumptions become explicit and challenge the fundamental assumptions about ABS and Agents. We present these implicit assumption in an explicit way by approaching it through programming, type-theory and category-theory to further deepen the concepts and methods in the field of Agent-Based Modelling \& Simulation.

TODO: is it really valid to bind the sending of messages to the advancing of time?
Downside: we cannot have method-calls as in OO, which allows agents to communicate with each other without time advancing. 

Expected benefits
1. By mapping the concepts of ABS to Category-Theory and Type-Theory we gain a deeper understanding of the deeper structure of Agents, Agent-Models and Agent-Simulations.
2. The declarative nature of pure functional programming will allow to close the gap between specification and code by designing an EDSL for ABS in Haskell building on the previously derived abstractions in Category-Theory and Type-Theory. The abstractions and the EDSL implementation will then serve as a specification tool and at the same time code.
3. The pure functional nature together with the EDSL and abstractions in Category- \& Type-Theory allow for a new level of formal verification \& validation using a combination of mathematical proofs in Category- \& Type-Theory, algebraic reasoning in the EDSL and model-checking using Unit-Tests and QuickCheck. The expectation is that this allows us to formally specify hypotheses about expected outcomes about the dynamics (or emergent patterns) of our simulations which then can be verified.
	
	
	
	
	
	
	
	
	
	
	
	
I noticed that it is pretty hard to convince an agent-based economics specialist who is not a computer scientist about a pure functional approach. My conjecture is that the implementation technique and method does not matter much to them because they have very little knowledge about programming and are almost always self-taught - they don't know about software-engineering, nothing about proper software-design and architecture, nothing about software-maintenance, nothing about unit-testing,... In the end they just "hack" the simulation in whatever language they are able to: C++, Visual Basic, Java or toolboxes like Netlogo. For them it is all about to \textit{get things done somehow} and not to get things done the right way or in a beautiful way - the way and the method doesn't matter, its just a necessary evil which needs to be done. Thus if functional programming could make their lives easier, then they will definitely welcome it. But functional programming is, i think, harder to learn and harder to understand - so one needs to provide an abstraction through EDSL. So I REALLY need to come up with convincing arguments why to use pure functional approaches in ACE THEY can understand, otherwise I will be lost and not heard (not published,...). 

What ACE economists care for:

\begin{itemize}
\item Very: Qualitative modelling with quantitative results
\item Yes: Easy reproducibility
\item Likely: Reasoning about convergence?
\item Likely: EDSL
\end{itemize}

My contributions are: pure functional framework, functional agent-model for market-simulations, EDSL for market-simulations, qualitative / implicit modelling with quanitative results, reasoning in my framework about convergence \\

IDEA: could I develop non-causal modelling (models are expressed in terms of non-directed equations, modelled in signal-relations) to allow for qualitative modelling for the agent-based economists? See hybrid modelling paper of Yampa. \textbf{THIS WOULD BE A HUGE NOVEL CONTRIBUTION TO ACE ESPECIALLY WHEN COMBINED WITH AN EDSL AND PROVIDING FULL REFERENTIAL TRANSPARENCY TO KEEP THE ABILITY TO REASON ABOUT CONVERGENCE}. This should be covered in the "EDSL"-paper.

TODO: maybe i should really focus only on market models? otherwise too much? \\

central novelty of my PhD: model specification = runnable code. possible through EDSL. but only in specific subfield of ACE: market-models. need a functional description of the model, then translate it to model specification in EDSL and then run it to see dynamics. But: model specification moves closer to functional programming languages. \\

another novelty approach: model specification through qualitative instead of quantiative approaches. is this possible? \\



pure functional agent-model \& theory, EDSL framework in Haskell for ACE

\begin{enumerate}
\item Which kind of problem do we have?
\item What aim is there? Solving the problem? 
\item How the aim is achieved by enumerating VERY CLEAR objectives.
\item What the impact one expects (hypothesis) and what it is (after results).
\end{enumerate}

Note: It is not in the interest of the researcher to develop new economic theories but to research the use of functional methods (programming and specification) in agent-based computational economics (ACE).

NOTE: Get the reader’s attention early in the introduction: motivation, significance, originality and novelty.

Methods need to be selected to implement the simulations. Special emphasis will be put on functional ones which will then be compared to established methods in the field of ABM/S and ACE. \\

Claim: non-programming environments are considered to be not powerful enough to capture the complexity of ACE implementations thus a programming approach to ACE will be always required.


To apply and test functional methods in ACE, four scenarios of ACE are selected and then the methods applied and compared with each other to see how each of them perform in comparison. The 4 selected scenarios represent a selection of the challenges posed in ACE: from very abstract ones to very operational ones.

Each of the selected scenarios is then implemented using the selected methods where each solution is then compared against the following criteria: 

\begin{enumerate}
\item suitability for scientific computation
\item robustness
\item error-sources
\item testability
\item stability
\item extendability
\item size of code
\item maintainability
\item time taken for development
\item verification \& correctness
\item replications \& parallelism
\item EDSL
\end{enumerate}

This will then allow to compare the different methods against each other and to show under which circumstances functional methods shine and when they should not be used.