\chapter{Introduction}
\label{chap:intro}

\section{Background}
Agent-based simulation and modelling (ABS) is a method for simulating the emergent behaviour of a system by modelling and simulating the interactions of its sub-parts, called agents. Examples for an ABS is simulating the spread of an epidemic throughout a population or simulating the dynamics of segregation within a city. Central to ABS is the concept of an agent who needs to be updated in regular intervals during the simulation so it can interact with other agents and its environment.
We understand ABS as a method of modelling and simulating a system where the global behaviour may be unknown but the behaviour and interactions of the parts making up the system is known. Those parts, called agents, are modelled and simulated out of which then the aggregate global behaviour of the whole system emerges. So the central aspect of ABS is the concept of an agent which can be understood as a metaphor for a pro-active unit, situated in an environment, able to spawn new agents and interacting with other agents in a network of neighbours by exchange of messages \cite{wooldridge_introduction_2009}. 

We informally assume the following about our agents:

\begin{itemize}
	\item They are uniquely addressable entities with some internal state.
	\item They can initiate actions on their own e.g. change their internal state, send messages, create new agents, kill themselves.
	\item They can react to messages they receive with actions as above.
	\item They can interact with an environment they are situated in.
\end{itemize} 

It is important to note that we focus our understanding of ABS on a very specific kind of agents where the focus is on communicating entities with individual, localized behaviour from out of which the global behaviour of the system emerges. This explicit distinction is necessary as to not confuse our concept of \textit{agent} with those of other fields like Multi Agent Systems (MAS) and AI \& Cybernetics. Especially ABS and MAS influence each other in the way that the basic concept of an agent is very similar but the areas of application are fundamentally different. MAS is primarily used as an engineering approach to organize large software-systems where ABS is primarily used for the simulation of collective behaviour of agents to gain insight into the dynamics of a system.

ABS is a method and tool and thus always applied in a very specific domain in which phenomenon are being researched which can be mapped to collective behaviour. This implies that we need to select a specific domain in which we want to advance the methodology of ABS. For our PhD we picked the field of Agent-Based Computational Social Sciences (ACS) which is traditionally a highly interdisciplinary field \cite{axelrod_chapter_2006}, drawing on lots of different other areas like economics, epidemology, genetics, neurocognition, biology. As the primary sources we selected the works of Epstein and Axtell in \cite{epstein_growing_1996}, \cite{epstein_generative_2012} and \cite{epstein_agent_zero:_2014} which are fundamentally rooted in ACS but are highly interdisciplinary.
Another field we are particularly interested in, the simulation of decentralized bilateral bartering, which belongs to the field of Agent-Based Computational Economics (ACE) \cite{tesfatsion_agent-based_2006} is covered in one of the cited works \cite{epstein_growing_1996}. This lucky coincidence let us approach both these very special fields together and apply them as the fundamental use-cases for developing our new methods as presented in the next section.

\section{Motivation}
The challenges one faces when specifying and implementing an ABS are manifold:

\begin{itemize}
	\item How is an agent represented?
	\item How do agents pro-actively act?
	\item How do agents interact?
	\item How is the environment represented?
	\item How can agents act on the environment?
	\item How to handle structural dynamism: creation and removal of agents?
\end{itemize}

Epstein \& Axtell explicitly advocate object-oriented programming in \cite{epstein_growing_1996} as "a particularly natural development environment for Sugarscape specifically and artificial societies generally." and report about 20.000 lines of code which includes GUI, graphs and plotting. Up until now most of ABS seems to have followed this suggestion and are implemented using programming languages which follow the object-oriented imperative paradigm. In this paradigm the program consists of an implicit, global mutable state which is spread across multiple objects. Although the control-flow is explicit (with the exception of parallelism) where methods of objects are being called from other methods in objects, the data-flow is mostly implicit due to side-effects on the global mutable data.
It is established knowledge that the effort to manage implicit global state which can be changed through effectful computations (side-effects) increases exponentially with the complexity of the system one implements (TODO: find a citation). This can only be held at bay through the proper usage of patterns \cite{gamma_design_1994} and years of working-experience (TODO: find a citation). To put it short: proper object-oriented programming \textit{is hard} where the difficulty arises from how to split up a problem into objects and their interactions. Still if one masters the technique of object-oriented program-design and implementation, due to the implicit global mutable state bugs due to side-effects are the daily life of a programmer (TODO: find a citation). Another serious problem of object-oriented implementations is the blurring of the fundamental difference between agent and object - an agent is first of all a metaphor and \textit{not} an object. In object-oriented programming this distinction is obviously lost as in such languages agents are implemented as objects which leads to the inherent problem that one automatically reasons about agents in a way as they were objects - agents have indeed become objects in this case. TODO: what is the problem behind this?

In \cite{axelrod_chapter_2006} Axelrod reports the vulnerability of ABS to misunderstanding. Due to informal specifications of models and change-requests among members of a research-team bugs are very likely to be introduced. He also reported how difficult it was to reproduce the work of \cite{axelrod_convergence_1995} which took the team four months which was due to inconsistencies between the original code and the published paper. 
The same problem was reported in \cite{ionescu_dependently-typed_2012} which tried to reproduce the work of Gintis \cite{gintis_emergence_2006}. In his work Gintis claimed to have found a mechanism in bilateral decentralized exchange which resulted in walrasian general equilibrium without the neo-classical approach of a tatonement process through a central auctioneer. This was a major break-through for economics as the theory of walrasian general equilibrium is non-constructive as it only postulates the properties of the equilibrium \cite{colell_microeconomic_1995} but does not explain the process and dynamics through which this equilibrium can be reached or constructed - Gintis seemed to have found just this process. Ionescu et al. \cite{ionescu_dependently-typed_2012} failed and were only able to solve the problem by directly contacting Gintis which provided the code - the definitive formal reference. It was found that there was a bug in the code which led to the "revolutionary" results which were seriously damaged through this error. They also reported ambiguity between the informal model description in Gintis paper and the actual implementation.
This lead to a research in a functional framework for agent-based models of exchange as described in \cite{botta_functional_2011} which tried to give a very formal functional specification of the model which comes very close to an implementation in Haskell.
This was investigated more in-depth in the thesis by \cite{evensen_extensible_2010} who got access to Gintis code of \cite{gintis_emergence_2006}. They found that the code didn't follow good object-oriented design principles (all was public, code duplication) and - in accordance with \cite{ionescu_dependently-typed_2012} - discovered a number of bugs serious enough to invalidate the results. This reporting seems to confirm the above observations that proper object-oriented programming is hard and if not carefully done introduces bugs.
The author of this text can report the same when implementing \cite{epstein_growing_1996}. Although the work tries to be much more clearer in specifying the rules how the agents behave, when implementing them still some minor inconsistencies and ambiguities show up due to an informal specification.
The fundamental problems of these reports can be subsumed under the term of verification which is the checking whether the implementation matches the specification. Informal specifications in natural language or listings of steps of behaviour will notoriously introduce inconsistencies and ambiguities which result in wrong implementations - wrong in the way that the \textit{intended} specification does not match the \textit{actual} implementation. To find out whether this is the case one needs to verify the model-specification against the code. Verification is a required approach for software systems which needs to meet high standards e.g. Medicine, Power Plant (TODO: cite) but has so far not been undertaken for ABS (TODO: is this really the case?, look into literature)

As ABS is almost always used for scientific research, producing often break-through scientific results as pointed out in \cite{axelrod_chapter_2006}, these ABS need to be \textit{free of bugs}, \textit{verified against their specification}, \textit{validated against hypotheses} and ultimately be \textit{reproducible}. One of the biggest challenges in ABS is the one of validation. In this process one needs to connect the results/dynamics of the simulation to initial hypotheses e.g. \textit{are the emergent properties the ones anticipated? if it is completely different why?}. It is important to understand that we always \textit{must have} a hypothesis regarding the outcome of the simulation, otherwise we leave the path of scientific discovery. We must admit that sometimes it is extremely hard to anticipate \textit{emergent patterns} but still there must be \textit{some} hypothesis regarding the dynamics of the simulation otherwise it is just guesswork.

In the concluding remarks of \cite{axelrod_chapter_2006} Axelrod explicitly mentions that the ABS community should converge both on standards for testing the robustness of ABS and on its tools. However as presented above, we can draw the conclusion that there seem to be some problems the way ABS is done so far. We don't say that the current state-of-the-art is flawed, which it is not as proved by influential models which are perfectly sound, but that it always contains some inherent danger of embarrassing failure. These observations lead us to posing two fundamental directions which are the basis of the motivation of our thesis.

\begin{enumerate}
	\item \textbf{Alternative to object-orientation} - Is there an alternative to the established object-oriented approaching ABS which offers an explicit data-flow, reduces the bugs due to global mutable state and does not lead to the blurring of agent and object?
	\item \textbf{Verification \& Validation of ABS} - Is there a way for formal specification which is still readable and does not fall back to pure mathematics? Is there a way to formally specify hypotheses about the simulation which are then checked automatically against the results?
\end{enumerate}

As will become evident from the literature-review we advocate pure functional programming in Haskell and the type-theoretic and category-theoretic foundations as a solution to the questions posed. The usage of pure functional programming in ABS is also a strong motivation by itself as it hasn't been researched yet and deserves a thorough treatment on its own. Surprisingly there exist hardly any attempts on implementing ABS in pure functional programming as will become clear in the literature-research. Maybe this can also be seen as a hint that ABS lacks a level of formalism which we hope to repair with our thesis. 

So put short the motivations is a twofold direction, referring to each other in a circular way. First, pure functional programming has not been researched for implementing and specifying ABS so far. Second,  the current state-of-the-art seems to be susceptible to flaws and bugs due to the lack of powerful verification. Combining both issues forms the very basic motivation of our thesis: use pure functional programming and its underlying theoretical framework to develop new methods for specifying, implementing, verifying and validating ABS to create simulations which are more reliable, reproducible and communicatable.