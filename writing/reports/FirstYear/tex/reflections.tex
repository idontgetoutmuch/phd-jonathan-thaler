\chapter{Reflecting the Literature}
\label{chap:refl}

In this chapter we reflect the literature we have investigated in the previous chapter to identify a research-gap and derive a vision for our research which will be clarified in the next chapter on aims and objectives. When looking at the literature it seems that the relevant concepts for approaching the problems mentioned in the introduction are there, but that they are distributed over the various topics.

\section{Actor Model}
The core concept of the Actor Model is that actors are processes which have \textit{share nothing} semantics: there exist no aliases, through which actors can implicitly change the state of another actor through side-effects. The only means of interaction is through message passing in which case data is copied and nothing is shared. This approach guarantees an explicit data-flow with localized state and is the original vision Alan Kay had when he conceived object-orientation \footnote{See \url{http://wiki.c2.com/?AlanKaysDefinitionOfObjectOriented}} and exists in its most faithful implementation in Erlang \footnote{Although Scala also comes with an Actor-Library, it allows sharing by sending mutable messages and references thus violating the locality of state.}. Due to its share nothing semantics, actors are assumed to run in parallel, synchronizing only on messaging which would allow for a very high number of actors.

The core weakness is that message passing is asynchronous and inherently unreliable and that actors are only reactive. This is a very problem in ABS as it leads to non-reproducible simulations as the randomness does not rely on model-inherent properties like random-number generators but on exogenous parameters. As pointed out by \cite{jennings_agent-based_2000} on agent-based software-engineering, the problems are that patterns of the interactions are inherently unpredictable and that predicting the global system behaviour is extremely difficult. This observation is in unison with the results of my paper on update-strategies (see Appendix \ref{app:updateStrategies}) where we showed that a truly agent-based solution (actor-strategy) leads to non-deterministic results due to inherent concurrency. A truly concurrent implementation is only useful when the model-semantics are concurrent as well, where the ordering of events does not matter (as shown in the Heroes \& Cowards Game). This is very rarely the case thus an implementation of parallel or sequential semantics are favourable (and are sufficient when event-ordering does not matter).
Also the asynchronous nature of messaging makes it difficult to handle cases where synchronous messaging is required e.g. in trading between two agents. This would require to synchronize agents through a central auctioneer, thus rendering the parallelism advantage void. Besides, we don't have any model of a global time, which is almost always necessary in ABS and could only be introduced by a global time-agent, synchronizing all agents.

\section{Process Calculi \& DEVS}
Process calculi are nice for specifying and verifying concurrent computations but are too cumbersome to fully implement a complex ABS. You do not program a large system in the lambda calculus, as you would not program a real distributed system in a process calculus \footnote{It was shown by Milner \cite{milner_functions_1992} that the pi-calculus can encode the lambda calculus, thus it is conceptually on a very low level: too much raw power leads to chaos.}. On the other hand, process calculi are used in the industry for verification purpopses so they may be of use for verification \& validation later on of small, critical parts of the ABS-communication which can be mapped to e.g. the $\pi$-calculus and then apply algebraic reasoning. As emphasised in the literature-review, no research was found on using process-calculi in the field of ABS. Although we can reason that if the $\pi$-calculus can be used to specifying and reasoning about MAS then it should be possible to do so for ABS or parts of it. There exists also a connection from the actor-model to process calculi \cite{agha_foundation_1997}, which strengthen our argument. 
DEVS is, although of very different nature than process calculi, on the same low-level thus the same what we said about process calculi apply to DEVS as well.

\section{Agent Formalisms}
There exist a lot of agent formalisms in the field of multi-agent systems (MAS) which allow the formal and high-level specification of such a system. Some make use of low-level features like process calculi and algebraic reasoning. Our intention in this PhD is not to deliver a new agent formalism but to draw inspiration from them and bringing their strengths - a high-level specification of interacting agents - to a real programming language. 

\section{Pure Functional Programming}
As pointed out in the literature-review at length, the strengths of pure functional programming (as in Haskell) are manifold and overcome the problems of object-oriented programming we indicated in the introduction \footnote{This does not mean that it makes object-oriented programming obsolete or that it can be applied equally well to all domains which have been assumed to be classic object-oriented domains - here we are just interested in ABS and we claim the pure functional way is very well suited for it - see below. Although attempts exist in bringing pure functional programming to e.g. GUI- and Game-programming, we think that especially these two fields are better suited to object-orientation because in both fields side-effects are fundamental and pervasive in every aspect of the domain and thus utterly difficult to isolate in a pure-functional way (which also allows for high-performance, see below).}. The most powerful aspect is obviously its \textit{purity}: it is explicit about effects (through monads) and has thus an explicit data-flow. Its composability achieved through higher-order functions and laziness is superior to objects because of the loose coupling between data and code. The declarative style allows to easily implement EDSLs for a given problem which makes reasoning possible, also due to the lack of implicit side-effects. Finally the static type system is a powerful tool to create contracts and specifications in code which supports reasoning and increases correctness and can be seen as a form of additional documentation \footnote{Of course to some, a static type system is just an annoying obstacle in writing code, but when going in the direction of verification and validation, it is a mandatory tool and can not be left aside.}.

Of course pure functional programming has also its weaknesses. The main issue in a lazy functional programming language is the difficulty of predicting space behaviour, resulting in \textit{space-leaks}, which is very hard even for experienced programmers \cite{hudak_history_2007}. The problem arises from the fact, that Haskell abstracts away from evaluation order and object lifetimes. Programmers have no way to determine which data-structures live for how long - indeed they don't want and should not be bothered to think about these details as this would violate the whole concept behind pure lazyness \cite{hudak_history_2007}.
Due to the lazy evaluation and non-imperative programming style it becomes apparent that debugging needs to be approached completely different than in imperative programming where one can freely set breakpoints to statements and inspect data. This is not possible in Haskell as there are no imperative statements and the data may have not been evaluated yet due to the unpredictable evaluation order as mentioned already in the space-leak problem.
Due to the lack of side-effects and aliasing, efficient in-order updates of memory is not as easily possible as in imperative languages like C thus real-time applications like Games which have a big global mutable state run much slower compared to its imperative implementations  \cite{mun_hon_functional_2005}, \cite{meisinger_game-engine-architektur_2010} - the works on game-programming in Yampa mention a similar performance-problem.
As of 2007 \cite{hudak_history_2007} another weakness was composition of Monads: although monads are seen a benefit to pure functional programming by allowing to making side-effects explicit, so far multiple monads do not compose in a nice, modular way and this issue is still open research. This has changed since then a bit through the use of Monad-Transformers which allow to stack monads which allows to make functionality of monads further down the stack be available further up - an example would be the use of a State-Monad on top of IO.

\section{Combining}
Having reflected the approaches we can now derive what is needed for handling the problems mentioned in the introduction: we are combining the strengths of the approaches. From process-calculus, DEVS and agent formalisms we take the concept of a domain-specific language which allows to reason about the system and apply algebraic laws in manipulating it. Also we hope to make use of the $\pi$-calculus and DEVS for verification purposes although in which way precisely they can be made of use to ABS is unclear and will be part of the research. From the actor model we take the concept of processes which interact with each other by shared-nothing messaging.
When applying these to pure functional programming in Haskell we arrive at an ideal combination. The purity allows us to implement deterministic, synchronized and reliable messaging with shared-nothing semantics. The declarative nature and its static type-system allows us to implement an EDSL inspired by the actor model and the formalisms mentioned above. Building on top of a FRP library like Yampa gives us the necessary time-semantics for ABS and allows us to formulate agents as processes, implemented as signal-functions (see chapter on functional reactive ABS).

\section{Identifying the Gap}
Functional programming in this area exists but only scratches the surface and focus only on implementing agent-behaviour frameworks like BDI and focus only on MAS. An in-depth treatise of agent-based modelling and implementing an agent-based simulation in a pure functional language has so far never been attempted. Also there basically exists no approach to ABS in terms of category-theory which form the basis of pure functional programming.