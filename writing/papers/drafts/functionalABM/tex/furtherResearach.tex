\section{Further Research}

\subsection{Multi-Step Conversations}
The communication in this simulation is single-step unidirectional: in each step of the simulation an agent looks at the position of the enemy and friend and updates its position, there is no conversation going on between the agent and its friend and enemy thus making it single-step and unidirectional because the whole information flow is initiated from one agent and no response is given. This is becomes kind of relaxed in the Scala implementation but is still basically unidirectional and single-step - the agents don't engage in a conversation. In many ABM/S models this is perfectly reasonable because many of the models work this way but when having e.g. bartering processes like in agent-based computational economics (ACE) where agents have a conversation with multiple asks and bids to find a price they are happy with, this method becomes obviously too restricted. \\ The author investigates exactly this problem in an additional paper, where he looks at how to implement bartering-processes in ACE using Akka and Haskell (bidirectional multi-step conversations)

\subsection{LISP}
LISP is the oldest functional programming language and the second-oldest high-level programming language, only one year younger than Fortran. It would have been very interesting to research how we can do ABM/S in LISP utilizing its \textit{homoiconicity} but that would have opened up too much complexity also because LISP, despite being a functional programming language, is too far away from both Haskell and Scala. Thus the topic of applying LISP to ABM/S is left for further research in another paper. 

\subsection{Process-Calculi}
There is a strong connection of the ideas between the Actor-Model and Process-Calculi like the Pi-Calculus (TODO: cite Milner) and research has been done on connecting both worlds (TODO: cite Agha Gul). Also because the Actor-Model is so close to Agents because it was a major inspiration for the development of Agents and thus be regarded as one way of implementing Agents, one can argue due to transitivity that Agents can be connected to Pi-Calculus as well. This would allow to formalize Agents using the algebraic power and tools developed in Pi-Calculus.

\subsection{Dependent Types}
Holy Grail: would solve a specific class of problems with types, but typing and programing becomes more complicated then - also poses problems because everything programmed in this way has to be constructive. For this paper out of focus but will look into this in the main work.