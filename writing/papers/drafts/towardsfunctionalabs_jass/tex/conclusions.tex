\section{Conclusions and future work}

\subsection{Advantages}
- being explicit and polymorph about side-effects: can have 'pure' (no side-effects except state), 'random' (can draw random-numbers), 'IO' (all bets are off), STM (concurrency) agents

- hybrid between SD and ABS due to continuous time AND parallel dataFlow (parallel update-strategy)

- being update-strategy polymorph (TODO: this is just an asumption atm, need to prove this): 4 different update-strategies, one agent implementation

- parallel update-strategy: lack of implicit side-effects makes it work without any danger of data-interference

- recursive simulation
- reasoning about correctness
- reasoning about dynamics 
- testing with quickcheck much more convenient
- expressivity:
	-> 1:1 mapping of SD to code: can express the SD formulas directly in code
	-> directly expressing state-charts in code
	
\subsection{Disadvantages}

\subsubsection{Performance}
Performance is currently no where near imperative object-oriented implementations. The reason for this is that we don't have in-place updates of data-structures and make no use of references. This results in lots of copying which is simply not necessary in the imperative languages with implicit effects. Also it is much more difficult to reason about time and space in our approach. Thus we see performance clearly as the main drawback of the functional approach and the only real advantage of the imperative approach over our.

\subsubsection{Steep learning curve}
Our approach is quite advanced in three ways. First it builds on the already quite involved FRP paradigm. Second it forces one to think properly of time-semantics of the model, how to sample it, how small $\Delta t$ should be and whether one needs super-sampling or not and if yes how many samples one should take. Third it requires to think about agent-interaction and update-strategies, whether one should use conversations which forces one to run sequentially or if one can run agents in parallel and use normal messaging which incurs a time-delay which in turn would need to be considered when setting the $\Delta t$.

\subsection{Future Work}
TODO: what we need to show / future work
	- can we do DES? e.g. single queue with multiple servers? also specialist vs. generalist
	- reasoning about correctness: implement Gintis \& Ionescous papers 
	- reasoning about dynamics: implement Gintis \& Ionescous papers