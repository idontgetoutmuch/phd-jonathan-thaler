\section{Conclusion and future research}
We put our theoretical considerations to a practical test by implementing case-studies using three very different kind of languages to see how each of them performed in comparison with each other in implementing the update-strategies. To summarize, we can say that Java is the gold-standard due to convenient synchronization primitives built in the language. Haskell really surprised us as it allowed us to faithfully implement all strategies equally well, something we didn't anticipate in the beginning of our research. We hope that our work convinces researches and developers in the field of ABS to give Haskell a try and dig deeper into it, as we feel it will be highly rewarding. We explicitly avoided using the functional reactive programming (FRP) paradigm to keep our solution simple but could only build simple models with homogeneous agents. The next step would be to fusion ABS with FRP using the library Yampa for leveraging both approaches from which we hope to gain the ability to develop much more complex models with heterogeneous agents. 
If one can live with the non-determinism of Scala with the Actors-library it is probably the most interesting and elegant solution to implement ABS. We attribute this to the closeness of Actors to the concept of agents, the powerful concurrency abstraction and language-level support. We barely scratched the surface on this topic but we find that the Actor Model should get more attention in ABS. We think that this research-field is nowhere near exhaustion and we hope that more research is going into this topic as we assume that the Actor-Model has a bright future ahead due to the ever increasing availability of massively parallel computing machinery.