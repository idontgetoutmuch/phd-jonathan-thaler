\section{Conclusion}
\begin{itemize}
	\item Selecting the correct Iteration-Strategy is of most importance and must match the model semantics
	
	\item Java: parallelism and concurrency very easy due to elegant and powerful built-in synchronization primitives, high-performance and large number of agents possible due to aliasing and side-effects
	
	\item Surprise: Haskell can faithfully implement all strategies equally well, something not anticipated in the beginning. But: still much work to do to capture large and complex models (see further research), performance is a big issue but this has not been about performance (2000 Agents are enough)
	
	\item Scala with Actors: extremely elegant solutions possible
\end{itemize} 
