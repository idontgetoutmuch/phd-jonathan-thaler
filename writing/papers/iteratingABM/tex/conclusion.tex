\section{Conclusion}
In this paper we presented the four general update-strategies for an ABM/S and discussed their implications. Again we cannot stress enough that selecting the correct update-strategy is of most importance and must match the semantics of the model one wants to implement. \\
We also argued that the ABS community needs a unified terminology of speaking about update-strategies otherwise confusions arise and reproduceablility suffers. We proposed such a unified terminology on the basis of the general update-strategies and hope it will get adopted. \\
To put our theoretical considerations to a practical test we implemented them in three very different kind of languages to see how each of them performed in comparison with each other in implementing the update-strategies. To summarize, we can say that Java is the gold-standard due to convenient synchronization primitives built in the language. Haskell really surprised us as it allowed us to faithfully implement all strategies equally well, something we didn't anticipate in the beginning of our research. We hope that our work convinces researches and developers in the field of ABS to give Haskell a try and dig deeper into it, as we feel it will be highly rewarding. \\
If one can live with the non-determinism of Scala with Actors it is probably the most interesting and elegant solution to implement ABS. We attribute this to the closeness of Actors to the concept of Agents, the powerful concurrency abstraction and language-level support.