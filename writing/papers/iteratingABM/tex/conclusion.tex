\section{Conclusion}
\begin{itemize}
	\item Selecting the correct Iteration-Strategy is of most importance and must match the model semantics
	\item Java: best for non-parallel, non-concurrent strategy
	\item Scala with Actors: best for concurrency
	\item Surprise: Haskell can faithfully implement all strategies equally well, something not anticipated in the beginning
\end{itemize} 

\subsection{Haskell excells}
We initially thought that Haskell would be suitable best for just implementing the Par-Strategy after implementing all the strategies in it we found out that Haskell is extremely well suited to implement all the strategies. 

We think this stems from the following facts: 
no side-effects (unless reflected in the types): is a must-have for STM, although it makes things more difficult in the beginning, in the end it turns out to be a blessing because one can guarantee that side-effects won't occur. We have taken care that the agents all run in side-effect free code.
 
STM: implementing concurrency is a piece-of-cake

extremely powerful static typesystem: in combination with side-effect free this results in the semantics of an update-strategy to be reflected in the Agent-Transformer function and the messaging-interface. This means a user of this approach can be guided by the types and can't abuse them. Thus the lesson learned here is that \textit{if one tries to abuse the types of the agent-transformer or work around, then this is an indication that the update-strategy one has selected does not match the semantics of the model one wants to implement}. If this happens in Java, it is much more easier to work around by introducing global variables or side-effects but this is not possible in Haskell. \\
Thus our conclusion in using Haskell is that it is an extremely underestimated language in ABM/S which should be explored much more as we have shown that it really shines in this context and we believe that it could be pushed further even more.