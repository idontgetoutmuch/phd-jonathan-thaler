\section[Implementation]{Implementation \footnote{Code available under\\ \url{https://github.com/thalerjonathan/phd/tree/master/coding/papers/iteratingABM/}}}
In this section we give a brief overview of comparing implementing the update-strategies in three languages which fundamentally differ among each other. We wanted to cover a wide range of different types of languages but didn't include a language where the memory-management falls in the hands of the developer. This would be the case e.g. in C++. This was looked into partially by \cite{dawson_opening_2014} but the focus of this paper is not on this issue as it would complicated things dramatically. All used languages are garbage-collected / the developer does not need to care how memory is cleared up.

For testing the suitability we selected a variety of simple models we implemented in each language with mostly all strategies. The selected models are \textit{Heroes \& Cowards}, \textit{SIRS}, \textit{Wildfire} and the \textit{Spatial Game} mentioned in \cite{huberman_evolutionary_1993}. We lack the space to explain all models but all are well known and can be easily found, looked up and understood on the Internet. They span different challenges to the ABS implementation: sending messages, accessing the environment, spawning new Agents, killing existing ones, discrete and continuous model. We also can confirm that all the reference-models proposed in \cite{isaac_abm_2011} and the StupidModel 1-16 by Railsback (TODO: cite) can be faithfully capture using our new terminology. Also we could show that the  Parallel-Strategy is the only strategy able to reproduce the pattern of the \textit{Spatial Game} due to the semantics of the model which require that all the Agents play the game at virtually the same time - which is only possible in the Parallel-Strategy.



\subsection{Java}
This language is included as the benchmark of object-oriented (OO) imperative languages as it is extremely popular in the ABS community and widely used in implementing their models and Environments. It comes with a comprehensive programming library, has nice object-oriented features built in and powerful synchronization primitives at built in at language-level. \\

\paragraph{Ease of Use}
Being experienced Java-Programmers we found that implementing all the strategies was straight-forward and easy thanks to the languages features. Especially parallelism and concurrency is quite very easy due to elegant and powerful built-in synchronization primitives.

\paragraph{Benefits}
We experienced quite high-performance even for a large number of agents which we attributed to aliasing using references and side-effects. This prevents massive copying like in the case of Haskell, where we found the performance to be quite low.

\paragraph{Deficits}
We couldn't identify something which absolutely didn't work, that's also why Java can be regarded as a very safe decision when opting which language to use for implementing ABS.
A downside is that one must take care when accessing memory in case of parallel or concurrent strategy. Due to the availability of aliasing and side-effects in the language and the type-system, it can't be guaranteed that access to memory happens only when its safe - something which is possible in Haskell (see below).
Care must be taken when references are sent by messages to other agents in case of parallel or concurrency

although the interfaces encourage it we cannot prevent the agents to use agent-references and directly accessing. a workaround would be to create new agent-instances in every iteration-step which would make old references useless but this doesn't protect us from concurrency issues with a current iteration (the copying must take place within a synchronized block, thus implicitly assuming ordering, something we don't want) and besides, can always work around and update the references.
that's the toll of side-effects: faster execution but less control over abuse
tried to clone agents in each step and let them collect their messages => extremely slow

\paragraph{Natural Strategy}
We think that the Sequential Strategy with Immediate Message-Handling is the most natural Strategy to express in Java due to its heavy reliance on side-effects through references (aliases) and shared thread of execution. Also most of the models work this way and its thus a save decision to start with Java.





 
\subsection{Haskell}
This language is included to put to test whether such a pure functional declarative programming language is suitable for full-blown ABS. What distinguishes it is its complete lack of implicit side-effects, global data, mutable variables and objects. The central concept is the function into which all data has to be passed in and out explicitly through statically typed arguments and return values: data-flow is completely explicit.

\paragraph{Ease of Use}
Being Haskell-Beginners we initially thought that it would be suitable at best for just implementing the Parallel-Strategy but after implementing all we came to the conclusion, that Haskell is extremely well suited to implement all of them. We think this stems from the facts that it has no implicit side-effects which reduces bugs considerably and results in very explicit data-flow. \\

Not having objects with data and methods which can call between each other meant, that we needed some different way of representing Agents. This was done using a struct-like type to carry data and a transformer function which would receive and process messages. This may seem to look like OO but it is not: Agents are not carried around but messages are sent to a receiver identified by an id.

\paragraph{Benefits}
We really enjoyed working in the extremely powerful static type-system. Although it seems to be restrictive in the beginning, when one gets used to it and knows how to use it for ones help, then it gets rewarding. Our major point was to let the type-system prevent us from introducing side-effects. In Haskell this is only possible in code marked in its types as producing side-effects, so this was something we explicitly avoided and were able to throughout the whole implementation. Thus arriving at a much safer version in the parallel iteration-strategies with separate threads of execution. This means a user of this approach can be guided by the types and can't abuse them. Thus the lesson learned here is that \textit{if one tries to abuse the types of the agent-transformer or work around, then this is an indication that the update-strategy one has selected does not match the semantics of the model one wants to implement}. If this happens in Java, it is much more easier to work around by introducing global variables or side-effects but this is not possible in Haskell. \\

Parallelism and Concurrency is a breeze in Haskell due to its complete lack of implicit side-effects. Adding hardware-parallel execution in the Parallel-Strategy required the adoption of only 5 lines of code and no change to the existing Agent-Code at all (e.g. no synchronization, as there are no implicit side-effects). For implementing the Concurrent Strategy we utilized the programming model of Software-Transactional-Memory (STM). The approach is that one optimistically runs Agents which introduce explicit side-effects in parallel where each Agent executes in a transaction and then to simply retry the transaction if another Agent has made concurrent side-effect modifications. This frees one from thinking in terms of synchronization and leaves the code of the Agent nearly the same as in the Sequential Strategy.

\paragraph{Deficits}
Performance is an issue. A real-time simulation of 2000 Agents in our Haskell solution as opposed to 100.000 in our Java solution is just bad. It is important though to note, that being Haskell-beginners, we are largely unaware of the subtle performance-details of the language thus we expect to achieve a massive speed-up in the hands of an experienced programmer. \\

Another thing is that currently only homogeneous agents are possible and still much work needs do be done to capture large and complex models with heterogeneous agents. For this we need a more robust and comprehensive surrounding framework, which is already existent in the form of functional reactive programming (FRP). Our next paper is targeted on combining our Haskell solution with an FRP framework like Yampa (see further research). \\ 

Our solution so far is unable to implement the Sequential Strategy with immediate message-handling. This is where object-orientation really shines and pure functional programming seems to be lacking in convenience. A solution would need to drag the collection of all Agents around which would make state-handling and manipulation very cumbersome. In the end it would have meant to rebuild OO concepts in a pure functional language, something we didn't wanted to do. For now this is left as an open, unsolved issue and we hope that it could be solved in our approach with FRP (see future research).

\paragraph{Natural Strategy}
The most natural strategy would be the Parallel-Strategy as it lends itself so well to the concepts of pure functional programming where things are evaluated virtually in parallel without side-effects on each other - something which resembles exactly the semantics of the Parallel-Strategy. We can also argue that the Concurrent - Strategy is also very natural formulated in Haskell due to the availability of STM, something only possible in a language without implicit side-effects as otherwise retries would not be possible.



\subsection{Scala with Actors}
This multi-paradigm functional language is included to test the usefulness of the \textit{Actor Strategy} for implementing ABS. The language comes with an Actor-library inspired by \cite{agha_actors:_1986} and resembles the approach of Erlang which allows a very natural implementation of the strategy.

\paragraph{Ease of Use}
We were completely new to Scala with Actors although we have some experience using Erlang. We found that the language has some very nice mixed-paradigm features which allows to program in a very flexible way without inducing too much restrictions on one.

\paragraph{Benefits}
Formulating Agent-behaviour is extremely convenient, especially for simple state-chart Agents. The Actor-language has a built-in feature which allows to change the behaviour of an Agent on message reception where the Agent then simply switches to a different message-handler, allowing elegant implementation of state-charts. \\

Performance is very high. We could run simulations in real-time with about 200.000 Agents concurrently, something the run-time system easily manages. Also it is very important to note that one can use the framework Akka to build real distributed systems using Scala with Actors so there are potentially no limits on the size and complexity of the models and number of agents one wants to run with it.

\paragraph{Deficits}
Care must be taken not to send references and mutable data, which is still possible in this mixed-paradigm language.

\paragraph{Natural Strategy}
The most natural strategy would be of course the Actor Strategy and we only used this Strategy in this language to implement our Models. Note that the Actor Strategy is the most general one and would allow to capture all the other strategies using the appropriate synchronization mechanisms.