\section{Results}
5 Pages

This is now very programming-language specific

\begin{itemize}
	\item Mapping the strategies to 3 programming-languages: Java, Scala with Actors, Haskell
	\item Comparing the programming languages in regard of their suitability to implement each of these strategies
	\item Screen-shots of results of the same simulation-model with all the strategies
\end{itemize}

\subsection{Selection of the Languages}
-> Java: supports global data => suitable to implement global decisions: implementing global-time, sequential iteration with global decisions
	-> Haskell: has no global data => local decisions (has support for global data through STM/IO but then looses very power?) => implementing global-time, parallel iteration with local-decisions. 
		-> Haskell STM solution => implementing concurrent version using STM? but this is very complicated in its own right but utilizing STM it will be much more easier than in java
	-> Scala: mixed, can do both => implementing local time with random iteration and local decisions


Note that we didn't select a language where the memory-management falls in the hands of the developer. This would be the case e.g. in C++. This was looked into partially by \cite{dawson_opening_2014} but the focus of this paper is not on this issue as it would complicated things dramatically. All used languages are garbage-collected / the developer does not need to care how memory is cleared up.

\subsection{Selected Models}

\subsubsection{Heroes \& Cowards}
\subsubsection{SIRS}
\subsubsection{Wildfire}
\subsubsection{Spatial Game}


\subsection{Java}
sequential more natural in java,
parallel needs to "think functional" in java
concurrency and actors always difficult in java despite java provides very good synchronization primitives

IMPORTANT: no need to explicitly add the environment, as this can be individually implemented by the agents on a shared basis (references)

sequential is able to work completely without messages and only by accesing references to neighbours but we explicitly don't want to follow this obvious way and stick to the send/receive message paradigm. we keep Agent-instance references

parallel then needs to utilize messages because would violate the parallel implementation. TODO: split state from agent and only update agent-state
problem: can send references through messages: share data
although the interfaces encourage it we cannot prevent the agents to use agent-references and directly accessing. a workaround would be to create new agent-instances in every iteration-step which would make old references useless but this doesn't protect us from concurrency issues with a current iteration (the copying must take place within a synchronized block, thus implicitly assuming ordering, something we don't want) and besides, can always work around and update the references.
thats the toll of side-effects: faster execution but less control over abuse
tried to clone agents in each step and let them collect their messages => extremely slow

conc: expect it to be a pain in the ass with java. it is not: its the same interface as in SEQ with updates running parallel like in PAR but 

act: need to copy messages, otherwise could stuck in an endless loop

\subsection[Haskell]{Haskell\footnote{Code available under\\ \url{https://github.com/thalerjonathan/phd/tree/master/coding/papers/iteratingABM/haskell}}}

We initially thought that Haskell would be suitable best for just implementing the Par-Strategy after implementing all the strategies in it we found out that Haskell is extremely well suited to implement all the strategies. 

We think this stems from the following facts: 
no side-effects (unless reflected in the types): is a must-have for STM, although it makes things more difficult in the beginning, in the end it turns out to be a blessing because one can guarantee that side-effects won't occur. We have taken care that the agents all run in side-effect free code.
 
STM: implementing concurrency is a piece-of-cake

extremely powerful static typesystem: in combination with side-effect free this results in the semantics of an update-strategy to be reflected in the Agent-Transformer function and the messaging-interface. This means a user of this approach can be guided by the types and can't abuse them. Thus the lesson learned here is that \textit{if one tries to abuse the types of the agent-transformer or work around, then this is an indication that the update-strategy one has selected does not match the semantics of the model one wants to implement}. If this happens in Java, it is much more easier to work around by introducing global variables or side-effects but this is not possible in Haskell. \\
Thus our conclusion in using Haskell is that it is an extremely underestimated language in ABM/S which should be explored much more as we have shown that it really shines in this context and we believe that it could be pushed further even more.

but still it is not suitable for big models with heterogeneous agents, there things are lacking: see further research




note that the difference between SEQ and PAR in Haskell is in the end a 'fold' over the agents in the case of SEQ and a 'map' in the case of PAR
dont have objects with methods which can call between each other but we need some way of representing agents. this is done using a struct type with a behaviour function and messaging mechanisms. important: agents are not carried arround but messages are sent to a receiver identified by an id. This is also a big difference to java where don't really need this kind of abstraction due to the use of objects and their 'messaging'. messaging mechanisms have up- and downsides, elaborate on it.

concurrency and actors extremely elegant possible through: STM which only possible in languages without side-effect	

the conc-version and the act-version of the agent-implementations look EXACTLY the same	 BUT we lost the ability to step the simulation!!!

This is the process of implementing the behaviour of the Agent as specified in the model. Although there are various kinds of Agent-Models like BDI but the basic principle is always the same: sense the environment, process messages, execute actions: change environment, send messages. According to \cite{wooldridge_introduction_2009} and also influenced by Actors from \cite{agha_actors:_1986} one can abstract the abilities in each step of an Agent to be the following:

\begin{enumerate}
\item Process received messages
\item Create new Agents
\item Send messages to other Agents
\item Sense (read) the environment
\item Influence (write) the environment
\end{enumerate}


\subsection{Scala with Actors}
direct support for actors
