\section[Language Comparison]{Language Comparison \footnote{Code available under\\ \url{https://github.com/thalerjonathan/phd/tree/master/coding/papers/iteratingABM/}}}
In this section we give a brief overview of comparing the suitability of three fundamentally different languages to implement the update-strategies. We wanted to cover a wide range of different types of languages but didn't include a language where the memory-management falls in the hands of the developer. This would be the case e.g. in C++. This was looked into partially by \cite{dawson_opening_2014} but the focus of this paper is not on this issue as it would complicated things dramatically. Also it was important to us that we tried to use the strenghts of each language as well as possible without abusing language constructs to recreate features it might seem to lack. An example would be to rebuild OO constructs in pure functional languages which would be a abuse of the language, something we explicitly avoided although it resulted in a few limitations as noted below.

For testing the suitability we selected a variety of simple models we implemented in each language with mostly all strategies. The selected models are \textit{Heroes \& Cowards} (see next section), \textit{SIRS}, \textit{Wildfire} and the \textit{Prisoners Dilemma} mentioned in the Introduction. We lack the space to explain all models but all are well known and can be easily found, looked up and understood on the Internet. They span different challenges to the ABS implementation: sending messages, accessing the environment, spawning new agents, killing existing ones, discrete and continuous model. Although not implemented, we also claim that all the reference-models proposed in \cite{isaac_abm_2011} and the StupidModel 1-16 by \cite{railsback_stupidmodel_2005} can be faithfully capture using our new terminology.


\subsection{Java}
This language is included as the benchmark of object-oriented (OO) imperative languages as it is extremely popular in the ABS community and widely used in implementing their models and frameworks. It comes with a comprehensive programming library, has nice object-oriented features and powerful synchronization primitives built in at language-level.

\paragraph{Ease of Use}
Being experienced Java-Programmers we found that implementing all the strategies was straight-forward and easy thanks to the languages features. Especially parallelism and concurrency is convenient to implement due to elegant and powerful built-in synchronization primitives.

\paragraph{Benefits}
We experienced quite high-performance even for a large number of agents which we attributed to the implicit side-effects using aliasing through references. This prevents massive copying like Haskell but comes at the cost of explicit data-flow.

\paragraph{Deficits}
A downside is that one must take care when accessing memory in case of Parallel or Concurrent strategy. Due to the availability of aliasing and side-effects in the language it can't be guaranteed by Java's type-system that access to memory happens only when its safe. So care must be taken when accessing references sent by messages to other agents, accessing references to other agents or the infrastructure of an agent itself e.g. the message-box. \\
We found that implementing the Actor Strategy was not possible when using thousands of agents because Java can't handle this number of threads. For implementing the Parallel and Concurrent ones we utilized the ExecutorService to submit a task for each agent which runs the update and finishes then. The tasks are evenly distributed between the available threads using this service where the service is backed by the number of cores the CPU has. This approach does not work for the Actor Strategy because there an agent runs constantly within its thread making it not possible to map to the concept of a task as this task would not terminate. The ExecutorService would then start n tasks (where n is the number of threads in the pool) and would not start new ones until those have finished, which will not occur until the agent would shut itself down. Also yielding or sleeping does not help either as not all threads are started but only n. 

\paragraph{Natural Strategy}
We found that the Sequential Strategy with immediate message-handling is the most natural strategy to express in Java due to its heavy reliance on side-effects through references (aliases) and shared thread of execution. Also most of the models work this way making Java a save choice for implementing ABS.





 
\subsection{Haskell}
This language is included to put to test whether a pure functional, declarative programming language is suitable for full-blown ABS. What distinguishes it is its complete lack of implicit side-effects, global data, mutable variables and objects. The central concept is the function into which all data has to be passed in and out explicitly through statically typed arguments and return values: data-flow is completely explicit. For a nice overview on the features and strengths of pure functional programming see the classical paper  \cite{hughes_why_1989}.

\paragraph{Ease of Use}
Being beginners in Haskell we initially thought that it would be suitable best for implementing the Parallel Strategy only due the inherent data-parallel nature of pure functional languages. After having implementing all strategies we had to admit that Haskell is very well suited to implement all of them faithfully. We think this stems from the fact that it has no implicit side-effects which reduces bugs considerably and results in completely explicit data-flow. \\

Not having objects with data and methods, which can call between each other meant that we needed some different way of representing agents. This was done using a struct-like type to carry data and a transformer function which would receive and process messages. This may seem to look like OO but it is not: agents are not carried around but messages are sent to a receiver identified by an id.

\paragraph{Benefits}
We really enjoyed working in the extremely powerful static type-system. Although it seems to be restrictive in the beginning, when one gets used to it and knows how to use it for ones support, then it becomes rewarding. Our major point was to let the type-system prevent us from introducing side-effects. In Haskell this is only possible in code marked in its types as producing side-effects, so this was something we explicitly avoided and were able to do so throughout the whole implementation. This means a user of this approach can be guided by the types and is prevented from abusing them. In essence, the lesson learned here is \textit{if one tries to abuse the types or work around, then this is an indication that the update-strategy one has selected does not match the semantics of the model one wants to implement}. If this happens in Java, it is much more easier to work around by introducing global variables or side-effects but this is not possible in Haskell. Also we claim that when using Haskell one arrives at a much safer version in the case of Parallel or Concurrent Strategies than in Java.\\

Parallelism and Concurrency is a breeze in Haskell due to its complete lack of implicit side-effects. Adding hardware-parallel execution in the Parallel-Strategy required the adoption of only 5 lines of code and no change to the existing agent-code at all (e.g. no synchronization, as there are no implicit side-effects). For implementing the Concurrent Strategy we utilized the programming model of Software-Transactional-Memory (STM). The approach is that one optimistically runs agents which introduce explicit side-effects in parallel where each agent executes in a transaction and then to simply retry the transaction if another agent has made concurrent side-effect modifications. This frees one from thinking in terms of synchronization and leaves the code of the agent nearly the same as in the Sequential Strategy. \\
Spawning thousands of threads in the Actor Strategy is no problem in Haskell due to its lightweight handling of threads internal in the runt-time system, something which Java seems to be lacking. We have to note that each agents needs to explicitly yield the execution to allow other agent-threads to be scheduled, something when omitted will bring the system to a grind.

\paragraph{Deficits}
Performance is an issue. Our Haskell solution could run only about 2000 agents in real-time with 25 updates per second as opposed to 50.000 in our Java solution, which is not very fast. It is important though to note, that being beginners in Haskell, we are largely unaware of the subtle performance-details of the language so we expect to achieve a massive speed-up in the hands of an experienced programmer. \\

Another thing is that currently only homogeneous agents are possible and still much work needs do be done to capture large and complex models with heterogeneous agents. For this we need a more robust and comprehensive surrounding framework, which is already existent in the form of functional reactive programming (FRP). Our next paper is targeted on combining our Haskell solution with an FRP framework like Yampa (see Further Research). \\ 

Our solution so far is unable to implement the Sequential Strategy with immediate message-handling. This is where OO really shines and pure functional programming seems to be lacking in convenience. A solution would need to drag the collection of all agents around which would make state-handling and manipulation very cumbersome. In the end it would have meant to rebuild OO concepts in a pure functional language, something we didn't wanted to do. For now this is left as an open, unsolved issue and we hope that it could be solved in our approach with FRP (see future research).

\paragraph{Natural Strategy}
The most natural strategy is the Parallel Strategy as it lends itself so well to the concepts of pure functional programming where things are evaluated virtually in parallel without side-effects on each other - something which resembles exactly the semantics of the Parallel Strategy. We argue that the Concurrent Strategy is also very natural formulated in Haskell due to the availability of STM, something only possible in a language without implicit side-effects as otherwise retries of transactions would not be possible.



\subsection{Scala with Actors}
This multi-paradigm functional language which sits in-between Java and Haskell and is included to test the usefulness of the Actor Strategy for implementing ABS. The language comes with an Actor-library inspired by \cite{agha_actors:_1986} and resembles the approach of Erlang which allows a very natural implementation of the strategy.

\paragraph{Ease of Use}
We were completely new to Scala with Actors although we have some experience using Erlang which was of great use. We found that the language has some very nice mixed-paradigm features which allow to program in a very flexible way without inducing too much restrictions on one.

\paragraph{Benefits}
Implementing agent-behaviour is extremely convenient, especially for simple state-driven agents. The Actor-language has a built-in feature which allows to change the behaviour of an agent on message-reception where the agent then simply switches to a different message-handler, allowing elegant implementation of state-dependent behaviour. \\

Performance is very high. We could run simulations in real-time with about 200.000 agents concurrently, thanks to the transparent handling in the run-time system. Also it is very important to note that one can use the framework Akka to build real distributed systems using Scala with Actors so there are potentially no limits to the size and complexity of the models and number of agents one wants to run with it.

\paragraph{Deficits}
Care must be taken not to send references and mutable data, which is still possible in this mixed-paradigm language.

\paragraph{Natural Strategy}
The most natural strategy would be of course the Actor Strategy and we only used this Strategy in this language to implement our models. Note that the Actor Strategy is the most general one and would allow to capture all the other strategies using the appropriate synchronization mechanisms.



\begin{table*}[t]
\centering
\caption{Language Comparisons}
\label{tab:language_comparisons}
\begin{tabular}{l || l | l | l  }
	 			& Java 	& Haskell 	& Scala	\\ \hline \hline

Sequential		& ++	& --		& ?		\\  
Parallel		& +		& ++		& ?		\\  
Concurrent		& +		& ++		& ?		\\  
Actor			& --	& +			& ++	\\  

\end{tabular}
\end{table*}