\section[Language Comparison]{Language Comparison \footnote{Code available under\\ \url{https://github.com/thalerjonathan/phd/tree/master/coding/papers/iteratingABM/}}}
In this section we give a brief overview of comparing the suitability of three fundamentally different languages to implement the update-strategies. We wanted to cover a wide range of different types of languages but didn't include a language where the memory-management falls in the hands of the developer. This would be the case e.g. in C++. This was looked into partially by \cite{dawson_opening_2014} but the focus of this paper is not on this issue as it would complicated things dramatically. All used languages are garbage-collected / the developer does not need to care how memory is cleared up.

For testing the suitability we selected a variety of simple models we implemented in each language with mostly all strategies. The selected models are \textit{Heroes \& Cowards}, \textit{SIRS}, \textit{Wildfire} and the \textit{Spatial Game} mentioned in \cite{huberman_evolutionary_1993}. We lack the space to explain all models but all are well known and can be easily found, looked up and understood on the Internet. They span different challenges to the ABS implementation: sending messages, accessing the environment, spawning new Agents, killing existing ones, discrete and continuous model. We also can confirm that all the reference-models proposed in \cite{isaac_abm_2011} and the StupidModel 1-16 by Railsback (TODO: cite) can be faithfully capture using our new terminology. Also we could show that the  Parallel Strategy is the only strategy able to reproduce the pattern of the prisoners dilemma due to the semantics of the model which require that all the Agents play the game at virtually the same time - which is only possible in the Parallel Strategy.

TODO: mention, that we didn't want to abuse the language and focus on its strengths e.g. don't rebuild OO in Haskell.


\subsection{Java}
This language is included as the benchmark of object-oriented (OO) imperative languages as it is extremely popular in the ABS community and widely used in implementing their models and Environments. It comes with a comprehensive programming library, has nice object-oriented features and powerful synchronization primitives built in at language-level.

\paragraph{Ease of Use}
Being experienced Java-Programmers we found that implementing all the strategies was straight-forward and easy thanks to the languages features. Especially parallelism and concurrency is quite very easy due to elegant and powerful built-in synchronization primitives.

\paragraph{Benefits}
We experienced quite high-performance even for a large number of agents which we attributed to aliasing using references and side-effects. This prevents massive copying like Haskell but comes at the cost of explicit data-flow.

\paragraph{Deficits}
We couldn't identify something which absolutely didn't work. That's also why Java can be regarded as a very safe decision when looking for an appropriate language to use for implementing ABS.A downside is that one must take care when accessing memory in case of Parallel or Concurrent strategy. Due to the availability of aliasing and side-effects in the language and the type-system, it can't be guaranteed that access to memory happens only when its safe. Thus care must be taken when accessing references sent by messages to other Agents, accessing references to other Agents or the infrastructure of an Agent itself e.g. the message-box. TODO: actor not possible if high number of agents because java can't handle very large number of threads. in parallel and concurrent one uses executorservice with the number of cores and submits for each agent a task which runs the update and the tasks are then evenly executed on the available threads. This approach does not work for the actor strategy where we don't have tasks for a single update but we constantly run the agent in a thread thus the task would not return until the agent shuts itself down. 

\paragraph{Natural Strategy}
We found that the Sequential Strategy with immediate message-handling is the most natural strategy to express in Java due to its heavy reliance on side-effects through references (aliases) and shared thread of execution. Also most of the models work this way and its thus a save decision to use Java.





 
\subsection{Haskell}
This language is included to put to test whether such a pure functional, declarative programming language is suitable for full-blown ABS. What distinguishes it is its complete lack of implicit side-effects, global data, mutable variables and objects. The central concept is the function into which all data has to be passed in and out explicitly through statically typed arguments and return values: data-flow is completely explicit.

\paragraph{Ease of Use}
Being beginners in Haskell we initially thought that it would be suitable at best for just implementing the Parallel Strategy due the inherent data-parallel nature of pure functional languages. After having implementing all strategies we had to admit that Haskell is very well suited to implement all of them faithfully. We think this stems from the facts that it has no implicit side-effects which reduces bugs considerably and results in very explicit data-flow. \\

Not having objects with data and methods which can call between each other meant, that we needed some different way of representing Agents. This was done using a struct-like type to carry data and a transformer function which would receive and process messages. This may seem to look like OO but it is not: Agents are not carried around but messages are sent to a receiver identified by an id.

\paragraph{Benefits}
We really enjoyed working in the extremely powerful static type-system. Although it seems to be restrictive in the beginning, when one gets used to it and knows how to use it for ones help, then it becomes rewarding. Our major point was to let the type-system prevent us from introducing side-effects. In Haskell this is only possible in code marked in its types as producing side-effects, so this was something we explicitly avoided and were able to do so throughout the whole implementation. This means a user of this approach can be guided by the types and is prevented from abusing them. Thus the lesson learned here is that \textit{if one tries to abuse the types or work around, then this is an indication that the update-strategy one has selected does not match the semantics of the model one wants to implement}. If this happens in Java, it is much more easier to work around by introducing global variables or side-effects but this is not possible in Haskell. Also we claim that when using Haskell one arrives at a much safer version in the case of Parallel or Concurrent Strategies than in Java.\\

Parallelism and Concurrency is a breeze in Haskell due to its complete lack of implicit side-effects. Adding hardware-parallel execution in the Parallel-Strategy required the adoption of only 5 lines of code and no change to the existing Agent-Code at all (e.g. no synchronization, as there are no implicit side-effects). For implementing the Concurrent Strategy we utilized the programming model of Software-Transactional-Memory (STM). The approach is that one optimistically runs Agents which introduce explicit side-effects in parallel where each Agent executes in a transaction and then to simply retry the transaction if another Agent has made concurrent side-effect modifications. This frees one from thinking in terms of synchronization and leaves the code of the Agent nearly the same as in the Sequential Strategy.
TODO: spawning thousands of parallel threads and keeping them running is no problem due to the leightweight handling, something which is missing in java.

\paragraph{Deficits}
Performance is an issue. Our Haskell solution could run only about 2000 Agents in real-time with 25 updates per second as opposed to 50.000 in our Java solution, which is not very fast. It is important though to note, that being beginners in Haskell, we are largely unaware of the subtle performance-details of the language thus we expect to achieve a massive speed-up in the hands of an experienced programmer. \\

Another thing is that currently only homogeneous agents are possible and still much work needs do be done to capture large and complex models with heterogeneous agents. For this we need a more robust and comprehensive surrounding framework, which is already existent in the form of functional reactive programming (FRP). Our next paper is targeted on combining our Haskell solution with an FRP framework like Yampa (see further research). \\ 

Our solution so far is unable to implement the Sequential Strategy with immediate message-handling. This is where object-orientation really shines and pure functional programming seems to be lacking in convenience. A solution would need to drag the collection of all Agents around which would make state-handling and manipulation very cumbersome. In the end it would have meant to rebuild OO concepts in a pure functional language, something we didn't wanted to do. For now this is left as an open, unsolved issue and we hope that it could be solved in our approach with FRP (see future research).

\paragraph{Natural Strategy}
The most natural strategy is the Parallel-Strategy as it lends itself so well to the concepts of pure functional programming where things are evaluated virtually in parallel without side-effects on each other - something which resembles exactly the semantics of the Parallel Strategy. We argue that the Concurrent Strategy is also very natural formulated in Haskell due to the availability of STM, something only possible in a language without implicit side-effects as otherwise retries of transactions would not be possible.



\subsection{Scala with Actors}
This multi-paradigm functional language is included to test the usefulness of the Actor Strategy for implementing ABS. The language comes with an Actor-library inspired by \cite{agha_actors:_1986} and resembles the approach of Erlang which allows a very natural implementation of the strategy.

\paragraph{Ease of Use}
We were completely new to Scala with Actors although we have some experience using Erlang. We found that the language has some very nice mixed-paradigm features which allow to program in a very flexible way without inducing too much restrictions on one.

\paragraph{Benefits}
Implementing Agent-behaviour is extremely convenient, especially for simple state-chart Agents. The Actor-language has a built-in feature which allows to change the behaviour of an Agent on message reception where the Agent then simply switches to a different message-handler, allowing elegant implementation of state-charts. \\

Performance is very high. We could run simulations in real-time with about 200.000 Agents concurrently, something the run-time system easily manages. Also it is very important to note that one can use the framework Akka to build real distributed systems using Scala with Actors so there are potentially no limits on the size and complexity of the models and number of agents one wants to run with it.

\paragraph{Deficits}
Care must be taken not to send references and mutable data, which is still possible in this mixed-paradigm language.

\paragraph{Natural Strategy}
The most natural strategy would be of course the Actor Strategy and we only used this Strategy in this language to implement our Models. Note that the Actor Strategy is the most general one and would allow to capture all the other strategies using the appropriate synchronization mechanisms.