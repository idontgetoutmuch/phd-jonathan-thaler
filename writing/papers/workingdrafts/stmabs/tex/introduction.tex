\section{Introduction} % (once upon a time...)
The future of scientific computing in general and Agent-Based Simulation (ABS) in particular is parallelism because Moore's law is not holding any more as we have reached the physical limits of CPU clocks. The only escape is going massively parallel due to availability of cheap massive parallel local hardware with many cores or cloud services like Amazon S2. Unfortunately the established imperative languages in the ABS field, Python, Java, C++, follow mostly a lock-based approach to concurrency which is error prone and does not compose. Further, data-parallelism in an imperative language is susceptible to side-effects because these languages cannot not distinguish between data-parallelism and concurrency in the types. 

Functional programming as in Haskell can provide a solution to both problems. The problems of lock-based approaches can be overcome by using Software Transactional Memory (STM). Although STM exists in other languages as well, Haskell was one of the first to natively build it into its core and the guaranteed lack of non-repeatable side-effects at compile time makes the use of STM in Haskell very compelling. Data-parallelism falls into place very naturally in Haskell because of the controlled side-effects and immutable data. The very unique benefit of using Haskell over existing STM implementations in other languages is that we can rule out any persistent side-effects in STM transactions which allows unproblematic retries of transactions - guaranteed at compile-time.

We follow \cite{discolo_lock_2006} and compare the performance of lock-based and STM implementations.  also that paper gives a good indication how difficult and complex constructing a correct concurrent program is. the paper shows how much easier, concise and less error-prone an STM implementation is over traditional locking with mutexes and semaphores. Further it shows that STM consistently outperforms the lock based implementation. We hypothesise that the reduced complexity and increased performance will be directly applicable to ABS as well.

We present two case-studies in which we employ an agent-based spatial SIR \citep{macal_agent-based_2010} and the well known SugarScape \citep{epstein_growing_1996} model to test our hypothesis. The latter model can be seen as one of the most influential exploratory models in ABS which laid the foundations of object-oriented implementation of agent-based models. The former one is an easy-to-understand explanatory model which has the advantage that it has an analytical theory behind it which can be used for verification and validation. 

The aim of this paper is to empirically and experimentally investigate the benefit of using STM over lock-based approaches for concurrent ABS models. Although there exists research which has used STM in ABS \cite{bezirgiannis_improving_2013}, we explore it more rigorous and systematically on a conceptual level. Although we use the functional programming language Haskell and its STM implementation, we omit functional programming concepts almost altogether and focus only on Haskells ability to guarantee that transactions are truly repeatable without persistent side-effects which can be guaranteed at compile-time. Thus our contribution is that to the best of our knowledge we are the first to systematically investigate the use of STM in ABS and compare is performance with sequential, lock-based and imperative implementations both on local and Amazon Cloud Service machinery.

We start with Section \ref{sec:rel_work} where we present related work and then present the concepts of STM in Section \ref{sec:background}. In Section \ref{sec:stm_abs} we show how to apply STM to ABS in general and in our case-studies in particular. Section \ref{sec:cs_sir} contains the first case-study using a spatial SIR mode whereas Section \ref{sec:cs_sugarscape} presents the second case-study using the SugarScape model. We conclude in Section \ref{sec:conclusion} and give further research directions in Section \ref{sec:further}.