\section{Introduction}

In the paper \cite{heindl_modeling_2009} the authors used a model of STM to simulate optimistic and pessimistic STM behaviour under various scenarios using the AnyLogic simulation package. They concluded that optimistic STM may lead to 25\% less retries of transactions.

why FP? because concurrency and parallelism in general more easier in FP due to controlled side-effects and immutable data. also strong benefit is that STM is built into the language based on leightweight thread system. unique benefit is that we can rule out any persistent side-effects in STM transactions which allows unproblematic retries of transactions - guaranteed at compile-time

We follow \cite{discolo_lock_2006} and compare the Performance of lock based and lock free implementations. also that paper gives a good indication how difficult and complex constructing a correct concurrent program is. the paper shows how much easier, concise and less error-prone an STM implementation is over traditional locking with mutexes and semaphores. Further it shows that stm consistently outperforms the lock based implementation. we hope the same results for our paper

We present case-studies in which we employ the well known SugarScape \citep{epstein_growing_1996} and agent-based SIR \citep{macal_agent-based_2010} model to test our hypothesis. The former model can be seen as one of the most influential exploratory models in ABS which laid the foundations of object-oriented implementation of agent-based models. The latter one is an easy-to-understand explanatory model which has the advantage that it has an analytical theory behind it which can be used for verification and validation.

problem of low-level lock-based concurrency programming
- inefficiency e.g. more contention for aquiring a lock
- complexity e.g. forgetting to releasing a lock or re-taking it can lead to deadlocks. in complex programs this is not obviously detectable

The aim of this paper is to empirically and experimentally investigate the benefit of using STM for concurrent ABS models. Although there exists research which has used STM in ABS \cite{bezirgiannis_improving_2013}, we explore it more rigorous and systematically on a conceptual level. Although we use the functional programming language Haskell and its STM implementation, we omit functional programming concepts almost altogether and focus only on Haskells ability to guarantee that transactions are truly repeatable without persistent side-effects which can be guaranteed at compile-time.

This paper makes the following contributions:
- STM to implement concurrent ABS 
- compares 3 approaches: non-concurrent, low-level locking, STM

The structure of the paper is:
%In Section \ref{sect:stm_impl} we give a short overview of our implementation, presenting and discussing code. In Section \ref{sect:stm_perf} we present performance comparisons and discuss the implications more in-depth in Section \ref{sect:stm_discussion}. Finally we will give a short outline over further research in \ref{sect:stm_further}.