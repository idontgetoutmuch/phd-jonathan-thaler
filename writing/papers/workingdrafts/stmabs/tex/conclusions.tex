\section{Conclusion (the moral of the tale)}
Using STM for concurrent, large-scale ABS seems to be a very promising approach as our proof-of-concept has shown. The concurrency abstractions of STM are very powerful, yet simple enough to allow convenient implementation of concurrent agents without the nastiness of low level concurrent locks. Also we have shown by experiments, that we indeed get a very substantial speed-up and that we even got linear performance scaling for our model. 

Interestingly, STM primitives map nicely to ABS concepts: using a share environment through a \textit{TVar} is very easy, also we implemented in an additional proof-of-concept the use of \textit{TChan} which can be seen as persistent message boxes for agents, underlining the message-oriented approach found in many agent-based models. Also \textit{TChan} offers a broadcast transactional channel, which supports broadcasting to listeners which maps nicely to a pro-active environment or a central auctioneer upon which agents need to synchronize.

Running in STM instead of IO also makes the concurrent nature more explicit and at the same time restricts it to purely STM behaviour. So despite obviously losing the reproducibility property due to concurrency, we still can guarantee that the agents can't do arbitrary IO as they are restricted to STM operations only.

Depending on the nature of the transactions, retries could become a bottle neck, resulting in a live lock in extreme cases. The central problem of STM is to keep the retries low, which is directly influenced by the read/writes on the STM primitives. By choosing more fine-grained / suitable data-structures e.g. using a TArray instead of an Array within a TVar, one can reduce retries significantly. We tracked the retries in our proof-of-concept using the stm-stats library and arrived at a ratio of 0.0\% retries - note that there were some retries but they were so low that they weren't significant.

Benefits are that using STM takes a big portion of burden from the modeller as one can think in STM primitives instead of low level locking and concurrency operational details.

After the strong performance results of the SIR case-study in Section \ref{sec:cs_sir} we come to the conclusion, that the performance results of the SugarScape case-study are not as compelling. This shows that for some ABS models, performance in a concurrent multi-core functional implementation is still nowhere near the established single-core imperative implementations in e.g. RePast. This does not come completely as a surprise because although functional program has caught up in speed, it is still behind imperative approaches. Also to squeeze out high performance of functional programs which can catch up with imperative implementations involves much more experience and sophisticated techniques than just writing imperative approaches.