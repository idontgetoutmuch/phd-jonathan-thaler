\section{Conclusion} %(the moral of the tale)
\label{sec:conclusion}

In this paper we investigated the potential for using STM for parallel, large-scale ABS and come to the conclusion that it is indeed a very promising alternative over lock-based approaches as our case-studies have shown. The STM approaches all consistently outperformed the lock-based implementations and scaled much better to larger number of CPUs. Besides, the concurrency abstractions of STM are very powerful, yet simple enough to allow convenient implementation of concurrent agents without the problems of lock-based implementation.

Interestingly, STM primitives map nicely to ABS concepts. When having a shared environment, it is natural either using \textit{TVar} or \textit{TArray}, depending on the environments nature. Also, there exists the \textit{TChan} primitive, which can be seen as a persistent message box for agents, underlining the message-oriented approach found in many agent-based models \cite{agha_actors:_1986, wooldridge_introduction_2009}. Also \textit{TChan} offers a broadcast transactional channel, which supports broadcasting to listeners which maps nicely to a pro-active environment or a central auctioneer upon which agents need to synchronize. The benefits of these natural mappings are that using STM takes a big portion of burden from the modeller as one can think in STM primitives instead of low level locks and concurrency operational details.

The strong static type-system of Haskell adds another benefit. By running in the STM instead of IO context makes the concurrent nature more explicit and at the same time restricts it to purely STM behaviour. So despite obviously losing the reproducibility property due to concurrency, we still can guarantee that the agents can't do arbitrary IO as they are restricted to STM operations only.

Depending on the nature of the transactions, retries could become a bottle neck, resulting in a live lock in extreme cases. The central problem of STM is to keep the retries low, which is directly influenced by the read/writes on the STM primitives. By choosing more fine-grained / suitable data-structures e.g. using a \textit{TArray} instead of an indexed array within a \textit{TVar}, one can reduce retries and increase performance significantly and avoid the problem of live locks as we have shown.

After the strong performance results of the SIR case-study in Section \ref{sec:cs_sir} we come to the conclusion, that the performance results of the SugarScape case-study are not as compelling. This shows that for some ABS models, performance in a concurrent multi-core functional implementation is still nowhere near the established single-core imperative implementations in e.g. RePast. This does not come as a surprise because although functional program has caught up in speed, it is still behind imperative approaches. Also to squeeze out high performance of functional programs, which can catch up with imperative implementations, involves much more experience and sophisticated techniques than just writing imperative approaches.
Also, the Amazon experiments suggest that we are running into a limit between 16 and 32 cores on the STM implementation, which is most probably due to the synchronous lock-step approach.

Despite the indisputable benefits of using STM within a pure functional setting like Haskell, it exists also in other imperative languages (Python, Java and C++,...) and we hope that our research sparks interest in the use of STM in ABS in general and that other researchers pick up the idea and apply it to the established imperative languages Python, Java, C++ in the ABS community as well.