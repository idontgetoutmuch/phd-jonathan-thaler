\section{Case Study 1: SIR} 
Our first case study is the SIR model which is a very well studied and understood compartment model from epidemiology \cite{kermack_contribution_1927} which allows to simulate the dynamics of an infectious disease like influenza, tuberculosis, chicken pox, rubella and measles spreading through a population \cite{enns_its_2010}.

In it, people in a population of size $N$ can be in either one of three states \textit{Susceptible}, \textit{Infected} or \textit{Recovered} at a particular time, where it is assumed that initially there is at least one infected person in the population. People interact \textit{on average} with a given rate of $\beta$ other people per time-unit and become infected with a given probability $\gamma$ when interacting with an infected person. When infected, a person recovers \textit{on average} after $\delta$ time-units and is then immune to further infections. An interaction between infected persons does not lead to re-infection, thus these interactions are ignored in this model. 

We followed in our agent-based implementation of the SIR model the work \cite{macal_agent-based_2010} but extended the  by placing the agents on a discrete 2D grid using a Moore (8) neighbourhood TODO: cite my own PFE paper. In this case agents interact with each other indirectly through the shared discrete 2D grid by writing their current state on their cell which neighbours can read.

It is important to note that due to the continuous-time nature of the SIR model, our implementation follows the time-driven \cite{meyer_event-driven_2014} approach and maps naturally to the continuous time-semantics and state-transitions provided by FRP. By sampling the system with very small $\Delta t$ this means that we have comparatively very few writes to the shared environment which will become important when discussing the performance results.

In this case study we compare the performance of the following implementations under varying numbers of CPU cores:

\begin{enumerate}
	\item State Monad - This is the original implementation we also discuss in TODO: cite my own PFE paper. In it the discrete 2D grid is shared amongst all agents using the State Monad. Agents are run sequentially after another thus ensuring exclusive read/write access to it. Because we are neither running in the STM or IO Monad there is no way we can run this implementation concurrently.
	\item STM Monad - This is the same implementation like the State Monad but instead of sharing the discrete 2D grid in a State Monad, agents run in the STM Monad and have access to the discrete 2D grid through a \textit{TVar}. This means that the reads and writes of the discrete 2D grid are exactly the same but happen always through the \textit{TVar}. Also each agent is run within its own thread, thus enabling true concurrency when the simulation is actually run on multiple cores (which can be configured by the Haskell Runtime System).
	\item IO Monad - This is exactly the same implementation like the STM Monad but instead of running in STM, the agents now run in IO. They share the discrete 2D grid using an \textit{IORef} and have access to an \textit{MVar} to synchronise access to the it. Also each agent is run within its own thread.
	\item RePast - To have an idea where the functional implementation is performance-wise compared to the established object-oriented methods, we implemented a Java version of the SIR model using RePast with the State-Chart feature. This implementation cannot run on multiple cores concurrently but gives a good estimate of the single core performance of imperative approaches. Also there exists a RePast High Performance Computing library for implementing large-scale distributed simulations in C++ - we leave this for further research as an implementation and comparison is out of scope of this paper.
\end{enumerate}

Each experiment was run until $t = 100$ and stepped using $\Delta t = 0.1$ except in RePast for which we don't have access to the underlying implementation of the state-chart and left it as it is. For each experiment we conducted 8 runs on our machine (see Table \ref{tab:machine_specs}) and report both the average and standard deviation. Further, we checked the visual outputs and the dynamics and they look qualitatively the same to the reference implementation of the State Monad TODO: cite my own PFE paper. In the experiments we varied the number of agents (grid size) and the number of cores when running concurrently - the numbers are always indicated clearly.

\begin{table}
	\centering
	\begin{tabular}{ c || c }
		OS & Fedora 28 64-bit \\ \hline
		RAM & 16 GByte \\ \hline
		CPU & Intel Core i5-4670K @ 3.40GHz x 4 \\ \hline
		HD & 250Gbyte SSD \\ \hline
		Haskell & GHC 8.2.2 \\ \hline
		Java & OpenJDK 1.8.0 \\ \hline
		RePast & 2.5.0.a
	\end{tabular}
	
	\caption{Machine and Software Specs for all experiments}
	\label{tab:machine_specs}
\end{table}

\subsection{Constant Grid Size, Varying Cores}
In this experiment we held the grid size constant to 51 x 51 (2601 agents) and varied the cores where possible. The results are reported in Table \ref{tab:constgrid_varyingcores}.

State Monad
1.

\begin{table}
	\centering
  	\begin{tabular}{ c || c | c | c | c }
                	& Cores & Avg. Duration & $\sigma$ Duration & Retries Ratio \\ \hline \hline 
    	State Monad & 1     & TODO sec & TODO sec & N/A  \\ \hline \hline
   		STM Monad   & 1     & TODO sec & TODO sec & TODO \\ \hline
   		STM Monad   & 2     & TODO sec & TODO sec & TODO \\ \hline
   		STM Monad   & 3     & TODO sec & TODO sec & TODO \\ \hline
   		STM Monad   & 4     & TODO sec & TODO sec & TODO \\ \hline \hline
   		IO Monad    & 1     & TODO sec & TODO sec & N/A  \\ \hline 
   		IO Monad    & 2     & TODO sec & TODO sec & N/A  \\ \hline 
   		IO Monad    & 3     & TODO sec & TODO sec & N/A  \\ \hline 
   		IO Monad    & 4     & TODO sec & TODO sec & N/A  \\ \hline \hline
   		RePast      & 1     & TODO sec & TODO sec & N/A  \\ \hline 
  	\end{tabular}
  	
  	\caption{Experiments on constant 51x51 (2601 agents) grid with varying number of cores.}
	\label{tab:constgrid_varyingcores}
\end{table}

Comparing the scaling to multiple cores of the IO and STM implementation shows no significant difference between STM and IO as can be seen in Figure \ref{fig:core_duration_stm_io}.

\begin{figure}
	\centering
	\includegraphics[width=0.6\textwidth, angle=0]{./fig/core_duration_stm_io.png}
	\caption{Comparison of scaling IO and STM  to multiple cores. TODO: re-do this figure after we have collected 8 runs of the same}
	\label{fig:core_duration_stm_io}
\end{figure}

\subsection{Varying Grid Size, Constant Cores}
In this experiment we varied the grid size and used constantly 4 cores. The results for STM are reported in Table \ref{tab:varyinggrid_constcores_stm}. The results for IO are reported in Table \ref{tab:varyinggrid_constcores_stm}. The results for Repast are reported in Table \ref{tab:varyinggrid_constcores_repast} - note that these experiments all ran on a single (1) core and were conducted to have a rough estimate where the functional approach is in comparison to the imperative.

\begin{table}
	\centering
  	\begin{tabular}{ c || c | c | c }
        Grid-Size & Avg. Duration & $\sigma$ Duration & Retries Ratio \\ \hline \hline 
   		51 x 51   & TODO sec & TODO sec & TODO \\ \hline
   		101 x 101 & TODO sec & TODO sec & TODO \\ \hline
   		151 x 151 & TODO sec & TODO sec & TODO \\ \hline
   		201 x 201 & TODO sec & TODO sec & TODO \\ \hline 
   		251 x 251 & TODO sec & TODO sec & TODO \\ \hline
  	\end{tabular}
  	
  	\caption{STM Monad experiments on varying grid sizes on 4 cores.}
	\label{tab:varyinggrid_constcores_stm}
\end{table}

\begin{table}
	\centering
  	\begin{tabular}{ c || c | c }
        Grid-Size & Avg. Duration & $\sigma$ Duration \\ \hline \hline 
   		51 x 51   & TODO sec & TODO sec \\ \hline
   		101 x 101 & TODO sec & TODO sec \\ \hline
   		151 x 151 & TODO sec & TODO sec \\ \hline
   		201 x 201 & TODO sec & TODO sec \\ \hline 
   		251 x 251 & TODO sec & TODO sec \\ \hline 
  	\end{tabular}
  	
  	\caption{IO Monad experiments on varying grid sizes on 4 cores.}
	\label{tab:varyinggrid_constcores_IO}
\end{table}

\begin{table}
	\centering
  	\begin{tabular}{ c || c | c }
        Grid-Size & Avg. Duration & $\sigma$ Duration \\ \hline \hline 
   		51 x 51   & TODO sec & TODO sec \\ \hline
   		101 x 101 & TODO sec & TODO sec \\ \hline
   		151 x 151 & TODO sec & TODO sec \\ \hline
   		201 x 201 & TODO sec & TODO sec \\ \hline 
   		251 x 251 & TODO sec & TODO sec \\ \hline 
  	\end{tabular}
  	
  	\caption{Repast experiments on varying grid sizes on a single (1) core.}
	\label{tab:varyinggrid_constcores_repast}
\end{table}

The Figure \ref{fig:agent_by_duration} clearly indicates that STM outperforms the low level IO implementation by a substantial factor and scales much smoother.
\begin{figure}
	\centering
	\includegraphics[width=0.6\textwidth, angle=0]{./fig/agents_duration_stm_io.png}
	\caption{Comparison of STM (Table \ref{tab:agent_by_duration_stm}) and IO performance (Table \ref{tab:agent_by_duration_io}). TODO: put into a single performance comparison figure: State, STM, IO and RePast}
	\label{fig:agent_by_duration}
\end{figure}

As can be seen in Figure \ref{agent_by_duration_repast}, while on a 51x51 grid the single-core Java RePast version outperforms the 4-core Haskell STM version by about 200\%, the figure is inverted on a 201x201 grid where the 4-core Haskell STM version outperforms the single core Java Repast version by 400\%. We can conclude that the single-core Java RePast version clearly outperforms the Haskell STM 4-core version on small grid-sizes but that the Haskell STM version scales up with increasing grid-sizes and clearly outperforms the RePast version with increasing number of agents.

\begin{figure}
	\centering
	\includegraphics[width=0.6\textwidth, angle=0]{./fig/agents_duration_stm_repast.png}
	\caption{Comparison of 4-Core STM and single core Repast (Table \ref{tab:agent_by_duration_repast}).}
	\label{fig:agent_by_duration_repast}
\end{figure}

\subsection{Conclusions}
Interpretation of the performance data leads to the following conclusions:
\begin{enumerate}
	%\item On a single core, no transaction retries should happen, the results support that assumption.
	\item Running in STM and sharing state using a TVar is much more time- and memory-efficient than running in the State Monad.
	\item Running STM on multiple cores concurrently leads to a significant performance improvement (for that model).
	\item STM outperforms the low level locking implementation, running in the IO Monad, substantially and scales much smoother.
	\item Both STM and IO show same scaling performance on multiple cores, with the most significant improvement when scaling from a single to 2 cores.
	\item STM on single core is still slower than an object-oriented Java implementation on a single core.
	\item STM on multiple cores dramatically outperforms the single-core object-oriented Java implementation on a single core on instances with large agent numbers.
\end{enumerate}