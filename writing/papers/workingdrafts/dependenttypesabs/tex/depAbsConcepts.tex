\section{Concepts of Dependent Types in Agent-Based Simulation}
Independent of the programming paradigm, there exist fundamentally two approaches implementing agent-based simulation: time- and event-driven. In the time-driven approach, the simulation is stepped in fixed $\Delta t$ and all agents are executed at each time-step - they act virtually in lock-step at the same time. The approach is inspired by the theory of continuous system dynamics (TODO: cite).
In the event-driven approach, the system is advanced through events, generated by the agents, and the global system state changes by jumping from event to event, where the state is held constant in between. The approach is inspired by discrete event simulation (DES) (TODO: citation) which is formalized in the DEVS formalism \cite{zeigler_theory_2000}.

In a preceding paper we investigated how to derive a time-driven pure functional ABS approach in Haskell (TODO: cite my paper). We came to quite satisfactory results and implemented also a number of agent-based models of various complexity (TODO: cite schelling, sugarscape, agent zero). Still we identified weaknesses due to the underlying functional reactive programming (FRP) approach. It is possible to define partial implementations which diverge during runtime, which may be difficult to determine for complex models for a programmer at compile time. Also sampling the system with fixed $\Delta t$ can lead to severe performance problems when small $\Delta t$ are required, as was shown in our paper. The later problem is well known in the simulation community and thus as a remedy an event-driven approach was suggested \cite{meyer_event-driven_2014}.
In this paper for the first time, we derive a pure functional event-driven agent-based simulation. Instead of using Haskell, which provides already libraries for DES \cite{sorokin_aivika_2015}, we focus on the dependently typed pure functional programming language Idris. In our previous paper we hypothesised that dependent types may offer interesting new insights and approaches to ABS but it was unclear how exactly we can make use of them, which was left for further research. In this paper we hypothesise that, as opposed to a time-driven approach, the even-driven approach is especially suited to make proper use of dependent types due to its different nature. Note that both a pure functional event-driven approach to ABS \textit{and} the use of dependent types in ABS has so far never been investigated, which is the unique contribution of this paper.
If we can construct a dependently typed program of the SIR ABM which is total, then we have a proof-by-construction that the SIR model reaches a steady-state after finite time

Dependent Types are the holy grail in functional programming as they allow to express even stronger guarantees about the correctness of programs and go as far where programs and types become constructive proofs \cite{wadler_propositions_2015} which must be total by definition \cite{thompson_type_1991}, \cite{altenkirch_why_2005}, \cite{altenkirch_pi_sigma:_2010}, \cite{program_homotopy_2013}. Thus the next obvious step is to apply them to our pure functional approach of agent-based simulation. So far no research in applying dependent types to agent-based simulation exists at all and it is not clear whether dependent types do make sense in this setting. We explore this for the first time and ask more specifically how we can add dependent types to our pure functional approach, which conceptual implications this has for ABS and what we gain from doing so. Note that we can only scratch the surface and lay down basic ideas and leave a proper in-depth treatment of this topic for further research. We use Idris \cite{brady_idris_2013}, \cite{brady_type-driven_2017} as language of choice as it is very close to Haskell with focus on real-world application and running programs as opposed to other languages with dependent types e.g. Agda and Coq which serve primarily as proof assistants.

Dependent Types promise the following:

\begin{enumerate}
	\item Types as proofs - In dependently types languages, types can depend on any values and are first-class objects themselves. TODO: make more clear

	\item Totality and termination - Constructive proofs must terminate, this means a well-typed program (which is itself a proof) is always terminating which in turn means that it must consist out of total functions. A total function is defined by \cite{brady_type-driven_2017} as: it terminates with a well-typed result or produces a non-empty finite prefix of a well-typed infinite result in finite time. Idris is turing complete but is able to check the totality of a function under some circumstances but not in general as it would imply that it can solve the halting problem. Other dependently typed languages like Agda or Coq restrict recursion to ensure totality of all their functions - this makes them non turing complete.
\end{enumerate}

%An agent can be seen as a potentially infinite stream of continuations which at some point could return information to stop evaluating the next item of the stream which allows an agent to terminate.
%correspondence between temporal logics and FRP due to jeffery: is abs just another temporal logic?

dependent-types:
-> encode model-invariants on a meta-level
-> encode dynamics (what? feedbacks? positive/negative) on a meta-level
-> totality equals steady-state of a simulation, can enforce totality if required through type-level programming
-> probabilistic types can encode probability distributions in types already about which we can then reason
-> can we encode objectives in types?
-> agents as dependently typed continuations?: need a dependently typed concept of a process over time

As shown in our previous research (TODO: cite), the strong static type system of Haskell allows us to guarantee a lot already at compile time:
\begin{itemize}
	\item Purity - no side-effects possible at all 
	\item Monad - controlled, explicit side-effects possible
	\item generic types allow to guarantee for all
\end{itemize}

Dependent Types in Idris bring the strong static type system of Haskell to a new level, which allows us to both guarantee more things at compile time and express things through type-level computations. This means the following at compile time

\begin{itemize}
	\item Ruling out ever larger classes of bugs
	\item Dependent State Machines
	\item Dependent Agent Interactions
	\item Flow Of Time
	\item Totality
	\item Constructive Proofs
\end{itemize}

\subsection{Ruling out Bugs}
\begin{enumerate}
	\item Index out of bounds access of Lists and Vectors can be guaranteed not to happen any more when using proofs of existence of the element in the list or vector.
	\item Size of list or vector stays constant / increases / decreases / sum of length of multiple vectors guaranteed to be of some number
\end{enumerate}

The question is how far we can generalise our approaches because we fear that the downside of using dependently typed abs is that every implementation needs to start from Scratch: we cant write a general library for it like chimera because the more we put into types, the more specific it is => individual implementation which reuses existing 'patterns' like state machines, messages,...

\subsection{Dependent State Machines}
dependent state machines in abs for internal state because that is very Common in ABS

\subsection{Dependent Agent Interactions}
\subsubsection{Agent Transactions}
dependently typed message protocols in ABS because its very common, and easily done thorugh methods in OOP: sugarscape mating and trading protocol
\subsubsection{Data Flow}
TODO: can dependent types be used in the Data Flow Mechanism?
\subsubsection{Event Scheduling}
TODO: can dependent types be used in the event-scheduling mechanism?

\subsection{Flow Of Time}
TODO: can dependent types be used to express the flow of time and its strongly monotonic increasing?

\subsection{Totality}
totality of parts or the whole simulation

\subsection{Constructive Proofs}
- An agent-based model and the simulated dynamics of it is itself a constructive proof which explain a real-world phenomenon sufficiently good
- proof of the existence of an agent: holds always only for the current time-step