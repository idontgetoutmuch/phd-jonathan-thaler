\section{Introduction}
The traditional approach to Agent-Based Simulation (ABS) has so far always been object-oriented techniques, due to the influence of the seminal work of Epstein et al \cite{epstein_growing_1996} in which the authors claim "[..] object-oriented programming to be a particularly natural development environment for Sugarscape specifically and artificial societies generally [..]" (p. 179). This work established the metaphor in the ABS community, that \textit{agents map naturally to objects} \citep{north_managing_2007} which still holds up today.

In this paper we challenge this metaphor and explore ways of approaching ABS using the functional programming paradigm as in the language Haskell. By doing this we expect to leverage the benefits of it \citep{hudak_history_2007} to become available when implementing ABS functionally: expressing \textit{what} a system is instead of \textit{how} it works through declarative code, being explicit about the interactions of the program with the real world, explicit data-centric programming resulting in less sources of bugs and a strong static type system making type-errors at run-time obsolete. 

We formulate the hypothesis that by using functional programming, the advantages can directly be transferred to implementing ABS. Therefore, we hypothesise, it is harder to make mistakes, the resulting simulations are easier to test and verify, guaranteed to be reproducible, have less sources of bugs and are ultimately more likely to be correct. All of this is of paramount importance in scientific computing, in which results need to be reproducible and correct.

We present case-studies in which we employ the well known SugarScape \citep{epstein_growing_1996} and agent-based SIR \citep{macal_agent-based_2010} model to test our hypothesis. The former model can be seen as one of the most influential exploratory models in ABS which laid the foundations of object-oriented implementation of agent-based models. The latter one is an easy-to-understand explanatory model which has the advantage that it has an analytical theory behind it which can be used for verification and validation.

The aim of this paper is to show \textit{how} to implement ABS in functional programming using Haskell and \textit{why} it is of benefit of doing so. Further, we give the reader a good understanding of what functional programming is, what the challenges are in applying it to ABS and how we solve these in our approach. Although functional programming is a highly technical subject, we avoid technical discussions and follow a very high-level approach, focusing on the concepts instead of their implementation. For readers which are interested in technical details we refer to relevant literature in the respective parts of the paper.

The paper makes the following contributions:

\begin{itemize*}
	\item It is the first to \textit{systematically} introduce the functional programming paradigm, as in Haskell, to ABS, identifying its benefits, difficulties and drawbacks. 
	\item We show how functional ABS can be scaled up to massively large-scale without the problems of low level concurrent programming using Software Transactional Memory (STM). Although there exist STM implementations in non-functional languages like Java and Python, due to the nature of Haskells type-system, the use of STM has unique benefits in this setting.
	\item Further we introduce a powerful and very expressive approach to testing ABS implementations using property-based testing. This allows a much more powerful way of expressing tests, shifting from unit-testing towards specification-based testing. Although property-based testing has been brought to non-functional languages like Java and Python as well, it has its origins in Haskell and it is here where it truly shines.
\end{itemize*}
