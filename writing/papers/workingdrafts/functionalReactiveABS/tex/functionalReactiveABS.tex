\section{Functional Reactive ABS}
the fundamental problem is that unlike in oo e.g. java there are no objects and no implicit aliases through which to acess and change data: method calls are not there in FP. we must silve the problem of how to represent an agent and how agents can interact with each other

\subsection{Parallel vs. Sequential}
TODO: cite my own work

\subsection{Environment}
TODO: again cite my own work where I discussed the problem of environments

Each agent has a copy of the environment passed in through the AgentIn and can change it by passing a changed version of the environment out through AgentOut. 
In the sequential update-strategy the environment of the agent i will then be passed to all agents i + 1 AgentIn in the current iteration and override their old environment. Thus all steps of changes made to the environment are visible in the AgentOuts. The last environment is then the final environment int he current iteration and will be returned by the callback function together with the current AgentOuts.
In the parallel update-strategy the environment is duplicated to each agent and then each agent can work on it and return the changed environment. Thus after one iteration there are n versions of environments where n is equals to the number of agents. These environments must then be collapsed into a final one which is always domain-specific thus needs to be done through a function provided in the environment itself.
In both the sequential and parallel update-strategy after one iteration there is one single environment left. An environment can have an optional behaviour which allows the environment to update its cells. This is a regular SF thus having also the time of the simulation available. Note that the environment cannot send messages to agents because it is not an agent itself. An example of an environment behaviour would be to regrow some good on each cell according to some rate per time-unit (inspired by SugarScape regrowing of Sugar).


\subsection{Messaging}
TODO: again cite my own work where I discussed the problem of queued messaging

Each Agent can send a message to an other agent where the messages are queued and can be processed when the agent is updated the next time. The agent is free to ignore the messages and if it does not process them they will not be here in the next update.

\subsubsection{Conversation}
When sending messages between agents there is the limitation that an agent cannot reply to a message within the same iteration. In some models this is not a problem as it is not required by the model to reply to messages e.g. in the case of the SIR-Model where an agent just sends a 'Contact Infected' messages which infects the receiver with a given probability but the receiver does not reply to this message.
This limitation is for some models a huge problem which prevents a faithful implementation of it in FrABS. For this we introduce the concept of a conversation between agents. This allows an agent A to initiate a conversation with another agent B in which the simulation is and halted both can exchange an arbitrary number of messages through calling and responsing without time passing (something not possible without this concept because in each iteration the time advances). After either one agent has finished with the conversation it will terminate it and the simulation will continue with the updated agents.

\subsubsection{Sampling Time}
my wrongthinking: messaging ALWAYS takes time e.g. send/response roundtrip. conversations dont take time but are restricted for the receiver e.g. the receiver cannot send messages to others or change the environment in a conversation

because an agent cannot reply within the same timestep sampling interval becomes an issue: if we need a reply within a given time then the sampling interval needs to be at least twice as much

difference between discrete and continuous: the successor of discrete is defined whereas in the case of continuous it is not?
how is the successor defined in the case of continuous time?