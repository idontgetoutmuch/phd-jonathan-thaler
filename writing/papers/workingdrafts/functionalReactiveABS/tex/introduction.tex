\section{Introduction}
% Drop Cap Letter needed in case of IEEE Journal
%\IEEEPARstart{W}{ith}

In Agent-Based Simulation (ABS) one models and simulates a system by modeling and implementing the pro-active constituting parts of the system, called \textit{Agents} and their local interactions. From these local interactions then the emergent property of the system emerges. ABS is still a young field, having emerged in the early-to-mid 90s primarily in the fields of social simulation and computational economics. 

The authors of the seminal Sugarscape model \cite{epstein_growing_1996} explicitly advocate object-oriented programming as "a particularly natural development environment for Sugarscape specifically and artificial societies generally.". They implemented their simulation software in Object Pascal and C where they used the former for programming the agents and the latter for low-level graphics \cite{axtell_aligning_1996}. Axelrod \cite{axelrod_advancing_1997} recommends Java for experienced programmers and Visual Basic for beginners. Up until now most of the ABS community seems to have followed these suggestions and are implemented using programming languages of the object-oriented imperative paradigm.

A serious problem of object-oriented implementations is the blurring of the fundamental difference between agent and object - an agent is first of all a metaphor and \textit{not} an object. In object-oriented programming this distinction is obviously lost as in such languages agents are implemented as objects which leads to the inherent problem that one automatically reasons about agents in a way as they were objects - agents have indeed become objects in this case. The most notable difference between an agent and an object is that the latter one do not encapsulate behaviour activation \cite{jennings_agent-based_2000} - it is passive. Also it is remarkable that \cite{jennings_agent-based_2000} a paper from 1999 claims that object-orientation is not well suited for modelling complex systems because objects behaviour is too fine granular and method invocation a too primitive mechanism.

In \cite{axelrod_chapter_2006} Axelrod reports the vulnerability of ABS to misunderstanding. Due to informal specifications of models and change-requests among members of a research-team bugs are very likely to be introduced. He also reported how difficult it was to reproduce the work of \cite{axelrod_convergence_1995} which took the team four months which was due to inconsistencies between the original code and the published paper. The consequence is that counter-intuitive simulation results can lead to weeks of checking whether the code matches the model and is bug-free as reported in \cite{axelrod_advancing_1997}. As ABS is almost always used for scientific research, producing often break-through scientific results as pointed out in \cite{axelrod_chapter_2006} and used for policy making, these ABS need to be \textit{free of bugs}, \textit{verified against their specification}, \textit{validated against hypotheses} and ultimately be \textit{reproducible}.

Pure functional programming in Haskell claims \cite{hudak_history_2007}, \cite{hudak_haskell_1994} to overcome these problems or at least allows to tackle them more effectively due to its declarative nature, free of side-effects, strong static type system. In this paper we ask how ABS can be done in Haskell, what the benefits are and if it could overcome the issues mentioned above.

TODO: don't sell this paper as an opposing view against OOP (e.g. OOP is bad) but as a positive view: "for the first time it is possible to do ABMS in pure functional programming".
