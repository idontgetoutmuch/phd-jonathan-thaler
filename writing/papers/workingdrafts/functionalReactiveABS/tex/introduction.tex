\section{Introduction}
% Drop Cap Letter needed in case of IEEE Journal
%\IEEEPARstart{W}{ith}

The challenges one faces when specifying and implementing an Agent-Based Simulation (ABS\footnote{Throughout this text we will use the abbreviation ABS for Agent-Based Simulation, ABM for Agent-Based Modelling and ABMS when talking about both Agent-Based Simulation \& Modelling}) are manifold. One needs to think about how to represent an agent, how agents can pro-actively act, how agents do interact, how the environment is represented, how the agents can act on the environment and how structural dynamics - how creation and removal of agents - is handled. TODO: incorporate my own paper

TODO: the remainder of the introduction is too long and too detailed. the main point is that oo is diffcult and flawed and leads to problem.
TODO: shorten gintis, shorten verification \& validation but keep the reproducibility.
TODO: say that pure functional programming is a remedy against all these problems because: put in the discussions on pure functional programming from literature discussion in 1st year report
TODO: also put much emphasis on EDSL

Epstein \& Axtell explicitly advocate object-oriented programming in \cite{epstein_growing_1996} as "a particularly natural development environment for Sugarscape \cite{epstein_growing_1996} specifically and artificial societies generally." and report about 20.000 lines of code which includes GUI, graphs and plotting. They implemented their Sugarscape software in Object Pascal and C where they used the former for programming the agents and the latter for low-level graphics \cite{axtell_aligning_1996}. Axelrod \cite{axelrod_advancing_1997} recommends Java for experienced programmers and Visual Basic for beginners. Up until now most of ABS seems to have followed this suggestion and are implemented using programming languages which follow the object-oriented imperative paradigm.
The main concept in this paradigm are objects which provide abstraction, hiding implementation details and expose an abstract interface to the user of the object who does not (and should not) make any assumptions about implementation details. So in this paradigm the program consists of an implicit, global mutable state which is spread across multiple objects. 

Although object-oriented programming was invented to give programmers a better way of composing their code, strangely objects ultimately do \textit{not} compose \cite{bill_what_2017}, \cite{erkki_lindpere_why_2013}. The reason for this is that objects hide both \textit{mutation} and \textit{sharing through pointers or references} of object-internal data. This makes data-flow mostly implicit due to the side-effects on the mutable data which is globally scattered across objects. To deal with the problem of composability and implicit data-flow the seminal work \cite{gamma_design_1994} put forward the use of \textit{patterns} to organize objects and their interaction. Other concepts, trying to address the problems, were the SOLID principles and Dependency Injection. Although a huge step in the right direction, these concepts come with a very heavy overhead, are often difficult to understand and to apply and don't solve the fundamental problem \cite{lawrence_krubner_object_2014}. To put it short: even for experienced programmers, proper object-oriented programming \textit{is hard}. The difficulty arises from how to split up a problem into objects and their interactions and controlling the implicit mutation of state which is spread across all objects. Still if one masters the technique of object-oriented program-design and implementation, due to the implicit global mutable state bugs due to side-effects are the daily life of a programmer as shown below. Note that this critique of object-oriented programming addresses the deficits of this paradigm as it is implemented and in use today in languages likes Java and C++. The original idea of object-orientation, invented by Alan Kay \footnote{\url{http://wiki.c2.com/?AlanKaysDefinitionOfObjectOriented}} was very different than today and has much more common with the Actor Model as will be discussed in the literature-review.
Another serious problem of object-oriented implementations is the blurring of the fundamental difference between agent and object - an agent is first of all a metaphor and \textit{not} an object. In object-oriented programming this distinction is obviously lost as in such languages agents are implemented as objects which leads to the inherent problem that one automatically reasons about agents in a way as they were objects - agents have indeed become objects in this case. The most notable difference between an agent and an object is that the latter one do not encapsulate behaviour activation \cite{jennings_agent-based_2000} - it is passive. Also it is remarkable that \cite{jennings_agent-based_2000} a paper from 1999 claims that object-orientation is not well suited for modelling complex systems because objects behaviour is too fine granular and method invocation a too primitive mechanism.

In \cite{axelrod_chapter_2006} Axelrod reports the vulnerability of ABS to misunderstanding. Due to informal specifications of models and change-requests among members of a research-team bugs are very likely to be introduced. He also reported how difficult it was to reproduce the work of \cite{axelrod_convergence_1995} which took the team four months which was due to inconsistencies between the original code and the published paper. The consequence is that counter-intuitive simulation results can lead to weeks of checking whether the code matches the model and is bug-free as reported in \cite{axelrod_advancing_1997}.
The same problem was reported in \cite{ionescu_dependently-typed_2012} which tried to reproduce the work of Gintis \cite{gintis_emergence_2006}. In his work Gintis claimed to have found a mechanism in bilateral decentralized exchange which resulted in walrasian general equilibrium without the neo-classical approach of a tatonement process through a central auctioneer. This was a major break-through for economics as the theory of walrasian general equilibrium is non-constructive as it only postulates the properties of the equilibrium \cite{colell_microeconomic_1995} but does not explain the process and dynamics through which this equilibrium can be reached or constructed - Gintis seemed to have found just this process. Ionescu et al. \cite{ionescu_dependently-typed_2012} failed and were only able to solve the problem by directly contacting Gintis which provided the code - the definitive formal reference. It was found that there was a bug in the code which led to the "revolutionary" results which were seriously damaged through this error. They also reported ambiguity between the informal model description in Gintis paper and the actual implementation.
This lead to a research in a functional framework for agent-based models of exchange as described in \cite{botta_functional_2011} which tried to give a very formal functional specification of the model which comes very close to an implementation in Haskell.
This was investigated more in-depth in the thesis by \cite{evensen_extensible_2010} who got access to Gintis code of \cite{gintis_emergence_2006}. They found that the code didn't follow good object-oriented design principles (all was public, code duplication) and - in accordance with \cite{ionescu_dependently-typed_2012} - discovered a number of bugs serious enough to invalidate the results. This reporting seems to confirm the above observations that proper object-oriented programming is hard and if not carefully done introduces bugs.
The author of this text can report the same when implementing \cite{epstein_growing_1996}. Although the work tries to be much more clearer in specifying the rules how the agents behave, when implementing them still some minor inconsistencies and ambiguities show up due to an informal specification.
The fundamental problems of these reports can be subsumed under the term of verification which is the checking whether the implementation matches the specification. Informal specifications in natural language or listings of steps of behaviour will notoriously introduce inconsistencies and ambiguities which result in wrong implementations - wrong in the way that the \textit{intended} specification does not match the \textit{actual} implementation. To find out whether this is the case one needs to verify the model-specification against the code. This is a well established process in the software-industry but has not got as much attention and is not nearly as well established and easy in the field of ABS as will become evident in the literature-review.
As ABS is almost always used for scientific research, producing often break-through scientific results as pointed out in \cite{axelrod_chapter_2006}, these ABS need to be \textit{free of bugs}, \textit{verified against their specification}, \textit{validated against hypotheses} and ultimately be \textit{reproducible}. One of the biggest challenges in ABS is the one of validation. In this process one needs to connect the results and dynamics of the simulation to initial hypotheses e.g. \textit{are the emergent properties the ones anticipated? if it is completely different why?}. It is important to understand that we always \textit{must have} a hypothesis regarding the outcome of the simulation, otherwise we leave the path of scientific discovery. We must admit that sometimes it is extremely hard to anticipate \textit{emergent patterns} but still there must be \textit{some} hypothesis regarding the dynamics of the simulation otherwise we drift off into guesswork.

In the concluding remarks of \cite{axelrod_chapter_2006} Axelrod explicitly mentions that the ABS community should converge both on standards for testing the robustness of ABS and on its tools. However as presented above, we can draw the conclusion that there seem to be some problems the way ABS is done so far. We don't say that the current state-of-the-art is flawed, which it is not as proved by influential models which are perfectly sound, but that it always contains some inherent danger of embarrassing failure.

\subsection{Motivation}
The observations of the problems presented in the previous section leads us to posing fundamental directions and questions which are the basis of the motivation of our thesis.

\begin{enumerate}
	\item \textbf{Alternative approach to object-oriented ABS} - Is there an alternative view to the established object-oriented view to ABS which does treat agents \textit{not} like objects and does not mix the concept of agent and object? Is there an alternative to the established object-oriented implementation approach to ABS which offers composability, explicit data-flow?
	\item \textbf{Verification \& Validation of ABS} - Is there a way for formal specification and verification which is still readable and does not fall back to pure mathematics? What exactly is the meaning of validation in ABS and is there a way to do formal validation in ABS? 
\end{enumerate}