\section{The final step: Dependent Types}
Dependent Types are the holy grail in functional programming as they allow to express even stronger guarantees about the correctness of programs and go as far where programs and types become constructive proofs \cite{wadler_propositions_2015} which must be total by definition \cite{thompson_type_1991}, \cite{altenkirch_why_2005}, \cite{altenkirch_pi_sigma:_2010}, \cite{program_homotopy_2013}. Thus the next obvious step is to apply them to our pure functional approach of agent-based simulation. So far no research in applying dependent types to agent-based simulation exists at all and it is not clear whether dependent types do make sense in this setting. We explore this for the first time and ask more specifically how we can add dependent types to our pure functional approach, which conceptual implications this has for ABS and what we gain from doing so. Note that we can only scratch the surface and lay down basic ideas and leave a proper in-depth treatment of this topic for further research. We use Idris \cite{brady_idris_2013}, \cite{brady_type-driven_2017} as language of choice as it is very close to Haskell with focus on real-world application and running programs as opposed to other languages with dependent types e.g. Agda and Coq which serve primarily as proof assistants.

Dependent Types promise the following:

\begin{enumerate}
	\item Types as proofs - In dependently types languages, types can depend on any values and are first-class objects themselves. TODO: make more clear

	\item Totality and termination - Constructive proofs must terminate, this means a well-typed program (which is itself a proof) is always terminating which in turn means that it must consist out of total functions. A total function is defined by \cite{brady_type-driven_2017} as: it terminates with a well-typed result or produces a non-empty finite prefix of a well-typed infinite result in finite time. Idris is turing complete but is able to check the totality of a function under some circumstances but not in general as it would imply that it can solve the halting problem. Other dependently typed languages like Agda or Coq restrict recursion to ensure totality of all their functions - this makes them non turing complete.
\end{enumerate}

In the light of the promises of dependent types, we can identify weaknesses of our FRP approach. The authors \cite{sculthorpe_safe_2009} show that the type-system of Yampa is not safe as FRP is sacrificing the safety of FP for sake of expressiveness. Amongst others they showed that well-formed feedback does depend on the programmer and cannot be guaranteed at compile time through the type system. Feedback is an inherent feature of ABS where agents update their state at time t+1 depending on time t - this is only visible in step 2 where we used feedback to update the random-number generator (rec/iPre/feedback makes the inherently feedback nature of ABS very explicit) but in more complex ABS models with a more complex state than in the SIR model, feedback is the core feature to keep and update the state of an agent. Also a chain of switches could result in an infinite loop - this cannot be checked at compile time and needs to be carefully designed by the programmer and results sometimes in popping up of operational details (e.g. the need to use $>>> notYet$ in parallel switches for stepping the simulation). 
Another weakness of the approach is that implementing a more complicated agent-transaction protocol correctly can get very challenging. This might not seem directly evident from the implementation in Step 6 but the problem is that there are lots of operational details which the programmer needs to keep in mind and get right to arrive at a correctly working transaction. It would be nice if we have support from the type-system which enforces a given protocol but this is not possible with our approach so far. Note that beside failing to stick to the protocol it is also possible to implement non-total transactions. Note that making the transition from Yampa to the general MSF approach provided by Dunai and BearRiver does not solve this fundamental problem.
We could opt for a re-implementation of FRP in Idris by building on the work of \cite{sculthorpe_safe_2009} and \cite{jeffrey_causality_2013} who have laid out ideas for adopting arrowized FRP to dependent types in Agda \footnote{We have actually found an attempt of implementation of Yampa in Idris on GitHub: \url{https://github.com/BartAdv/idris-yampa} but we haven't tried it and development of the project seems to be inactive since 2 years.}. Unfortunately we would lack Ross Patersons \cite{paterson_new_2001} arrow notation which would force us to program our system in a point-free style which can get quite cumbersome and unreadable if the model to implement is complicated (which is easily the case in ABS). Thus we decide not to follow this road also for the sake of a fresh start, to free us from the FRP background and to see what a fresh approach in dependent types could offer to ABS.

%An agent can be seen as a potentially infinite stream of continuations which at some point could return information to stop evaluating the next item of the stream which allows an agent to terminate.
%correspondence between temporal logics and FRP due to jeffery: is abs just another temporal logic?

\subsection{A fresh start: focus on totality}
A SIR model enters a steady state as soon as there are no more infected agents. Thus we can informally argue that a SIR model must always terminate as:
\begin{enumerate}
	\item Only infected agents can infect susceptible agents.
	\item Eventually after a finite time every infected agent will recover.
	\item There is no way to move from the consuming \textit{recovered} state back into the \textit{infected} state \footnote{There exists an extended SIR model, called SIRS which adds a cycle to the state-machine by introducing a transition from recovered to susceptible but we don't consider that here.}.
\end{enumerate}

Thus a SIR model must enter a steady state after a finite amount of time. Using the DE presented in the introduction on the SD model we can show that the system enters a stable state in finite time (TODO: are there any references?):

TODO: show that it must terminate through the SD formulas. also calculate the t for when I(t)= 0

This result gives us the confidence, that the agent-based approach will terminate, given it is really a correct implementation of the SD model. Still this does not proof that the agent-based approach itself will terminate and so far no proof of the totality of it was given. Dependent Types and Idris ability for totality and termination checking should theoretically allow us to proof that an agent-based SIR implementation terminates after finite time: if an implementation of the agent-based SIR model in Idris is total it is a proof by construction. Note that such an implementation should not run for a limited virtual time but run unrestricted of the time and the simulation should terminate as soon as there are no more infected agents. We hypothesize that it should be possible due to the nature of the state transitions where there are no cycles and that all infected agents will eventually reach the recovered state. 
Abandoning the FRP approach and starting fresh, the question is how we implement a \textit{total} agent-based SIR model in Idris. Note that in the SIR model an agent is in the end just a state-machine thus the model consists of communicating / interacting state-machines. In the book \cite{brady_type-driven_2017} the author discusses using dependent types for implementing type-safe state-machines, so we investigate if and how we can apply this to our model. We face the following questions: how can we be total? can we even be total when drawing random-numbers? Also a fundamental question we need to solve then is how we represent time: can we get both the time-semantics of the FRP approach of Haskell AND the type-dependent expressivity or will there be a trade-off between the two?

TODO: implement sir with state-machine approach from Idris. an idea would be to let infected agents generate infection- actions: the more infected agents the more infection-actions => zero infected agents mean zero infection actions. this list can then be reduced?