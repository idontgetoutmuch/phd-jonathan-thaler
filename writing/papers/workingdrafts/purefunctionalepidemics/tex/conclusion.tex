\section{Conclusions and Further Research}
by leveraging on FRP we gain all the benefits and drawbacks of it.
testing, exploring: \cite{perez_testing_2017}, \cite{perez_back_2017}

Criticism of the FRP approach:
- can lead to infinite loops and needs much care of the programmer who has to consider operational details. This is already visible in the SIR model where we need to be careful to break a potential infinity loop in our simulation stepping. Also the state-machine of the SIR model is quite simple and thus the implementation quite straightforward, for more complex models with more complex e.g. nested state-machines, things will get pretty rough.
- having a two layer (arrows and pure functions) language in Yampa \cite{jeffrey_causality_2013} and three a layer (arrows, monadic and pure functions) language in Dunai / BearRiver adds expressivity and power but can makes things quite complex already in the simple SIR example. Fortunately with a more complex model the complexity in this context does not increase - in the end it is the price we need to pay for this high expressivity like occasionally.

We have also implemented synchronous interactions, which we termed agent-transactions in a 6th step but which we omitted due to lack of space (but can be looked at our github repo). Agent-transactions are necessary when TODO: explain . In the end, they can be seen as a kind of method-call emulation of oop with stronger typing.

We have built a full blown library for implementing pure agent-based simulation which implements and combines all the presented techniques including agent-transactions. As examples with implemented a number of well known agent-based models with various complexity, including the seminal Sugarscape model. Compared to object oriented implementations, the pure functional ones are quite concise and highly expressive. This shows that from an engineering point of view a pure functional approach to ABS is as well suited as object oriented techniques.

In the light of the promises of dependent types, we can identify weaknesses of our FRP approach. The authors \cite{sculthorpe_safe_2009} show that the type-system of Yampa is not safe as FRP is sacrificing the safety of FP for sake of expressiveness. Amongst others they showed that well-formed feedback does depend on the programmer and cannot be guaranteed at compile time through the type system. Feedback is an inherent feature of ABS where agents update their state at time t+1 depending on time t - this is only visible in step 2 where we used feedback to update the random-number generator (rec/iPre/feedback makes the inherently feedback nature of ABS very explicit) but in more complex ABS models with a more complex state than in the SIR model, feedback is the core feature to keep and update the state of an agent. Also a chain of switches could result in an infinite loop - this cannot be checked at compile time and needs to be carefully designed by the programmer and results sometimes in popping up of operational details (e.g. the need to use $>>> notYet$ in parallel switches for stepping the simulation). 
Another weakness of the approach is that implementing a more complicated agent-transaction protocol correctly can get very challenging. This might not seem directly evident from the implementation in Step 6 but the problem is that there are lots of operational details which the programmer needs to keep in mind and get right to arrive at a correctly working transaction. It would be nice if we have support from the type-system which enforces a given protocol but this is not possible with our approach so far. Note that beside failing to stick to the protocol it is also possible to implement non-total transactions. Note that making the transition from Yampa to the general MSF approach provided by Dunai and BearRiver does not solve this fundamental problem.
We could opt for a re-implementation of FRP in Idris by building on the work of \cite{sculthorpe_safe_2009} and \cite{jeffrey_causality_2013} who have laid out ideas for adopting arrowized FRP to dependent types in Agda \footnote{We have actually found an attempt of implementation of Yampa in Idris on GitHub: \url{https://github.com/BartAdv/idris-yampa} but we haven't tried it and development of the project seems to be inactive since 2 years.}. Unfortunately we would lack Ross Patersons \cite{paterson_new_2001} arrow notation which would force us to program our system in a point-free style which can get quite cumbersome and unreadable if the model to implement is complicated (which is easily the case in ABS). Thus we decide not to follow this road also for the sake of a fresh start, to free us from the FRP background and to see what a fresh approach in dependent types could offer to ABS.

Generally one can say that this pure functional approach is not as superior over traditional object-oriented approaches as one might think at first. There are the single real benefit is the lack of implicit side-effects and reproducibility guaranteed at compile time. The next step would be to make the move to dependent type which would pose a unique benefit over the object-oriented approach and builds on the existing pure functional approach.

Dependent Types are the holy grail in functional programming as they allow to express even stronger guarantees about the correctness of programs and go as far where programs and types become constructive proofs \cite{wadler_propositions_2015} which must be total by definition \cite{thompson_type_1991}, \cite{altenkirch_why_2005}, \cite{altenkirch_pi_sigma:_2010}, \cite{program_homotopy_2013}. Thus the next obvious step is to apply them to our pure functional approach of agent-based simulation. So far no research in applying dependent types to agent-based simulation exists at all and it is not clear whether dependent types do make sense in this setting. We explore this for the first time and ask more specifically how we can add dependent types to our pure functional approach, which conceptual implications this has for ABS and what we gain from doing so. Note that we can only scratch the surface and lay down basic ideas and leave a proper in-depth treatment of this topic for further research. We use Idris \cite{brady_idris_2013}, \cite{brady_type-driven_2017} as language of choice as it is very close to Haskell with focus on real-world application and running programs as opposed to other languages with dependent types e.g. Agda and Coq which serve primarily as proof assistants.

We barely scratched the surface when discussing the use of dependent types in ABS. In contrast to many dependently typed programs in our approach there is actually an interest and need in running them as only then the dynamics of the simulation unfold over time. So far we looked only at how we can ensure the correctness of our mechanisms when using dependent types. It would be of immense interest whether we could apply dependent types also to the model meta-level or not - this boils down to the question if we can encode our model specification in a dependent type way? This would allow the ABS community for the first time to reason about a proper formalisation of a model, something the ABS community hasn't been very fond of so far. Also could we reason about the dynamics in the types e.g. positive/negative feedback?

\subsection{Benefits}

\subsubsection{Continuous Time}
It seems that in our approach we combine the benefits of SD and ABS: we have continuous time-semantics but with individual, heterogenous agents.

\subsubsection{Code close to specification}
When looking at the code of the agent-based implementation in Appendix \ref{app:abs_code} and SD implementation in Appendix \ref{app:sd_code}, both look very much like a specification. By creating this EDSL which allows to express powerful time-semantics it is possible to now create an ABS in a declarative style in Haskell where the agent-implementation looks very much like a model-specification thus being correct by definition.
We claim that this is not only true for models with time-semantics but also with models which lack time-semantics and resemble a more imperative style of behaviour. We can also capture this using monadic programming using the State Monad for which we provide EDSL primitives as well which support all necessary operations in a monadic context.

\subsubsection{Being pure}
Because no part of the simulation runs in the IO monad and we do not use unsafePerformIO we can rule out a serious class of bugs caused by implicit data-dependencies and side-effects which can occur in traditional imperative implementations. Note that we actually use unsafePerformIO when one wants to generate unique agent-ids for new agents which are created during the simulation. This is necessary because in this case we need to guarantee that two invocations will result in two different ids, which would be difficult / impossible when running the simulation in the \textit{parallel} update-strategy. This is not a problem as long as an agent does not rely on the absolute value of an agent-id but just uses it as an opaque identifier for messaging.
Also we can statically guarantee the reproducibility of the simulation. Within the agents there are no side effects possible which could result in differences between same runs (e.g. file access, networking, threading, random-number seeding). Every agent has access to its own random-number generator, allowing randomness to occur in the simulation but the random-generator seed is fixed in the beginning and can never be changed within an agent to come from e.g. the current system time, which would require to run within the IO Monad. This means that after initialising the agents, which \textit{could} run in the IO Monad, the simulation itself runs completely deterministic.
We provide functionality to render the output to a window (using the Gloss library) or writing to a text-file, meaning, parts of the simulation would run in the IO Monad. Here we rely on Yampas \textit{reactimate} function which provides a well-defined way of communicating with the world in such a system. This function provides the $\Delta t$ for the next step, which \textit{could} come from IO Monad but we forbid this and keep the $\Delta t$ always fixed, thus removing another source of non-reproducibility where $\Delta t$ is influenced by sytem dependent non deterministic rendering-performance every step as happens in games or described by \cite{perez_testing_2017} in the context of FRP.

\subsubsection{Robust time handling}
The actual $\Delta t$ is never visible leads to an even more declarative style and supports the EDSL greatly. This also makes it impossible to mess around with time.

\subsubsection{Replications}
We nearly get replications for free without having to worry about side-effects and can even run them in parallel without headaches.

\subsection{Drawbacks}
We identify two main drawbacks.

\subsubsection{Performance}
Performance is currently no where near imperative object-oriented implementations. The reason for this is that we don't have in-place updates of data-structures and make no use of references. This results in lots of copying which is simply not necessary in the imperative languages with implicit effects. Also it is much more difficult to reason about time and space in our approach. Thus we see performance clearly as the main drawback of the functional approach and the only real advantage of the imperative approach over our.

\subsubsection{Steep learning curve}
Our approach is quite advanced in three ways. First it builds on the already quite involved FRP paradigm. Second it forces one to think properly of time-semantics of the model, how to sample it, how small $\Delta t$ should be and whether one needs super-sampling or not and if yes how many samples one should take. Third it requires to think about agent-interaction and update-strategies, whether one should use conversations which forces one to run sequentially or if one can run agents in parallel and use normal messaging which incurs a time-delay which in turn would need to be considered when setting the $\Delta t$.

\subsection{Agents As Signals}
Due to the underlying nature and motivation of FRP and Yampa, agents can be seen as signals which are generated and consumed by a signal-function which is the behaviour of an agent.  If an agent does not change, the output-signal should be constant and if the agent changes e.g. by sending a message, changing its state,... the output-signal should change as well. A dead agent then should have no signal at all.
The question is if the agents of our agent-based SIR implementation are true signals: do the dynamics stay constant when we sample the system with $\Delta t = 0$? We hypothesize that our agents are true signals, thus they should not change when time does not change because they are completely time-dependent and rely completely on time-semantics. When actually running the simulation with $\Delta t = 0$ one gets the results as seen in Figure \ref{fig:sir_abs_zero_dt}.
