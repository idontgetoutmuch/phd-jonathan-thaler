\subsection{Step V: Adding an environment}
In this step we will add an environment in which the agents exist and through which they interact with each other. This is a fundamental different approach to agent-agent interaction but is as valid as the interactions in the previous steps.
In ABS agents are often situated within a discrete 2d environment TODO: cite sugarscape, schelling, agentzero, which is simply a finite nxm grid with either a moore or neumann neighbourhood. Agents are either static or can move freely around with cells allowing either single or multiple occupants. 
We can directly transfer the SIR model to a discrete 2d environment by placing the agents on a corresponding 2d grid with a moore neighbourhood. The behaviour of the agents is the same but they select their neighbours directly from the environment using the moore neighbourhood. Also instead of using data-flow to communicate, agents now communicate through the environment by revealing their current state to their neighbours by placing it on their cell. Agents can read (actually they could write too) then the states of all their neighbours which tells them if a neighbour is infected or not. This allows us to implement the infection mechanism close to step 1 and 2.


\subsection{Reflection}
In step 3 and 4 we already have one variant of possible environment scenarios: the non-proactive read-only one. Implementing a pro-active read-only is easy: we use an agent as environment which broadcasts updates to all agents through data-flows. Implementing non pro-active read/write environments is very easy possible using MSFs and the StateT monad as shown in this step. If we want our environment to be pro-active e.g. regrowing some resources, then we simply add an environment-agent which acts upon the environment state. The convenient thing is that although conceptually all agents act at the same time, technically by using \textit{map} they are run after another which also serialises the environment access which gives every agent exclusive read/write access while it is active.
When attempting to introduce a non/pro-active read/write environment to the Yampa implementation it becomes quite cumbersome. A possible solution would be to add another type-parameter \textit{e} which captures the type of the environment and then pass it in through the input and allow it to be returned in the output of an agent signal-function. We would then end up with n copies of the environment - one for each agent - which we need to fold back into a single environment. When we have a pro-active environment we could also add it as another agent but this results in even more problems when folding it back - the solution would be to run a separate environment signal-function which acts on the folded environment after all agents are run. All these problems are not an issue when using MSFs with a StateT as they become obsolete.
In the last step we will introduce synchronised agent-transaction as the final agent-agent interaction mechanism. This is a quite sophisticated concept: synchronised agent-transactions which allow an arbitrary number of interactions between two agents without time lag. The use-case for this are price negotiations between multiple agents where the agents need to come to an agreement in the same time-step as described in TODO cite sugarscape.