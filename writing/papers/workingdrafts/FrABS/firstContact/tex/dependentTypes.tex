\section{The final step: Dependent Types}
Dependent Types are the holy grail in functional programming as they allow to express even stronger guarantees about the correctness of programs and go as far where programs become constructive proofs \cite{altenkirch_why_2005}, \cite{altenkirch_pi_sigma:_2010}, \cite{program_homotopy_2013}. Thus the logical final step is to apply them to our pure functional approach to agent-based simulation.
So far no research for applying dependent types to agent-based simulation exists at all and it is not clear whether dependent types do make sense in this setting.
In this section we explore this for the first time and ask more specifically how we can add dependent types to our pure functional agent-based simulation approach, which conceptual implications this has for ABS and what we gain from doing so.

\subsection{Totality and Termination}
TODO: discuss shortly
By totality of a function we understand that it produces an answer in finite time for all possible inputs. TODO: need more precision, see Idris talk 2 or 3?

\subsection{Types as proofs}
TODO: discuss shortly
\cite{wadler_propositions_2015}

\subsection{Practical application}
Can the theoretical benefits be translated to our practical approach? If yes how?

TODO: talk about idris \cite{brady_idris_2013}, \cite{brady_type-driven_2017} as language of choice as it is very close to the real world with focus on real application and running programs as opposed to e.g. Agda and Coq which serve primarily as proof assistants.

A weakness of our FRP approach is that the type-system of Yampa is not safe as was shown by \cite{sculthorpe_safe_2009}. The authors argued that FRP is sacrificing the safety of FP for sake of expressiveness. Amongst others they showed that well-formed feedback does depend on the programmer and cannot be guaranteed at compile time through the type system. Feedback is an inherent feature of ABS where agents update their state at time t+1 depending on time t - this is only visible in step 2 where we used feedback to update the random-number generator but in more complex ABS models with a more complex state than in the SIR model, feedback is the core feature to keep and update the state of an agent.  rec/iPre/feedback makes the inherently feedback nature of ABS very explicit. Also a chain of switches could result in an infinite loop - this cannot be checked at compile time and needs to be carefully designed by the programmer and results sometimes in popping up of operational details (e.g. use of >>> notYet in parallel switches). 
Another weakness of the approach is that implementing a more complicated agent-transaction protocol correct can get very challenging. This might not seem directly evident from the implementation in Step 6 but the problem is that there are lots of operational details which the programmer needs to keep in mind and get right to arrive at a correctly working transaction. It would be nice if we have support from the type-system which enforces a given protocol but this is not possible with out approach so far. Note that beside failing to stick to the protocol it is also possible to implement non-total transactions.
Note that making the transition from Yampa to the general MSF approach provided by Dunai and BearRiver does not solve this fundamental problem.


Totality and termination of agent behaviour can be checked (to a certain extent). Using the DE presented in the introduction on the SD model it is possible to show that the system enters a stable state in finite time (TODO: are there any references?) but so no proof of the totality of the agent-based approach was given. Dependent Types and Idris ability for totality and termination checking (to a certain extend) should theoretically allow us to proof that an agent-based SIR implementation terminates after finite time. If an implementation of the agent-based SIR model in Idris is total it is a proof by construction. Note that this implementation should not run for a limited virtual time but the time should be left open and the simulation should terminate as soon as there are no more infected agents. We hypothesize that it should be possible due to the nature of the state transitions where there are no cycles and that all infected agents will eventually reach the recovered state. Also could we reason about the dynamics in the types e.g. positive/negative feedback?

An agent can be seen as a potentially infinite stream of continuations which at some point could return information to stop evaluating the next item of the stream which allows an agent to terminate.
correspondence between temporal logics and FRP due to jeffery: is abs just another temporal logic?

TODO: how can we use types as proofs

Basically we have two potential directions to follow:
\begin{enumerate}
	\item Re-implement the FRP approach of Yampa, Dunai / BearRiver in Idris
	\item Develop something new in Idris specifically for ABS
\end{enumerate}

We could opt for a re-implementation of FRP in Idris by building on the work of \cite{sculthorpe_safe_2009} and \cite{jeffrey_causality_2013} who have laid out ideas for adopting arrowized FRP to dependent types in Agda \footnote{We have actually found an attempt of implementation of Yampa in Idris on github: \url{https://github.com/BartAdv/idris-yampa} but we haven't tried using it - and development of the project seems to be inactive since 2 years.}. Unfortunately we would lack Ross Patersons \cite{paterson_new_2001} arrow notation which would force us to program our system in a point-free style which can get quite cumbersome and unreadable if the model to implement is complicated (which is easily the case in ABS). Thus we decide not to follow this road also for the sake of a fresh start, to free us from the FRP background and to see what a fresh approach in dependent types could offer to ABS.

\subsection{A Fresh approach: State-Machines}
In the SIR model an agent is in the end just a state-machine thus the model consists of communicating / interacting state-machines. In the book \cite{brady_type-driven_2017} the author discusses using dependent types for implementing type-safe state-machines, so we investigate if and how we can apply this to our model.
TODO: implement sir with state-machine approach from Idris
A fundamental question we need to solve then is how we represent time: can we get both the time-semantics of the FRP approach of Haskell AND the type-dependent expressivity or will there be a trade-off between the two?

Out first attempt is to implement a total version of the agent-based SIR model which does NOT restrict the time to run the simulation for but which terminates automatically if there is no more infected agent and returns the time at which it terminated. We know that a simply SIR model must always terminate as:
\begin{enumerate}
	\item Only infected agents can infect susceptible agents.
	\item Eventually after a finite time every infected agent will recover.
	\item There is no way to move from the consuming \textit{recovered} state back into the infected state.
\end{enumerate}
Thus a SIR model must enter a steady state after a finite amount of time. If we can formulate a total program which implements the agent-based SIR model we have a constructive proof that the agent-based SIR model terminated in finite time. This can be done using the equations of the SD approach but in an agent-based setting no such formal proofs have been done yet.