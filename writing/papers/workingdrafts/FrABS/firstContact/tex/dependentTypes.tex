\section{The final step: Dependent Types}
Dependent Types are the holy grail in functional programming as they allow to express even stronger guarantees about the correctness of programs and go as far where programs become constructive proofs \cite{altenkirch_why_2005}, \cite{altenkirch_pi_sigma:_2010}, \cite{program_homotopy_2013}. Thus the logical final step is to apply them to our pure functional approach to agent-based simulation.
So far no research for applying dependent types to agent-based simulation exists at all and it is not clear whether dependent types do make sense in this setting.
In this section we explore this for the first time and ask more specifically how we can add dependent types to our pure functional agent-based simulation approach, which conceptual implications this has for ABS and what we gain from doing so.

\subsection{Theoretical benefits}
\subsubsection{Totality and Termination}
TODO: discuss shortly
By totality of a function we understand that it produces an answer in finite time for all possible inputs. TODO: need more precision, see Idris talk 2 or 3?

\subsubsection{Types as proofs}
TODO: discuss shortly
\cite{wadler_propositions_2015}

\subsection{Practical application}
Can the theoretical benefits be translated to our practical approach? If yes how?

TODO: talk about idris \cite{brady_idris_2013}, \cite{brady_type-driven_2017} as language of choice as it is very close to the real world with focus on real application and running programs as opposed to e.g. Agda and Coq which serve primarily as proof assistants.

A weakness of our FRP approach is that the type-system of Yampa is not safe as was shown by \cite{sculthorpe_safe_2009}. The authors argued that FRP is sacrificing the safety of FP for sake of expressiveness. Amongst others they showed that well-formed feedback does depend on the programmer and cannot be guaranteed at compile time through the type system. Feedback is an inherent feature of ABS where agents update their state at time t+1 depending on time t - this is only visible in step 2 where we used feedback to update the random-number generator but in more complex ABS models with a more complex state than in the SIR model, feedback is the core feature to keep and update the state of an agent.  rec/iPre/feedback makes the inherently feedback nature of ABS very explicit. Also a chain of switches could result in an infinite loop - this cannot be checked at compile time and needs to be carefully designed by the programmer and results sometimes in popping up of operational details (e.g. use of >>> notYet in parallel switches). 
Another weakness of the approach is that implementing a more complicated agent-transaction protocol correct can get very challenging. This might not seem directly evident from the implementation in Step 6 but the problem is that there are lots of operational details which the programmer needs to keep in mind and get right to arrive at a correctly working transaction. It would be nice if we have support from the type-system which enforces a given protocol but this is not possible with out approach so far. Note that beside failing to stick to the protocol it is also possible to implement non-total transactions.
Note that making the transition from Yampa to the general MSF approach provided by Dunai and BearRiver does not solve this fundamental problem.


Totality and termination of agent behaviour can be checked (to a certain extent). Using the DE presented in the introduction on the SD model it is possible to show that the system enters a stable state in finite time (TODO: are there any references?) but so no proof of the totality of the agent-based approach was given. Dependent Types and Idris ability for totality and termination checking (to a certain extend) should theoretically allow us to proof that an agent-based SIR implementation terminates after finite time. If an implementation of the agent-based SIR model in Idris is total it is a proof by construction. Note that this implementation should not run for a limited virtual time but the time should be left open and the simulation should terminate as soon as there are no more infected agents. We hypothesize that it should be possible due to the nature of the state transitions where there are no cycles and that all infected agents will eventually reach the recovered state. Also could we reason about the dynamics in the types e.g. positive/negative feedback?

An agent can be seen as a potentially infinite stream of continuations which at some point could return information to stop evaluating the next item of the stream which allows an agent to terminate.
correspondence between temporal logics and FRP due to jeffery: is abs just another temporal logic?

TODO: how can we use types as proofs

Basically we have two potential directions to follow:
\begin{enumerate}
	\item Re-implement the FRP approach of Yampa, Dunai / BearRiver in Idris
	\item Develop something new in Idris specifically for ABS
\end{enumerate}

\subsection{Re-implement FRP}
Arrowised yes / no? but we don't have Ross Patersons arrow-notation which makes programming with them in point-free style very annoying and difficult for more complex models.
TODO: implement very simple FRP in Idris?
my intuition: don't follow this approach, maybe we find a unique way of doing ABS / FRP in dependent types? For now we don't go there as fundamental ideas have been already laid out by \cite{sculthorpe_safe_2009} \footnote{We have actually found an attempt of implementation of Yampa in Idris on github: \url{https://github.com/BartAdv/idris-yampa} but we haven't tried using it - and development of the project seems to be inactive since 2 years.}

\subsection{A Fresh approach: State-Machines}
In the SIR model an agent is in the end just a state-machine thus the model consists of communicating / interacting state-machines. In the book \cite{brady_type-driven_2017} the author discusses using dependent types for implementing type-safe state-machines, so we investigate if and how we can apply this to our model.
TODO: implement sir with state-machine approach from Idris
A fundamental question we need to solve then is how we represent time: can we get both the time-semantics of the FRP approach of Haskell AND the type-dependent expressivity or will there be a trade-off between the two?