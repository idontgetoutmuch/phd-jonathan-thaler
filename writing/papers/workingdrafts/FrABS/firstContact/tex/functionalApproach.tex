\section{Deriving a functional approach}
%2 main points from Henrik: 1.: try to stick to synchronous updates because this is how the real world works. 2.: get rid of globally shared mutable state as it complicates things extremely with reasoning
%clear conceptual formal model of what agents are and then structure my implementation around it

In this section we will derive a functional approach for implementing an agent-based simulation of the SIR model. We will start out with a very naive approach and show its limitations which can be overcome by bringing in FRP. Then in three steps we will add more concepts and generalisations, ending up at the final approach which utilises monadic stream functions (MSF) \cite{perez_functional_2016}, a generalisation of FRP.
Although we presented a high-level agent-based approach to the SIR model in the previous section, which focused only on the states and the transitions, we haven't talked about technical implementation details on how to actually implement such a state-machine. In these steps we will ultimately present four different approaches on how to implement these states and transitions. Although all result \textit{on average} in the same dynamics, not all of them are equally expressive and testable.

\subsection*{Step I: Naive beginnings}
In our first step we start with modelling the states of the agents for which we simply use an Algebraic Data Type (ADT):

\begin{minted}[fontsize=\footnotesize]{haskell}
data SIRState = Susceptible | Infected | Recovered
\end{minted}

Also agents are ill for some duration meaning we need to keep track when a potentially infected agent recovers. Also as previously mentioned, a simulation is stepped in discrete or continuous time-steps thus we introducing a notion of \textit{time} and $\Delta t$ by defining:

\begin{minted}[fontsize=\footnotesize]{haskell}
type Time      = Double
type TimeDelta = Double
\end{minted}

Then we can represent every agent simply as a tuple of its state and its potential recovery time. We hold all our agents simply in a list and define helper functions:
\begin{minted}[fontsize=\footnotesize]{haskell}
type SIRAgent = (SIRState, Time)
type Agents   = [SIRAgent]

is :: SIRState -> SIRAgent -> Bool
is s (s',_) = s == s'

susceptible :: SIRAgent
susceptible = (Susceptible, 0)

infected :: Time -> SIRAgent
infected t = (Infected, t)

recovered :: SIRAgent
recovered = (Recovered, 0)
\end{minted}

Next we need to think about how to actually step our simulation. For this we define a function which simply steps our simulation with a fixed $\Delta t = 1.0$ until $t = 150$ where in each step the agents are processed and the output is fed back into the next step.
TODO: need a much better explanation and maybe split up into more steps?
As already mentioned in previous sections, the agent-based implementation of the SIR model is inherently stochastic which means we need access to a random-number generator. We decided to use the Rand Monad at this point as threading a generator through the simulation and the agents is very cumbersome. Thus our simulation stepping runs in the Rand Monad:

\begin{minted}[fontsize=\footnotesize]{haskell}
runSimulation :: RandomGen g 
              => Time 
              -> TimeDelta 
              -> Agents 
              -> Rand g [Agents]
runSimulation tEnd dt as = runSimulationAux 0 dt as []
  where
    runSimulationAux :: RandomGen g 
                     => Time 
                     -> TimeDelta 
                     -> Agents 
                     -> [Agents] 
                     -> Rand g [Agents]
    runSimulationAux t dt as acc
      | t >= tEnd = return $ reverse (as : acc)
      | otherwise = do
        as' <- stepSimulation dt as 
        runSimulationUntilAux (t + dt) dt as' (as : acc)

stepSimulation :: RandomGen g => TimeDelta -> Agents -> Rand g Agents
stepSimulation dt as = mapM (processAgent dt as) as
\end{minted}

Now we can implement the behaviour of an individual agent.
It is important to try to infect the agent for every infected contact and not for a signle one.

\subsubsection{Results}
TODO: show results

\subsubsection{Pros}
first approach, it works, having random-monad is VERY convenient

\subsubsection{Cons}
- time is explicitly available and needs to be dealt with explicitly
- all agent-states are fed back into every agent
- agent representation and function is not very elegant 

\subsection{Step II: Adding FRP}
CODE in SIRYampa

- time is implicit and cannot be messed with
- agent can switch their behaviour

\subsection{Step III: Adding data-flow}
- getting rid of feeding all agent-states back into every agent, making data-flows explicit between agents, which is necessary because connections between agents are not fixed at compile time
- with occasionally we can achieve extremely fine grained stochastics as opposed to draw random number of events we create only a single event or not, this allows for a much smoother curve and is a real advantage: we are treating it as a continuous system

\subsection{Step IV: Generalising to Monadic Stream Functions}
- this allows us to add dynamic environments and agent transactions
- we need deterministic behaviour under all curcumstances, thus we cannot use IO or STM. for globally mutable state we use StateT
- also putting agentout into StateT monad composes now much better

\subsection{Step V: Adding an environment}

\subsection{Step VI: Adding agent transactions}
