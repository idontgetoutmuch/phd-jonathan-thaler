\section{FrABS SIR Code}

\begin{minted}[fontsize=\footnotesize, linenos]{haskell}
data SIRState = Susceptible | Infected | Recovered deriving (Eq, Show)
data FrSIRMsg = Contact SIRState deriving (Eq, Show)

type FrSIRAgentState = SIRState

type FrSIREnvironment = [AgentId]

type FrSIRAgentDef = AgentDef FrSIRAgentState FrSIRMsg FrSIREnvironment
type FrSIRAgentBehaviour = AgentBehaviour FrSIRAgentState FrSIRMsg FrSIREnvironment
type FrSIRAgentIn = AgentIn FrSIRAgentState FrSIRMsg FrSIREnvironment
type FrSIRAgentOut = AgentOut FrSIRAgentState FrSIRMsg FrSIREnvironment
type FrSIRAgentObservable = AgentObservable FrSIRAgentState

type FrSIREventSource = EventSource FrSIRAgentState FrSIRMsg FrSIREnvironment
type FrSIRMessageSource = MessageSource FrSIRAgentState FrSIRMsg FrSIREnvironment
type FrSIRReplicationConfig = ReplicationConfig FrSIRAgentState FrSIRMsg FrSIREnvironment

-------------------------------------------------------------------------------
infectivity :: Double
infectivity = 0.05

contactRate :: Double
contactRate = 5

illnessDuration :: Double
illnessDuration = 15

contactSS :: Int
contactSS = 20

illnessTimeoutSS :: Int
illnessTimeoutSS = 2

-------------------------------------------------------------------------------
createFrSIRNumInfected :: Int -> Int -> IO ([FrSIRAgentDef], FrSIREnvironment)
createFrSIRNumInfected agentCount numInfected = do
    let agentIds = [0 .. (agentCount-1)]
    let infectedIds = take numInfected agentIds
    let susceptibleIds = drop numInfected agentIds

    adefsSusceptible <- mapM (frSIRAgent Susceptible) susceptibleIds
    adefsInfected <- mapM (frSIRAgent Infected) infectedIds

    return (adefsSusceptible ++ adefsInfected, agentIds)

frSIRAgent :: SIRState -> AgentId -> IO FrSIRAgentDef
frSIRAgent initS aid = do
    rng <- newStdGen
    let beh = sirAgentBehaviour rng initS
    let adef = AgentDef { 
          adId = aid
        , adState = initS
        , adBeh = beh
        , adInitMessages = NoEvent
        , adConversation = Nothing
        , adRng = rng 
        }

    return adef
   
-------------------------------------------------------------------------------
-- UTILITIES
gotInfected :: FrSIRAgentIn -> Rand StdGen Bool
gotInfected ain = onMessageM gotInfectedAux ain False
  where
    gotInfectedAux :: Bool -> AgentMessage FrSIRMsg -> Rand StdGen Bool
    gotInfectedAux False (_, Contact Infected) = randomBoolM infectivity
    gotInfectedAux x _ = return x

respondToContactWith :: SIRState -> FrSIRAgentIn -> FrSIRAgentOut -> FrSIRAgentOut
respondToContactWith state ain ao = onMessage respondToContactWithAux ain ao
  where
    respondToContactWithAux :: AgentMessage FrSIRMsg -> FrSIRAgentOut -> FrSIRAgentOut
    respondToContactWithAux (senderId, Contact _) ao = sendMessage (senderId, Contact state) ao

-- SUSCEPTIBLE
sirAgentSuceptible :: RandomGen g => g -> FrSIRAgentBehaviour
sirAgentSuceptible g = 
	transitionOnEvent 
		sirAgentInfectedEvent 
		(sirAgentSusceptibleBehaviour g) 
		(sirAgentInfected g)

sirAgentInfectedEvent :: FrSIREventSource
sirAgentInfectedEvent = proc (ain, ao) -> do
    let (isInfected, ao') = agentRandom (gotInfected ain) ao
    infectionEvent <- edge -< isInfected
    returnA -< (ao', infectionEvent)

sirAgentSusceptibleBehaviour :: RandomGen g => g -> FrSIRAgentBehaviour
sirAgentSusceptibleBehaviour g = proc (ain, e) -> do
    let ao = agentOutFromIn ain
    ao1 <- doOnce (setDomainState Susceptible) -< ao
    ao2 <- sendMessageOccasionallySrcSS 
    		g
    		(1 / contactRate)
    		contactSS
    		(randomAgentIdMsgSource (Contact Susceptible) True) -< (ao1, e)
    returnA -< (ao2, e)

-- INFECTED
sirAgentInfected :: RandomGen g => g -> FrSIRAgentBehaviour
sirAgentInfected g = 
	transitionAfterExpSS 
		g 
		illnessDuration 
		illnessTimeoutSS 
		(sirAgentInfectedBehaviour g) 
		sirAgentRecovered

sirAgentInfectedBehaviour :: RandomGen g => g -> FrSIRAgentBehaviour
sirAgentInfectedBehaviour g = proc (ain, e) -> do
    let ao = agentOutFromIn ain
    ao1 <- doOnce (setDomainState Infected) -< ao
    let ao2 = respondToContactWith Infected ain ao1
    returnA -< (ao2, e)

-- RECOVERED
sirAgentRecovered :: FrSIRAgentBehaviour
sirAgentRecovered = setDomainStateReact Recovered

-- INITIAL CASES
sirAgentBehaviour :: RandomGen g => g -> SIRState -> FrSIRAgentBehaviour
sirAgentBehaviour g Susceptible = sirAgentSuceptible g
sirAgentBehaviour g Infected = sirAgentInfected g
sirAgentBehaviour _ Recovered = sirAgentRecovered

-------------------------------------------------------------------------------
runFrSIRSteps :: IO ()
runFrSIRSteps = do
	-- no collapsing/updating of environment
    params <- initSimulation updateStrategy Nothing Nothing shuffleAgents (Just rngSeed)
    
    (initAdefs, initEnv) <- createFrSIRNumInfected agentCount numInfected
    
    let dynamics = simulateAggregateTime initAdefs initEnv params dt t aggregate

	print dynamics
	
aggregate :: ([FrSIRAgentObservable], FrSIREnvironment) -> (Double, Double, Double)
aggregate (aobs, _) = (susceptibleCount, infectedCount, recoveredCount)
  where
    susceptibleCount = fromIntegral $ length $ filter ((Susceptible==) . snd) aobs
    infectedCount = fromIntegral $ length $ filter ((Infected==) . snd) aobs
    recoveredCount = fromIntegral $ length $ filter ((Recovered==) . snd) aobs
\end{minted}