\section{Conclusion and future research}
In this paper we presented a novel approach to implement agent-based models by Functional Reactive Programming (FRP) in Haskell building on the library Yampa which we termed Functional Reactive Agent-Based Simulation \footnote{For this research implemented a prototype library called \textit{FrABS} which is available under \url{https://github.com/thalerjonathan/phd/tree/master/coding/libraries/frABS}. We plan on releasing it on Hackage in the future.}.

In general, FRP tries to shift the direction of data-flow, from message passing onto data dependency. This helps reason about what things are over time, as opposed to how changes propagate TODO: cite ivan perez phd thesis. This of course raises the question whether FRP is \textit{really} the right approach, because in our approach to ABS, messaging is an essential concept. It is important to emphasis that agent relations in interactions are never fixed in advance and are completely dynamic, forming a network. Maybe one has to look at messaging in a different way in FRP and to view and model it as a data-dependency but it is not clear how this can be done. The question is whether there is a mechanism in which we have explicit data-dependency but which is dynamic like messaging.

In the paper, TODO: cite my own art of iterating paper, the authors discuss four update-strategies of which we implemented only the \textit{sequential} and \textit{parallel} ones. The other two strategies are inherent concurrent ones, thus to implement them would require the agents to use concurrency features like STM or run in the IO Monad. Unfortunately both require monadic code which is not possible in Yampa. In \cite{perez_functional_2016} the authors provide a generalisation to FRP which also allows to run monads in FRP, which would make running the agents in the STM Monad possible. Using this approach we could then implement true concurrent agents allowing to implement the other two update-strategies. It would be interesting to see the benefits and drawbacks of our approach in these two strategies, especially when treating agents like signals as in the case of our SIR implementation. We leave this for further research.

Functional Programming is particularly strong for reasoning about an implementation and verification of an implemented model. How we can test, reason about and verify implemented models of ABS in our apprach, we leave for further research in an accompanying paper which will be written for the agent-based simulation audience.