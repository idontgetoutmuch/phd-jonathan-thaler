\section{Introduction}
When implementing an agent-based simulation (ABS) it is of utmost importance that the implementation is correct up to a specification, which is the model. To ensure that an implementation matches a specification, one uses verification, which ensures that \textit{"we are building the model right"} (TODO: cite). With the established approaches in the field of ABS, which are primarily the object-oriented programming languages Java and Python, it is very difficult, or might even be impossible to \textit{formally} prove that an implementation is correct up to a specification. Also one can say in general that formal proofs of correctness are highly complex and take a lot of effort and are almost always beyond the scope of a project and just not feasible. Still, not checking the correctness of the implementation in \textit{some} way would be highly irresponsible and thus software engineers have developed the concept of unit-testing and test-driven development (todo: cite). Put shortly, in test-driven development one implements unit-tests for each feature to implement before actually implementing the feature. Then the features is implemented and the tests for it should pass. This cycle is repeated until the implementation of all requirements has finished. Of course it is important to cover the whole functionality with tests to be sure that all cases are checked which can be supported by code coverage tools to ensure that all code-paths have been tested.
Thus we can say that test-driven development in general and unit-testing together with code-coverage in particular, allow to guarantee the correctness of an implementation to some informal degree which has been proven to be sufficiently enough through years of practice in the software industry all over the world. Also a fundamental strength of such tests is that programmers gain much more confidence when making changes to code - without such tests all bets are off and there is no reliable way to know whether the changes have broken something or not.
The work of \cite{collier_test-driven_2013} discusses the use of test-driven development with unit-tests to implement ABS and we support the position that every ABS which has some degree of complexity and is used for some form of policy or decision making should be thoroughly tested.

In this paper we discuss a complementary method of testing the implementation of an ABS, called property-based testing, which to our best knowledge has not been discussed in the field of ABS yet. We present two models for case-studies. First, the SIR model, which is of explanatory nature, where we show how to express formal model-specifications in property-tests. Second, the SugarScape model, which is exploratory nature, where we  show how to express hypotheses in property-tests.

Property-based testing has its origins in the pure functional programming language Haskell (TODO: cite quickcheck papers and history of haskell paper) so we discuss it from that perspective. We show that besides property-based testing, Haskell has a lot more to offer in regards to testing and guaranteeing the correctness of an ABS implementation. Simply by switching to this language removes a large class of run-time bugs and allows to make stronger guarantees about the correctness of the ABS implementation, making the implementation \textit{very likely} to be correct.

The aim of this paper is to investigate the potential of property-based testing which allows to directly express model-specifications in code and test them. 

The contributions of this paper are:
\begin{itemize}
	\item Showing that by simply switching to a pure functional programming language removes a large class of run-time errors and allows much stronger guarantees of correctness already at compile time and without actual need of tests.
	\item Expanding the testing techniques of ABS implementations by property-based testing, an additional, highly expressive method from which we hope it makes testing easier and ABS implementations which utilise it more likely to be correct.
\end{itemize}

The structure of the paper is as follows. To make this paper sufficiently self-contained we give a brief introduction of the concepts of pure functional programming in Haskell in Section TODO. Then we introduce property-based testing in general in Section TODO. Then we present both case-studies in Section TODO and Section TODO. We follow with related work in Section TODO. Finally we conclude and give further research in Section TODO. 