\section{Deriving a pure functional approach}
\label{sec:functional_approach}

We presented a high-level agent-based approach to the SIR model in the previous section, which focused only on the states and the transitions, but we haven't talked about technical implementation. 

In \cite{thaler_art_2017} two fundamental problems of implementing an agent-based simulation from a programming-language agnostic point of view is discussed. The first problem is how agents can be pro-active and the second how interactions and communication between agents can happen. For agents to be pro-active, they must be able to perceive the passing of time, which means there must be a concept of an agent-process which executes over time. Interactions between agents can be reduced to the problem of how an agent can expose information about its internal state which can be perceived by other agents. Further the authors have shown the influence of different deterministic and non-deterministic elements in agent-based simulation on the dynamics and how the influence of non-determinism can completely break them down or result in different dynamics despite same initial conditions. This means that we want to rule out any potential source of non-determinism.

In this section we will derive a pure functional approach for an agent-based simulation of the SIR model in which we will pose solutions to the previously mentioned problems. We will start out with a very naive approach and show its limitations which we overcome by adding FRP. Then in further steps we will add more concepts and generalisations, ending up at the final approach which utilises Monadic Stream Functions, a generalisation of FRP. 

Of paramount importance is to keep our implementations pure which rules out the use of the IO Monad and thus any potential source of non-determinism under all circumstances because we would loose all compile time guarantees about reproducibility. Still we will make use of the Random and State Monad which indeed allow side-effects but the crucial point here is that we restrict side-effects only to these types in a controlled way without allowing general unrestricted effects
\footnote{The code of all steps can be accessed freely through the following URL: \url{https://github.com/thalerjonathan/phd/tree/master/public/purefunctionalepidemics/code}}.

\input{./tex/naiveBeginning.tex}

\input{./tex/addingFRP.tex}

\input{./tex/generalisingMSF.tex}

\input{./tex/addingEnvironment.tex}

\subsection{Additional Steps}
ABS involves a few more advanced concepts which we didn't fully explore in this paper due to lack of space. Instead we give a short overview and discuss them without presenting code or going into technical details.

\subsubsection{Agent-Transactions}
Agent-transactions are necessary when an arbitrary number of interactions between two agents need to happen instantaneously without time-lag. The use-case for this are price negotiations between multiple agents where each pair of agents needs to come to an agreement in the same time-step \cite{epstein_growing_1996}. In object-oriented programming, the concept of synchronous communication between agents is implemented directly with method calls.

We have implemented synchronous interactions, which we termed agent-transactions in an additional step. We solved it pure functionally by running the signal functions of the transacting agent pair as often as their protocol requires but with $\Delta t=0$, which indicates the instantaneous character of agent-transactions.

\subsubsection{Event Scheduling}
Our approach is inherently time-driven where the system is sampled with fixed $\Delta t$. The other fundamental way to implement an ABS in general, is to follow an event-driven approach \cite{meyer_event-driven_2014} which is based on the theory of Discrete Event Simulation \cite{zeigler_theory_2000}. In such an approach the system is not sampled in fixed $\Delta t$ but advanced as events occur where the system stays constant in between. Depending on the model, in an event-driven approach it may be more natural to express the requirements of the model.

In an additional step we have implemented a rudimentary event-driven approach which allows the scheduling of events but had to omit it due to lack of space. Using the flexibility of MSFs we added a State transformer to the monad stack which allows enqueuing of events into a priority queue. The simulation is advanced by processing the next event at the top of the queue which means running the MSF of the agent which receives the event. The simulation terminates if there are either no more events in the queue or after a given number of events or if the simulation time has advanced to some limit. Having made the transition to MSFs, implementing this feature was quite straight forward which shows the power and strength of the generalised approach to FRP using MSFs.

\subsubsection{Dynamic Agent creation}
In the SIR model, the agent population stays constant - agents don't die and no agents are created during simulation - but some simulations \cite{epstein_growing_1996} require dynamic agent creation and destruction. We can easily add and remove agents signal functions in the recursive switch after each time-step. The only problem is that creating new agents requires unique agent ids but with the transition to MSFs we can add a monadic context which allows agents to draw the next unique agent id when they create a new agent. 