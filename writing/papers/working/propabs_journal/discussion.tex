\section{Discussion}
\label{sec:discussion}
In this paper we have shown how to use property-based testing on a technical level to encode informal specifications of agent behaviour and model invariants into formal specification directly in code. Although our research uses the simple agent-based SIR model to demonstrate our approach, we argue that it is applicable to event-driven ABS \cite{meyer_event-driven_2014} in general, as we clearly focus on relating input to output events. However, the transitions we implemented were one-step transitions, feeding only a single event to the agents. Although we covered the full functionality by also testing the infected and recovered agent separately, the next step is to implement property tests which test the full transition from susceptible to recovered. This would required a stateful approach with multiple events and a different approach calculating the probabilities. We leave this for further research.

The benefits of a property-based approach in ABS over unit testing is manifold. First, it expresses specifications rather than individual test cases, which makes it more general than unit testing. It allows expressing probabilities of various types (hypotheses, transitions, outputs) and performing statistically robust testing by sequential hypothesis testing. Most importantly, it relates whole classes of inputs to whole classes of outputs, automatically generating thousands of tests if necessary, therefore better scaling to the stochastic nature of ABS.

The main challenge of property-based testing is to write custom data generators, which produce sufficient coverage for the problem at hand, something not always obvious when starting out. Further, it is not always clear without some analysis, whether a property test actually covers enough of the random test space or not. As a robust solution to this issues, QuickCheck provides functions allowing to specify required coverage as well as functionality to perform sequential statistical hypothesis testing to arrive at statistically robust coverage tests. An alternative solution to the potential coverage problems of QuickCheck is the \textit{deterministic} property-testing library SmallCheck \cite{runciman_smallcheck_2008}, which instead of randomly sampling the test space, enumerates test cases exhaustively up to some depth.

We hypothesise that it is very likely that if Gintis \cite{gintis_emergence_2006} would have applied rigorous unit and property-based testing to his model he might have found the inconsistencies and could have corrected them. Additionally, the code of the re-implementation \cite{evensen_extensible_2010} contains numerous invariant checks and assertions, which are properties expressed in code, thus immediately applicable for property-based testing. Further, due to the mathematical nature of Gintis' model, many properties in the form of formulas can be found in the paper specification \cite{gintis_emergence_2006}, which could be directly expressible using property-based and unit testing. 

Property-based testing has a close connection to model checking \cite{mcmillan_symbolic_1993}, where properties of a system are proved in a formal way. The important difference is that the checking happens directly on code and not on the abstract, formal model, thus one can say that it combines model checking and unit testing, embedding it directly in the software development and Test-Driven Development process without an intermediary step. We hypothesise that adding it to the already existing testing methods in the field of ABS is of substantial value as it allows to cover a much wider range of test cases due to automatic data generation. This can be used in two ways: to verify an implementation against a formal specification and to test hypotheses about an implemented simulation. This puts property-based testing on the same level as agent- and system testing, where not technical implementation details of agents are checked like in unit tests but their individual complete behaviour and the system behaviour as a whole.

\medskip

We have omitted tests for the infected agent as they follow conceptually the same patterns as the susceptible agent. The testing of transitions of the infected agent work slightly different though as they follow an exponential distribution but are encoded in a similar fashion as demonstrated with the susceptible agent. The case for the recovered agent is a bit more subtle, due to its behaviour: it simply stays \texttt{Recovered} \textit{forever}. A property-based test for the recovered agent would therefore run a recovered agent for a random number of time units and require that its output is always \texttt{Recovered}. Of course, this is no proof that the recovered agent stays recovered \textit{forever} as this would take forever to test and is thus not computable. Here we are hitting the limits of what is possible with random black-box testing like property-based testing. Without looking at the actual implementation it is not possible to prove that the recovered agent is really behaving as specified. We made this fact clear at the beginning of this paper, that property-based testing is not proof for correctness, but is only a support for raising the confidence in correctness by constructing cases that show that the behaviour is not incorrect. To be really sure that the recovered agent behaves as specified we need to employ white-box verification and look at the actual implementation. This is beyond the scope of this paper and left for further research.

The reason why we limit the virtual time in section \ref{sec:enc_model_inv} to 50 time units is also related to the limitations of property-based testing. Theoretically, limiting the duration is actually not necessary because we can reason that the SIR simulation \textit{will always} reach an equilibrium in finite steps. Unfortunately, this is not possible to express and test directly with property-based testing and would also require a dependently typed programming language like Idris \cite{brady_idris_2013,brady_type-driven_2017}. We leave this for further research.