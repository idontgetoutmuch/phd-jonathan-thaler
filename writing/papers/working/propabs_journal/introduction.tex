\section{Introduction}
\label{sec:introduction}
Since its inception in the early 1990s \cite{epstein_growing_1996,siebers_introduction_2008,wooldridge_introduction_2009}, Agent-Based Simulation (ABS) as a third way of doing science \cite{axelrod_advancing_1997,axelrod_guide_2006} has matured substantially and has found its way into the mainstream of science \cite{macal_everything_2016}. Further, a number of ABS frameworks and tools like RePast, AnyLogic and NetLogo as well as open databases of ABS models \cite{openabm_model_database}
have been developed, allowing for quick and robust prototyping and development of models.  

However, despite the broad acceptance and adoption of ABS as methodology and \textit{generative} way of doing science, there have been struggles as reported by Axelrod \cite{axelrod_chapter_2006}. He discusses the vulnerability of ABS to misunderstanding: due to informal specifications of models and change requests amongst members of a research team, bugs are very likely to be introduced. Further, he reports how difficult it was to reproduce other work \cite{axelrod_convergence_1995}, which took the team four months, due to inconsistencies between the original code and the published paper. The consequence is that counter-intuitive simulation results can lead to weeks of checking whether the code matches the model and is bug-free \cite{axelrod_advancing_1997}.

The same problem was reported by researchers \cite{ionescu_dependently-typed_2012}, which tried to reproduce the work of Gintis \cite{gintis_emergence_2006}. In his work, Gintis claimed to have found a mechanism in bilateral decentralized exchange, which resulted in Walrasian General Equilibrium without the neo-classical approach of a tatonement process through a central auctioneer \cite{colell_microeconomic_1995}. This was a major breakthrough for economics as the theory of Walrasian General Equilibrium is non-constructive. It postulates the properties and existence of the equilibrium but does not explain the process and dynamics through which this equilibrium can be reached or constructed. Gintis seemed to have found a model for this process.

The authors \cite{ionescu_dependently-typed_2012} failed to reproduce the results and were only able to solve the problem by directly contacting Gintis, which provided the code, the definitive formal reference. It was found that there was a bug in the code leading to unexpected results, which were seriously damaged through this error. They also reported ambiguity between the informal model description in Gintis' paper and the actual implementation. This discovery lead to research in a functional framework for agent-based models of exchange \cite{botta_functional_2011}, which tried to give a very formal functional specification of the model, coming very close to an implementation in Haskell. The failure of Gintis was investigated in more depth also by other researchers \cite{evensen_extensible_2010} who got access to Gintis' code through his website \cite{gintis_herbert_website}. They found that the code in Object Pascal did not follow good object-oriented design principles (all of it was public, code duplication) and discovered a number of bugs serious enough to damage the results.

These issues show that due to the fact that ABS is primarily used for scientific research, often producing break-through scientific results, besides on converging both on standards for testing the robustness of implementations and on its tools, ABS more importantly needs to be \textit{free of bugs}, \textit{verified against their specification}, \textit{validated against hypotheses} and ultimately be \textit{reproducible} \cite{axelrod_chapter_2006}. Further, a special issue with ABS is that the emergent behaviour of the system is generally not known in advance and researchers look for some \textit{unique} emergent pattern in the dynamics. Whether the emergent pattern is then truly due to the system working correctly, or a bug in disguise is often not obvious and becomes increasingly difficult to assess with increasing system complexity. 

These facts are also underlined in summaries of various ABS development methods \cite{hammer_tongs_north_2018} which all put fundamental emphasis on the verification and validation process for ABS. Although there exist methods and research of verification and validation in ABS, unfortunately, as section \ref{sec:related} shows, there does not exist much research on the issue of code testing an ABS implementation. In software engineering, this task has been traditionally achieved by unit testing, as introduced by Beck in the seminal work on Test-Driven Development \cite{beck_test_2002}. Unit tests are code pieces which test a given unit of functionality of some given feature. Generally, this results in hundreds or sometimes thousands of unit tests as all execution paths of the whole software should be covered.

We hypothesise that the reason why unit testing is not very present in the field of ABS verification and validation research is a conceptual mismatch between unit testings' deterministic and ABS' rather stochastic nature. The fact that a unit test needs to be written for each edge case makes it difficult to scale up to the stochastic nature of ABS, where the agent and model behaviour in general is often characterised by probabilistic distributions instead of deterministic rules. As a possible solution to this issue, our work \cite{thaler_show_2019} was the first to propose \textit{property-based testing} as an alternative to unit testing for code testing ABS implementations. The main idea of property-based testing is to express model specifications and invariants directly in code and test them through \textit{automated} and \textit{randomised} test data generation. In our paper \cite{thaler_show_2019} we presented a few different angles and ways to conceptually use property-based testing to code test ABS implementations. However, we did not discuss technical details and left the exact workings of property-based testing for ABS open as it was beyond the focus of that paper.

In this paper we pick up our conceptual work \cite{thaler_show_2019} and put it into a more technical perspective and demonstrate additional techniques of property-based testing in the context of ABS, which were not covered in the conceptual paper. More specifically, in this paper we show how to encode agent specifications and model invariants into property tests, using an agent-based SIR model \cite{macal_agent-based_2010} as use case. Following an event-driven \cite{meyer_event-driven_2014} approach we demonstrate how to express an agent specification in code by relating random input events to specific output events. Further, using specific property-based testing features which allow expressing expected coverage of data distributions, we show how transition probabilities can be tested. Finally, we also express model invariants by encoding them into property tests. By doing this, we demonstrate how property-based testing works on a technical level, how specifications and invariants can be put into code and how probabilities can be expressed and tested using statistically robust verification. This underlines the conclusion of our original work \cite{thaler_show_2019}, that property-based testing maps naturally to ABS. Further, this work shows that in the context of ABS, property-based testing does scale up better than unit testing as it allows to run thousands of test cases automatically instead of constructing each manually and, more importantly, property-based testing is able to encode probabilities, something unit testing is not capable of in general.

The paper is structured as follows: section \ref{sec:related} presents related work. In section \ref{sec:proptesting} property-based testing is introduced on a technical level. In section \ref{sec:sirmodel} the agent-based SIR model is introduced, together with its informal event-driven specification. Section \ref{sec:method} and \ref{sec:enc_model_inv} contain the main contribution of the paper, where it is shown how to encode agent specifications, transition probabilities and model invariants with property-based testing. Section \ref{sec:discussion} discusses the approach, concludes and  points out further research.