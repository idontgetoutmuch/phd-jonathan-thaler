\section{Property-Based Testing}
\label{sec:proptesting}
TODO: strictly speaking i need to rephrase this section as well

Property-based testing allows to formulate \textit{functional specifications} in code which then a property-based testing library tries to falsify by \textit{automatically} generating test data, covering as much cases as necessary. When a case is found for which the property fails, the library then reduces the test data to its simplest form for which the test still fails, for example shrinking a list to a smaller size. It is clear to see that this kind of testing is especially suited to ABS, because it allows to formulate specifications, where we describe \textit{what} to test instead of \textit{how} to test. % Also the deductive nature of falsification in property-based testing suits very well the constructive and exploratory nature of ABS.
Further, the automatic test generation can make testing of large scenarios in ABS feasible because it does not require the programmer to specify all test cases by hand, as is required in traditional unit tests.

Property-based testing has its origins in the QuickCheck library \cite{claessen_quickcheck_2000,claessen_testing_2002} of the pure functional programming language Haskell. QuickCheck tries to falsify the specifications by \textit{randomly} sampling the test space. This library has been successfully used for testing Haskell code in the industry for years, underlining its maturity and real world relevance in general and of property-based testing in particular \cite{hughes_quickcheck_2007}.

%According to the authors of QuickCheck \textit{"The major limitation is that there is no measurement of test coverage."} \cite{claessen_quickcheck_2000}. Although QuickCheck provides help to report the distribution of test cases it is not able to measure the coverage of tests in general. This could lead to the case that test cases which would fail are never tested because of the stochastic nature of QuickCheck. Fortunately, the library provides mechanisms for the developer to measure coverage in specific test cases where the data and its expected distribution is known to the developer.

%\medskip

To give an understanding of how property-based testing works with QuickCheck, we give examples of properties of lists, which are directly expressed as functions in Haskell. Such functions can take arbitrary inputs, with random data generated automatically by QuickCheck during testing. The return type of the function is a \texttt{Bool} indicating whether the property holds for the given random inputs or not.

%\begin{HaskellCode}
\begin{footnotesize}
\begin{verbatim}
-- list append (++) is associative
prop_append_associative :: [Int] -> [Int] -> [Int] -> Bool
prop_append_associative xs ys zs = (xs ++ ys) ++ zs == xs ++ (ys ++ zs)

-- The reverse of a reversed list is the original list
prop_reverse_reverse :: [Int] -> Bool
prop_reverse_reverse xs = reverse (reverse xs) == xs

-- reverse is distributive over list append (++)
prop_reverse_distributive :: [Int] -> [Int] -> Bool
prop_reverse_distributive xs ys 
  = reverse (xs ++ ys) == reverse xs ++ reverse ys
\end{verbatim}
\end{footnotesize}
%\end{HaskellCode}

When testing each property with QuickCheck, we get the following output:

\begin{footnotesize}
\begin{verbatim}
> quickCheck prop_append_associative
+++ OK, passed 100 tests.
> quickCheck prop_reverse_reverse
+++ OK, passed 100 tests.
> quickCheck prop_reverse_distributive
*** Failed! Falsifiable (after 5 tests and 6 shrinks):    
[0]
[1]
\end{verbatim}
\end{footnotesize}

QuickCheck generates 100 test cases for each property test by generating random data for the input arguments. We have not specified any data for our input arguments because QuickCheck is able to provide a suitable data generator through type inference. For lists as used in these examples and all the existing Haskell types there exist custom data generators already. %We have to use a monomorphic list, in our case \texttt{Int}, and cannot use polymorphic lists because QuickCheck would not know how to generate data for a polymorphic type. Still, by appealing to genericity and polymorphism, we get the guarantee that the test case is the same for all types of a lists.

QuickCheck generates 100 test cases by default and requires all of them to pass. If there is a test case which fails, the overall property test fails and QuickCheck shrinks the input to a minimal size, which still fails and reports it as a counter example. This is the case in the third property test \texttt{prop\_reverse\_distributive} which is wrong as \texttt{xs} and \texttt{ys} need to be swapped on the right-hand side. In this run, QuickCheck found a counter example to the property after 5 tests and applied 6 shrinks to find the minimal failing example of \texttt{xs = [0]} and \texttt{ys = [1]}. If we swap \texttt{xs} and \texttt{ys}, the property test passes 100 test cases just like the other two did. It is possible to configure QuickCheck to generate an arbitrary number of random test cases, which can be used to increase the coverage if the sampling space is quite large.

\subsection{Generators}
QuickCheck comes with a lot of data generators for existing types like \texttt{String, Int, Double, [] (List)}, but in case one wants to randomize custom data types, one has to write custom data generators. There are two ways to do this. The first on is to fix them at compile time by writing an \texttt{Arbitrary} type class instance. A type class can be understood as an interface definition, and an instance as a concrete implementation of such an interface for a specific type. The advantage of having an \texttt{Arbitrary} instance is that the custom data type can be used as random argument to a function as in the examples above. The second way to write custom data generators is to implement a run-time generator in the \texttt{Gen} context.

Here we implement a custom data generator for the \texttt{SIRState} for both cases. We start with the run-time option, running in the \texttt{Gen} context:

%\begin{HaskellCode}
\begin{footnotesize}
\begin{verbatim}
genSIRState :: Gen SIRState
genSIRState = elements [Susceptible, Infected, Recovered]
\end{verbatim}
\end{footnotesize}
%\end{HaskellCode}

This implementation makes use of the \texttt{elements :: [a] $\rightarrow$ Gen a} function, which picks a random element from a non-empty list with uniform probability. If a skewed distribution is needed, one can use the \texttt{frequency :: [(Int, Gen a)] $\rightarrow$ Gen a} function, where a frequency can be specified for each element. Generating on average 80\% \texttt{Susceptible}, 15\% \texttt{Infected} and 5\% \texttt{Recovered} can be achieved using this function:

%\begin{HaskellCode}
\begin{footnotesize}
\begin{verbatim}
genSIRState :: Gen SIRState
genSIRState = frequency [(80, Susceptible), (15, Infected), (5, Recovered)]
\end{verbatim}
\end{footnotesize}
%\end{HaskellCode}

Implementing an \texttt{Arbitrary} instance is straightforward, one only needs to implement the \texttt{arbitrary :: Gen a} method:

%\begin{HaskellCode}
\begin{footnotesize}
\begin{verbatim}
instance Arbitrary SIRState where
  arbitrary = genSIRState
\end{verbatim}
\end{footnotesize}
%\end{HaskellCode}

When we have a random \texttt{Double} as input to a function, but want to restrict its random range to (0,1) because it reflects a probability, we can do this easily with \texttt{newtype} and implementing an \texttt{Arbitrary} instance.

%\begin{HaskellCode}
\begin{footnotesize}
\begin{verbatim}
newtype Probability = P Double

instance Arbitrary Probability where
  arbitrary = P <$> choose (0, 1)
\end{verbatim}
\end{footnotesize}
%\end{HaskellCode}

\subsection{Distributions}
As already mentioned, QuickCheck provides functions to measure the coverage of test cases. This can be done using the 
\texttt{label :: String $\rightarrow$ prop $\rightarrow$ Property} function. It takes a \texttt{String} as first argument and a testable property and constructs a \texttt{Property}. QuickCheck collects all the generated labels, counts their occurrences and reports their distribution. For example, it could be used to get an idea of the length of the random lists created in the \texttt{reverse\_reverse} property shown above:

%\begin{HaskellCode}
\begin{footnotesize}
\begin{verbatim}
reverse_reverse_label :: [Int] -> Property
reverse_reverse_label xs  
  = label ("length of random-list is " ++ show (length xs)) 
          (reverse (reverse xs) == xs)
\end{verbatim}
\end{footnotesize}
%\end{HaskellCode}

When running the test, we see the following output:

\begin{footnotesize}
\begin{verbatim}
+++ OK, passed 100 tests:
 5% length of random-list is 27
 5% length of random-list is 0
 4% length of random-list is 19
 ...
\end{verbatim}
\end{footnotesize}

\subsection{Coverage}
QuickCheck provides two additional functions to work with test-case distributions: \texttt{cover} and \texttt{checkCoverage}. The function \texttt{cover :: Double $\rightarrow$ Bool $\rightarrow$ String $\rightarrow$ prop $\rightarrow$ Property} allows to explicitly specify that a given percentage of successful test cases belong to a given class. The first argument is the expected percentage, the second argument is a \texttt{Bool} indicating whether the current test case belongs to the class or not, the third argument is a label for the coverage, and the fourth argument is the property which needs to hold for the test case to succeed. 

Here we look at an example where we use \texttt{cover} to express that we expect 15\% of all test cases to have a random list with at least 50 elements.

%\begin{HaskellCode}
\begin{footnotesize}
\begin{verbatim}
reverse_reverse_cover :: [Int] -> Property
reverse_reverse_cover xs  
  = cover 15 (length xs >= 50) "Length of random list at least 50"
             (reverse (reverse xs) == xs)
\end{verbatim}
\end{footnotesize}
%\end{HaskellCode}

When repeatedly running the test, we see the following output:

\begin{footnotesize}
\begin{verbatim}
+++ OK, passed 100 tests (10% length of random list at least 50).
Only 10% Length of random-list at least 50, but expected 15%.
+++ OK, passed 100 tests (21% length of random list at least 50).
\end{verbatim}
\end{footnotesize}

As can be seen, QuickCheck runs the default 100 test cases and prints a warning if the expected coverage is not reached. This is a useful feature, but it is up to us to decide whether 100 test cases are suitable and whether we can really claim that the given coverage will be reached or not. Therefore, QuickCheck provides the function \texttt{checkCoverage :: prop $\rightarrow$ Property} which does this for us. When \texttt{checkCoverage} is used, QuickCheck will run an increasing number of test cases until it can decide whether the percentage in \texttt{cover} was reached or cannot be reached at all. The way QuickCheck does this, is by using sequential statistical hypothesis testing \cite{wald_sequential_1992}. Thus, if QuickCheck comes to the conclusion that the given percentage can or cannot be reached, it is based on a robust statistical test giving us high confidence in the result.

When we run the example from above but now with \texttt{checkCoverage} we get the following output:

\begin{footnotesize}
\begin{verbatim}
+++ OK, passed 12800 tests 
    (15.445% length of random-list at least 50).
\end{verbatim}
\end{footnotesize}

We see that after QuickCheck ran 12,800 tests it came to the statistically robust conclusion that, indeed, at least 15\% of the test cases have a random list with at least 50 elements. 