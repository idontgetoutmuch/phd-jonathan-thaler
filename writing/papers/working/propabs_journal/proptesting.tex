\section{Property-based testing}
\label{sec:proptesting}
Property-based testing allows to formulate \textit{functional specifications} in code which then a property-based testing library tries to falsify by \textit{automatically} generating test data, covering as much cases as necessary. When a case is found for which the property fails, the library then reduces the test data to its simplest form for which the test still fails, for example shrinking a list to a smaller size. It is clear to see that this kind of testing is especially suited to ABS, because it allows to formulate specifications, where we describe \textit{what} to test instead of \textit{how} to test. % Also the deductive nature of falsification in property-based testing suits very well the constructive and exploratory nature of ABS.
Further, the automatic test generation can make testing of large scenarios in ABS feasible because it does not require the programmer to specify all test cases by hand, as is required in traditional unit tests.

Property-based testing has its origins in the pure functional programming language Haskell in the works of \cite{claessen_quickcheck_2000,claessen_testing_2002}, where the authors present the QuickCheck library, which tries to falsify the specifications by \textit{randomly} sampling the test space. This library has been successfully used for testing Haskell code in the industry for years, underlining its maturity and real world relevance in general and of property-based testing in particular \cite{hughes_quickcheck_2007}.

%According to the authors of QuickCheck \textit{"The major limitation is that there is no measurement of test coverage."} \cite{claessen_quickcheck_2000}. Although QuickCheck provides help to report the distribution of test cases it is not able to measure the coverage of tests in general. This could lead to the case that test cases which would fail are never tested because of the stochastic nature of QuickCheck. Fortunately, the library provides mechanisms for the developer to measure coverage in specific test cases where the data and its expected distribution is known to the developer.

%\medskip

To give a good understanding of how property-based testing works with \\ QuickCheck, we give examples of properties of lists, which are directly expressed as functions in Haskell. Such functions can take arbitrary inputs, which random data are generated automatically by QuickCheck during testing. The return type of the function is a \texttt{Bool} indicating whether the property holds for the given random inputs or not.

%\begin{HaskellCode}
\begin{footnotesize}
\begin{verbatim}
-- list append (++) is associative
prop_append_associative :: [Int] -> [Int] -> [Int] -> Bool
prop_append_associative xs ys zs = (xs ++ ys) ++ zs == xs ++ (ys ++ zs)

-- The reverse of a reversed list is the original list
prop_reverse_reverse :: [Int] -> Bool
prop_reverse_reverse xs = reverse (reverse xs) == xs

-- reverse is distributive over list append (++)
prop_reverse_distributive :: [Int] -> [Int] -> Bool
prop_reverse_distributive xs ys 
  = reverse (xs ++ ys) == reverse xs ++ reverse ys
\end{verbatim}
\end{footnotesize}
%\end{HaskellCode}

When testing each property with QuickCheck, we get the following output:

\begin{footnotesize}
\begin{verbatim}
> quickCheck prop_append_associative
+++ OK, passed 100 tests.
> quickCheck prop_reverse_reverse
+++ OK, passed 100 tests.
> quickCheck prop_reverse_distributive
*** Failed! Falsifiable (after 5 tests and 6 shrinks):    
[0]
[1]
\end{verbatim}
\end{footnotesize}

QuickCheck generates 100 test cases for each property test by generating random data for the input arguments. We have not specified any data for our input arguments because QuickCheck is able to provide a suitable data generator through type inference. For lists as used in these examples and all the existing Haskell types there exist custom data generators already. %We have to use a monomorphic list, in our case \texttt{Int}, and cannot use polymorphic lists because QuickCheck would not know how to generate data for a polymorphic type. Still, by appealing to genericity and polymorphism, we get the guarantee that the test case is the same for all types of a lists.

QuickCheck generates 100 test cases by default and requires all of them to pass. If there is a test case which fails, the overall property test fails and QuickCheck shrinks the input to a minimal size, which still fails and reports it as a counter example. This is the case in the third property test \texttt{prop\_reverse\_distributive} which is wrong as \texttt{xs} and \texttt{ys} need to be swapped on the right-hand side. In this run, QuickCheck found a counter example to the property after 5 tests and applied 6 shrinks to find the minimal failing example of \texttt{xs = [0]} and \texttt{ys = [1]}. If we swap \texttt{xs} and \texttt{ys}, the property test passes 100 test cases just like the other two did. It is possible to configure QuickCheck to generate an arbitrary number of random test cases, which can be used to increase the coverage if the sampling space is quite large.