\section{Testing agent specifications}
\label{sec:method}
%TODO: put emphasis on statistical robust testing using cover and checkCoverage,
%TODO: introduce concepts along writing the main body. focus on event-driven sir.
%TODO: it would be great if i can show how property-based testing found a bug in an implementation

We start by encoding the invariants of the susceptible agent directly into Haskell, implementing a function which takes all necessary parameters and returns a \texttt{Bool} indicating whether the invariants hold or not. The encoding is straightforward when using pattern matching and it nearly reads like a formal specification due to the declarative nature of functional programming.

\begin{HaskellCode}
susceptibleProps :: SIREvent              -- ^ Random event sent to agent
                 -> SIRState              -- ^ Output state of the agent
                 -> [QueueItem SIREvent]  -- ^ Events the agent scheduled
                 -> AgentId               -- ^ Agent id of the agent
                 -> Bool
-- received Recover => stay Susceptible, no event scheduled
susceptibleProps Recover Susceptible es _ = null es
-- received MakeContact => stay Susceptible, check events
susceptibleProps MakeContact Susceptible es ai
  = checkMakeContactInvariants ai es cor 
-- received Contact _ Recovered => stay Susceptible, no event scheduled
susceptibleProps (Contact _ Recovered) Susceptible es _ = null es
-- received Contact _ Susceptible => stay Susceptible, no event scheduled
susceptibleProps (Contact _ Susceptible) Susceptible es _  = null es
-- received Contact _ Infected, didn't get Infected, no event scheduled
susceptibleProps (Contact _ Infected) Susceptible es _ = null es
-- received Contact _ Infected AND got infected, check events
susceptibleProps (Contact _ Infected) Infected es ai
  = checkInfectedInvariants ai es
-- all other cases are invalid and result in a failed test case
susceptibleProps _ _ _ _ = False
\end{HaskellCode}

Next, we give the implementation for the \texttt{checkMakeContactInvariants} function. We omit a detailed implementation of \texttt{checkInfectedInvariants} as it works in a similar way and its details do not add anything conceptually new. The function \texttt{checkMakeContactInvariants} encodes the invariants which have to hold when the susceptible agent receives a \texttt{MakeContact} event:

\begin{HaskellCode}
checkInfectedInvariants :: AgentId              -- ^ Agent id of the agent 
                        -> [QueueItem SIREvent] -- ^ Events the agent scheduled
                        -> Bool
checkInfectedInvariants sender 
  -- expect exactly one Recovery event
  [QueueItem receiver (Event Recover) t'] 
  -- receiver is sender (self) and scheduled into the future
  = sender == receiver && t' >= t 
-- all other cases are invalid
checkInfectedInvariants _ _ = False
\end{HaskellCode}

%The \texttt{checkMakeContactInvariants} is a bit more complex:
%
%\begin{HaskellCode}
%checkMakeContactInvariants :: AgentId              -- ^ Agent id of the agent 
%                           -> [QueueItem SIREvent] -- ^ Events the agent scheduled
%                           -> Int                  -- ^ Contact Rate
%                           -> Bool
%checkMakeContactInvariants sender es contactRate
%    -- make sure there has to be exactly one MakeContact event and
%    -- exactly contactRate Contact events
%    = invOK && hasMakeCont && numCont == contactRate
%  where
%    (invOK, hasMakeCont, numCont) 
%      = foldr checkMakeContactInvariantsAux (True, False, 0) es
%
%    checkMakeContactInvariantsAux :: QueueItem SIREvent 
%                                  -> (Bool, Bool, Int)
%                                  -> (Bool, Bool, Int)
%    checkMakeContactInvariantsAux 
%        (QueueItem (Contact sender' Susceptible) receiver t') (b, mkb, n)
%      = (b && sender == sender'   -- sender in Contact must be self
%           && receiver `elem` ais -- receiver of Contact must be in agent ids
%           && t == t', mkb, n+1)  -- Contact event is scheduled immediately
%    checkMakeContactInvariantsAux 
%        (QueueItem MakeContact receiver t') (b, mkb, n) 
%      = (b && receiver == sender  -- receiver of MakeContact is agent itself
%           && t' == t + 1         -- MakeContact scheduled 1 timeunit into future
%           &&  not mkb, True, n)  -- there can only be one MakeContact event
%    checkMakeContactInvariantsAux _ (_, _, _) 
%      = (False, False, 0)         -- other patterns are invalid
%\end{HaskellCode}

\subsection{Writing a property test}
What is left is to actually write a property test using QuickCheck. We are making heavy use of random parameters to express that the properties have to hold invariant of the model parameters. We make use of additional data generator modifiers: \texttt{Positive} ensures that the value generated is positive; \texttt{NonEmptyList} ensures that the randomly generated list is not empty.

QuickCheck comes with a lot of data generators for existing types like \texttt{String, Int, Double, []}, but in case one wants to randomize custom data types one has to write custom data generators. There are two ways to do this. Either fix them at compile time by writing an \texttt{Arbitrary} instance or write a run-time generator running in the \texttt{Gen} context. The advantage of having an \texttt{Arbitrary} instance is that the custom data type can then be used as random argument to a function..

This implementation makes use of the \texttt{elements :: [a] $\rightarrow$ Gen a} functions, which picks a random element from a non-empty list with uniform probability. If a skewed distribution is needed, one can use the \texttt{frequency :: [(Int, Gen a)] $\rightarrow$ Gen a} function, where a frequency can be specified for each element.

\begin{HaskellCode}
genEventFreq :: Int
             -> Int
             -> Int
             -> (Int, Int, Int)
             -> [AgentId]
             -> Gen SIREvent
genEventFreq mcf _ rcf _ []  
  = frequency [ (mcf, return MakeContact), (rcf, return Recover)]
genEventFreq mcf cof rcf (s,i,r) ais
  = frequency [ (mcf, return MakeContact)
              , (cof, do
                  ss <- frequency [ (s, return Susceptible)
                                  , (i, return Infected)
                                  , (r, return Recovered)]
                  ai <- elements ais
                  return (Contact ai ss))
              , (rcf, return Recover)]
         
genEvent :: [AgentId] -> Gen SIREvent
genEvent = genEventFreq 1 1 1 (1,1,1) 
\end{HaskellCode}

When we have a random \texttt{Double} as input to a function but want to restrict its random range to (0,1) because it reflects a probability, we can do this easily with \texttt{newtype} and implementing an \texttt{Arbitrary} instance. The same can be done for limiting the simulation duration to a lower range than the full \texttt{Double} range. Implementing an \texttt{Arbitrary} instance is straightforward, one only needs to implement the \texttt{arbitrary :: Gen a} method:

\begin{HaskellCode}
newtype Probability = P Double
newtype TimeRange   = T Double

instance Arbitrary Probability where
  arbitrary = P <$> choose (0, 1)
  
instance Arbitrary TimeRange where
  arbitrary = T <$> choose (0, 50)
\end{HaskellCode}

We are now equipped with all functionality to implement the property test.

\begin{HaskellCode}
prop_susceptible_invariants :: Positive Int         -- ^ Contact rate (beta)
                            -> Probability          -- ^ Infectivity (gamma)
                            -> Positive Double      -- ^ Illness duration (delta)
                            -> Positive Double      -- ^ Current simulation time
                            -> NonEmptyList AgentId -- ^ population agent ids
                            -> Gen Property
prop_susceptible_invariants 
  (Positive beta) (P gamma) (Positive delta) (Positive t) (NonEmpty ais) = do
  -- generate random event, requires the population agent ids
  evt <- genEvent ais
  -- run susceptible random agent with given parameters
  (ai, ao, es) <- genRunSusceptibleAgent beta gamma delta t ais evt
  -- check properties
  return (label (labelTestCase ao) (property (susceptibleProps evt ao es ai)))
  where
    labelTestCase :: SIRState -> String
    labelTestCase Infected    = "Susceptible -> Infected"
    labelTestCase Susceptible = "Susceptible"
    labelTestCase Recovered   = "INVALID"
\end{HaskellCode}

Due to the large random sampling space with 5 parameters, we increase the number of test cases to generate to 100,000. We also label the test cases to generate a distribution of the transitions. The case where the agents output state is \texttt{Recovered} is marked as "INVALID" as it must never occur, otherwise the test will fail, due to the invariants encoded above.

\begin{verbatim}
+++ OK, passed 100000 tests (6.77s):
94.522% Susceptible
 5.478% Susceptible -> Infected
\end{verbatim}

All 100,000 test cases go through within 6.7 seconds. The distribution of the transitions shows that we indeed cover both cases a susceptible agent can react within one event. It either stays susceptible or makes the transition to infection. The fact that there is no transition to recovered shows that the implementation is correct - for a transition to recovered we would need to send an additional, second event to the agent.

Encoding of the invariants and writing property tests for the infected agents follows the same idea and is not repeated here. Next, we show how to test transition probabilities using the powerful statistical hypothesis testing feature of QuickCheck.

\subsection{Encoding transition probabilities}
In the specifications from section \ref{sec:sirmodel} there are probabilistic state transitions, for example an infected agent \textit{will} recover after a given time, which is randomly distributed with the exponential distribution. The susceptible agent \textit{might} become infected, depending on the events it receives and the infectivity ($\gamma$) parameter. We look now into how we can encode these probabilistic properties using the powerful \texttt{cover} and \texttt{checkCoverage} feature of QuickCheck.

The function \texttt{cover :: Testable prop $\Rightarrow$ Double $\rightarrow$ Bool $\rightarrow$ String $\rightarrow$ prop $\rightarrow$ Property} allows to explicitly specify that a given percentage of successful test cases belong to a given class. The first argument is the expected percentage; the second argument is a \texttt{Bool} indicating whether the current test case belongs to the class or not; the third argument is a label for the coverage; the fourth argument is the property which needs to hold for the test case to succeed. 

QuickCheck provides the powerful function \texttt{checkCoverage :: Testable prop $\Rightarrow$ prop $\rightarrow$ Property} which does this for us. When \texttt{checkCoverage} is used, QuickCheck will run an increasing number of test cases until it can decide whether the percentage in \texttt{cover} was reached or cannot be reached at all. The way QuickCheck does it, is by using sequential statistical hypothesis testing \cite{wald_sequential_1992}, thus if QuickCheck comes to the conclusion that the given percentage can or cannot be reached, it is based on a robust statistical test giving strong confidence in the result.

We follow the same approach as in encoding the invariants of the susceptible agent but instead of checking the invariants, we compute the probability for each case. In this property test we cannot randomise the model parameters because this would lead to random coverage. This might seem like a disadvantage but we do not really have a choice here, still the model parameters can be adjusted arbitrarily and the property must hold. %Note that we do not provide the details of computing the probabilities of each input-to-output case as it is quite technical and of not much importance - it is only a matter of multiplication and divisions amongst the event-frequencies and model parameters.
We make use of the \texttt{cover} function together with \texttt{checkCoverage}, which ensures that we get a statistical robust estimate whether the expected percentages can be reached or not. Implementing this property test is then simply a matter of computing the probabilities and of case analysis over the random input event and the agents output.

\begin{HaskellCode}
...
case evt of 
  Recover -> 
    cover recoverPerc True 
     ("Susceptible receives Recover, expected " ++ show recoverPerc) True
...
\end{HaskellCode}

Note the usage pattern of \texttt{cover} where we unconditionally include the test case into the coverage class so all test cases pass. The reason for this is that we are just interested in testing the coverage, which is in fact the property we want to test. We could have combined this test into the previous one but then we couldn't have used randomised model parameters. For this reason, and to keep the concerns separated we opted for two different tests, which makes them also much more readable.

%\begin{HaskellCode}
%prop_susceptible_proabilities :: Positive Double      -- ^ Current simulation time
%                              -> NonEmptyList AgentId -- ^ Agent ids of the population
%                              -> Property
%prop_susceptible_proabilities (Positive t) (NonEmpty ais) = checkCoverage (do
%  -- fixed model parameters, otherwise random coverage
%  let cor = 5
%      inf = 0.05
%      ild = 15.0
%
%   -- compute distributions for all cases
%  let recoverPerc       = ...
%      makeContPerc      = ...
%      contactRecPerc    = ...
%      contactSusPerc    = ...
%      contactInfSusPerc = ...
%      contactInfInfPerc = ...
%
%  -- generate a random event
%  evt <- genEvent ais
%  -- run susceptible random agent with given parameters
%  (_, ao, _) <- genRunSusceptibleAgent cor inf ild t ais evt
%
%  -- encode expected distributions
%  return $ property $
%    case evt of 
%      Recover -> 
%        cover recoverPerc True 
%          ("Susceptible receives Recover, expected " ++ 
%           show recoverPerc) True
%      MakeContact -> 
%        cover makeContPerc True 
%          ("Susceptible receives MakeContact, expected " ++ 
%           show makeContPerc) True
%      (Contact _ Recovered) -> 
%        cover contactRecPerc True 
%          ("Susceptible receives Contact * Recovered, expected " ++ 
%           show contactRecPerc) True
%      (Contact _ Susceptible) -> 
%        cover contactSusPerc True 
%          ("Susceptible receives Contact * Susceptible, expected " ++ 
%           show contactSusPerc) True
%      (Contact _ Infected) -> 
%        case ao of
%          Susceptible ->
%            cover contactInfSusPerc True 
%              ("Susceptible receives Contact * Infected, stays Susceptible " ++
%               ", expected " ++ show contactInfSusPerc) True
%          Infected ->
%            cover contactInfInfPerc True 
%              ("Susceptible receives Contact * Infected, becomes Infected, " ++
%               ", expected " ++ show contactInfInfPerc) True
%          _ ->
%            cover 0 True "Impossible Case, expected 0" True
%\end{HaskellCode}

When running the property test we get the following output:

\begin{footnotesize}
\begin{verbatim}
+++ OK, passed 819200 tests (7.32s):
33.3582% Susceptible receives MakeContact, expected 33.33%
33.2578% Susceptible receives Recover, expected 33.33%
11.1643% Susceptible receives Contact * Recovered, expected 11.11%
11.1096% Susceptible receives Contact * Susceptible, expected 11.11%
10.5616% Susceptible receives Contact * Infected, stays Susceptible, expected 10.56%
 0.5485% Susceptible receives Contact * Infected, becomes Infected, expected 0.56%
\end{verbatim}
\end{footnotesize}

After 819,200 (!) test cases QuickCheck comes to the conclusion that the distributions generated by the test cases reflect the expected distributions and passes the property test. We see that the values do not match exactly in some cases but by using sequential statistical hypothesis testing, QuickCheck is able to conclude that the coverage are statistically equal.