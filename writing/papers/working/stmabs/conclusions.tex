\section{Conclusion} %(the moral of the tale)
\label{sec:conclusion}

In this paper we investigated the potential for using STM for parallel, large scale ABS and come to the conclusion that it is indeed a very promising alternative over lock-based approaches as our case studies have shown. The STM implementations all consistently outperformed the lock-based ones and scaled much better to larger number of CPUs. Besides, the concurrency abstractions of STM are very powerful, yet simple enough to allow convenient implementation of concurrent agents without the problems of lock-based implementation. Due to most ABS being primarily pure computations, which do not need interactive input from the user, files or network during simulation, the fact that no such interactions can occur within an agent when running within STM is not a problem. 

Further, STM primitives map nicely to ABS concepts. When having a shared environment, it is natural either using \texttt{TVar} or \texttt{TArray}, depending on the environments nature. Also, there exists the \texttt{TChan} primitive, which can be seen as a persistent message box for agents, underlining the message-oriented approach found in many agent-based models \cite{agha_actors:_1986, wooldridge_introduction_2009}. Also \texttt{TChan} offers a broadcast transactional channel, which supports broadcasting to listeners which maps nicely to a proactive environment or a central auctioneer upon which agents need to synchronize. The benefits of these natural mappings are that using STM takes a big portion of burden from the modeller as one can think in STM primitives instead of low level locks and concurrent operational details. 

The strong static type system of Haskell adds another benefit. By running in the \texttt{STM} instead of \texttt{IO} context makes the concurrent nature more explicit and at the same time restricts it to purely STM behaviour. So despite obviously losing the reproducibility property due to concurrency, we still can guarantee that the agents can't do arbitrary IO as they are restricted to STM operations only.

Depending on the nature of the transactions, retries could become a bottle neck, resulting in a live lock in extreme cases. The central problem of STM is to keep the retries low, which is directly influenced by the read/writes on the STM primitives. By choosing more fine-grained and suitable data structures e.g. using a \texttt{TArray} instead of an indexed array within a \texttt{TVar}, one can reduce retries and increase performance significantly and avoid the problem of live locks as we have shown.

Despite the indisputable benefits of using STM within a pure functional setting like Haskell, it exists also in other imperative languages (Python, Java and C++, etc) and we hope that our research sparks interest in the use of STM in ABS in general and that other researchers pick up the idea and apply it to the established imperative languages Python, Java, C++ in the ABS community as well.