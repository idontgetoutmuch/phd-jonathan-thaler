\section{Introduction} % (once upon a time...)
The future of scientific computing in general and Agent-Based Simulation (ABS) in particular is parallelism: Moore's law is declining as we are reaching the physical limits of CPU clocks. The only option is going massively parallel due to availability of cheap massive parallel local hardware with many cores, or cloud services like Amazon EC.

This trend has been already recognised in the field of ABS as a research challenge for \textit{Large-scale ABMS} \cite{macal_everything_2016} was called out and as substantial body of research for parallel ABS shows \cite{suryanarayanan_pdes-mas_2013, logan_distributed_2001, lees_using_2008, suryanarayanan_synchronised_2013, riley_next_2003, gasser_mace3j:_2002, himmelspach_plugn_2007, minson_distributing_2008, gorur_repast_2016, hay_experiments_2015, abar_agent_2017, cicirelli_efficient_2015}, which discusses important concepts and introduced a number of highly sophisticated distributed ABM frameworks and libraries in the context of distributed parallel ABS built on PDES as internal working for parallel and distributed execution.

However, this sophisticated machinery is not always required and comes with substantial implementation and configuration overhead. Also, this powerful tools are often not needed as ABM does not always need to be run in a distributed way but the implementer 'simply' wants to parallelise the model locally. Although these existing distributed ABM frameworks could be used for this, they are overkill and more straightforward concepts for parallelising ABM would be more appropriate. However, for this case there does not exist much research, and it seems that either implementers resorted to the distributed ABM frameworks, implemented their own low-level concurrency plumbing which can be considerably complex - or simply refrained from using parallelism due to the high complexity involved and accept a longer execution time. What makes it worse is that parallelism always comes with danger of additional, very subtle bugs, which might lie dormant, potentially invalidating significant scientific results of the model. Therefore something simpler is needed for local parallelism.
Therefore, this paper proposes Software Transactional Memory (STM) as a new underlying concept for local parallelisation of ABM. This paper hypothesises that by using STM, implementing local parallel ABM is considerably easier than with lock-based approaches, less error prone and easier to validate. 

Unfortunately the established imperative languages in the ABS field, Python, Java, C++, follow mostly a lock-based approach to concurrency which is error prone and does not compose. Further, data-parallelism in an imperative language is susceptible to side-effects because these languages cannot distinguish between data-parallelism and concurrency in the types. 

Functional programming such as Haskell \citep{hudak_history_2007} can help to improve on both problems. Data-parallelism falls into place very naturally in it because of the way side-effects are handled and because data is immutable. Also, the problems of lock-based approaches can be overcome by using Software Transactional Memory (STM). Although STM exists in other languages as well, Haskell was one of the first to natively build it into its core. Further, it has the unique benefit that it can guarantee the lack of persistent side-effects at compile time, allowing unproblematic retries of transactions, something of fundamental importance in STM. This makes the use of STM in Haskell very compelling.

The challenge \textit{Large-scale ABMS} which focuses on efficient modelling and simulating large-scale ABS, is directly addressed by this thesis work on parallelism and concurrency in ABS. Further, STM can help in validation challenge of macal \emph{H5: Requirement that all models be completely validated} due to side effects restricted

The paper \cite{discolo_lock_2006} gives a good indication how difficult and complex constructing a correct concurrent program is and shows how much easier, concise and less error-prone an STM implementation is over traditional locking with mutexes and semaphores. Further it shows that STM consistently outperforms the lock-based implementation. We follow this work and compare the performance of lock-based and STM implementations and hypothesise that the reduced complexity and increased performance will be directly applicable to ABS as well.

We present two case-studies in which we employ an agent-based spatial SIR \citep{macal_agent-based_2010, thaler_pure_2019} and the well known SugarScape \citep{epstein_growing_1996} model to test our hypothesis. The latter model can be seen as one of the most influential exploratory models in ABS which laid the foundations of object-oriented implementation of agent-based models. The former one is an easy-to-understand explanatory model which has the advantage that it has an analytical theory behind it which can be used for verification and validation. 

The aim of this paper is to experimentally investigate the benefit of using STM over lock-based approaches for concurrent ABS models. Our contribution is that to the best of our knowledge we are the first to \textit{systematically} investigate the use of STM in ABS and compare its performance with sequential, lock-based and imperative implementations both on local and Amazon Cloud Service machinery.

We start with Section \ref{sec:rel_work} where we present related work. Then we discuss the concepts of STM and Haskell in Section \ref{sec:background}. In Section \ref{sec:stm_abs} we show how to apply STM to ABS in general. Section \ref{sec:cs_sir} contains the first case-study using a spatial SIR mode whereas Section \ref{sec:cs_sugarscape} presents the second case-study using the SugarScape model. We conclude in Section \ref{sec:conclusion} and give further research directions in Section \ref{sec:further}.