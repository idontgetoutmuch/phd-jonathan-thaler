\section{Introduction} % (once upon a time...)
The future of scientific computing in general and Agent-Based Simulation (ABS) in particular is parallelism: Moore's law is declining as we are reaching the physical limits of CPU clocks. The only option is going massively parallel due to availability of cheap massive parallel local hardware with many cores, or cloud services like Amazon EC. This trend has been already recognised in the field of ABS as a research challenge for \textit{Large-scale ABMS} \cite{macal_everything_2016} was called out and as a substantial body of research for parallel ABS shows \cite{suryanarayanan_pdes-mas_2013, logan_distributed_2001, lees_using_2008, suryanarayanan_synchronised_2013, riley_next_2003, gasser_mace3j:_2002, himmelspach_plugn_2007, minson_distributing_2008, gorur_repast_2016, hay_experiments_2015, abar_agent_2017, cicirelli_efficient_2015}.

In this body of work it has been established that parallelisation of autonomous agents, situated in some spacial, metric environment can be particularly challenging. The reason for this is that the environment constitutes a key medium for the agents interactions, represented as a \textit{passive} data structure, recording attributes of the environment and the agents \cite{lees_using_2008}. Thus the problem of parallelising ABS boils down to the problem of how to synchronise access to shared state without violating the causality principle and resource constraints \cite{logan_distributed_2001, suryanarayanan_pdes-mas_2013}. Various researchers have developed different techniques where most of them are based on the concept of Parallel Discrete-Event Simulation (PDES). The idea behind PDES is to partition the shared space into logical processes which run at their own speed, processing events coming from themselves and other logical processes. To deal with inconsistencies there exists a conservative approach which does not allow to process events with a lower timestamp than the current time of the logical process; and an optimistic approach which deals with inconsistencies through rolling back changes to state.

Adopting PDES to ABS is challenging as agents are autonomous and thus the topology can change in every step, making it hard to predict the topology of logical processes in advance \cite{lees_using_2008} and thus posing a difficult problem for parallelisation in general \cite{cicirelli_efficient_2015}. The work \cite{suryanarayanan_pdes-mas_2013, suryanarayanan_synchronised_2013} discusses this challenge by giving a detailed and in-depth discussion of the internals and implementation of their powerful and highly complex PDES-MAS system. The rather conceptual work \cite{logan_distributed_2001} proposes a general, distributed simulation framework for multiagent systems and addresses a number of key problems: decomposition of the environment, load balancing, modelling, communication and shared state variables, which the authors mention as the central problem of parallelisation.

In addition, various distributed simulation environments for ABS have been developed and their internals published in research papers: the SPADES system \cite{riley_next_2003} manages agents through UNIX pipes using a parallel sense-think-act cycle employing a conservative PDES approach; Mace3J \cite{gasser_mace3j:_2002} a Java based system running on single- or multicore workstations implements a message passing approach to parallelism; James II \cite{himmelspach_plugn_2007} is also a Java based system and focuses on PDEVS simulation with a plugin architecture to facilitate reuse of models; the well known RePast-HPC \cite{minson_distributing_2008, gorur_repast_2016} framework is using a PDES engine under the hood. 

The baseline of this body of research is that parallelisation is possible and we know how to do it. However, the complexity of these parallel and distributed simulation concepts and toolkits is high and the model development effort is hard \cite{abar_agent_2017}. Further, this sophisticated and powerful machinery is not always required as ABS does not always need to be run in a distributed way but the implementers 'simply' want to parallelise their models locally. Although these existing distributed ABS frameworks could be used for this, they are overkill and more straightforward concepts for parallelising ABS would be appropriate. However, for this case there does not exist much research, and implementers either resort to the distributed ABS frameworks, implement their own low-level concurrency plumbing which can be considerably complex - or simply refrain from using parallelism due to the high complexity involved and accept a longer execution time. What makes it worse is that parallelism always comes with danger of additional, very subtle bugs, which might lie dormant, potentially invalidating significant scientific results of the model. Therefore something simpler is needed for local parallelism. Unfortunately, the established imperative languages in the ABS field, Python, Java, C++, don't make adding parallelism easy, due to their inherent use of unrestricted side effects. Further, they mostly follow a lock-based approach to concurrency which is error prone and does not compose. %Further, data-parallelism in an imperative language is susceptible to side-effects because these languages cannot distinguish between data-parallelism and concurrency in the types.

\medskip

This paper proposes Software Transactional Memory (STM) in conjunction with functional programming in Haskell \cite{hudak_history_2007} as a new underlying concept for local parallelisation of ABS. We hypothesise that by using STM in Haskell, implementing local parallel ABS is considerably easier than with lock-based approaches, less error prone and easier to validate. Although STM exists in other languages as well by now, Haskell was one of the first to natively build it into its core. Further, it has the unique benefit that it can guarantee the lack of persistent side effects at compile time, allowing unproblematic retries of transactions, something of fundamental importance in STM. This makes the use of STM in Haskell very compelling. 
Our hypothesis is supported by \cite{discolo_lock_2006}, which gives a good indication how difficult and complex constructing a correct concurrent program is and shows how much easier, concise and less error-prone an STM implementation is over traditional locking with mutexes and semaphores. Further, it shows that STM consistently outperforms the lock-based implementation.

%Functional programming such as Haskell \cite{hudak_history_2007} can help to improve on both problems. Data-parallelism falls into place very naturally in it because of the way side-effects are handled and because data is immutable. Also, the problems of lock-based approaches can be overcome by using Software Transactional Memory (STM). 

\medskip

To the best of our knowledge we are the first to \textit{systematically} discuss the use of STM in the context of ABS. However, the idea of applying transactional memory to simulation in general is not new and was already explored in the work \cite{hay_experiments_2015}, where the authors looked into how to apply Intelâ€™s \textit{hardware} transactional memory to simulations in the context of a Time Warp PDES simulation. The results showed that their approach generally outperformed traditional locking mechanisms.

The master thesis \cite{bezirgiannis_improving_2013} investigates Haskells' parallel and concurrency features to implement (amongst others) \textit{HLogo}, a Haskell clone of the NetLogo \cite{wilensky_introduction_2015} simulation package, focusing on using STM for a limited form of agent interactions. \textit{HLogo} is basically a re-implementation of NetLogos API in Haskell where agents run within an unrestricted side effect context (known as \texttt{IO}) and thus can also make use of STM functionality. The benchmarks show that this approach does indeed result in a speedup especially under larger agent populations. Despite the parallelism aspect our work share, our approach is rather different: we avoid unrestricted side effects through \texttt{IO} within the agents under all costs and explore the use of STM more on a conceptual level rather than implementing an ABS library.

\medskip

The aim of this paper is to experimentally investigate the benefits of using STM over lock-based approaches for concurrent ABS models. Therefore, we follow \cite{discolo_lock_2006} and compare the performance of lock-based and STM implementations and expect that the reduced complexity and increased performance will be directly applicable to ABS as well. We present two case studies in which we employ an agent-based spatial SIR \cite{macal_agent-based_2010, thaler_pure_2018} and the well known SugarScape \cite{epstein_growing_1996} model to test our hypothesis. The latter model can be seen as one of the most influential exploratory models in ABS which laid the foundations of object-oriented implementation of agent-based models. The former one is an easy-to-understand explanatory model which has the advantage that it has an analytical theory behind it which can be used for verification and validation. 

The contribution of this paper is a systematic investigation of the usefulness of STM over lock-based approaches, therefore giving implementers a new method of locally parallelising their own implementations without the overhead of a distributed, parallel PDES system or the error-prone low-level locking semantics of a custom built parallel implementation. Therefore, our paper directly addresses the \textit{Large-scale ABMS} challenge \cite{macal_everything_2016}, which focuses on efficient modelling and simulating large-scale ABS. Further, using STM, which restricts side effects, and makes parallelism easier, can help in the validation challenge \cite{macal_everything_2016} \emph{H5: Requirement that all models be completely validated}.

We start with Section \ref{sec:background} where we discuss the concepts of STM and side effects in Haskell. In Section \ref{sec:stm_abs} we show how to apply STM to ABS in general. Section \ref{sec:cs_sir} contains the first case study using a spatial SIR mode whereas Section \ref{sec:cs_sugarscape} presents the second case study using the SugarScape model. We conclude in Section \ref{sec:conclusion} and give further research directions in Section \ref{sec:further}.