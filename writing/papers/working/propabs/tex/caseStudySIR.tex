\section{Case Study I: SIR}
\label{sec:case_SIR}
As first use-case we discuss property-based testing for the \textit{explanatory} agent-based SIR model. It is a very well studied and understood compartment model from epidemiology \cite{kermack_contribution_1927} which allows to simulate the dynamics of an infectious disease like influenza, tuberculosis, chicken pox, rubella and measles spreading through a population. We implemented an agent-based version of this model \footnote{The code is freely accessible from \url{https://github.com/thalerjonathan/phd/tree/master/public/propabs/sir}}, inspired by \cite{macal_agent-based_2010}.

In this model, people in a population of size $N$ can be in either one of three states \textit{Susceptible}, \textit{Infected} or \textit{Recovered} at a particular time, where it is assumed that initially there is at least one infected person in the population. People interact \textit{on average} with a given rate of $\beta$ other people per time-unit and become infected with a given probability $\gamma$ when interacting with an infected person. When infected, a person recovers \textit{on average} after $\delta$ time-units and is then immune to further infections. An interaction between infected persons does not lead to re-infection, thus these interactions are ignored in this model. Due to the models' origin in System Dynamics (SD) \cite{porter_industrial_1962}, there exists a top-down formalisation in SD with the following equations:

\begin{equation}
\begin{aligned}
\frac{\mathrm d S}{\mathrm d t} = -infectionRate \\
\frac{\mathrm d I}{\mathrm d t} = infectionRate - recoveryRate \\
\frac{\mathrm d R}{\mathrm d t} = recoveryRate 
\end{aligned}
\end{equation}

\begin{equation}
\begin{aligned}
infectionRate = \frac{I \beta S \gamma}{N} \\
recoveryRate = \frac{I}{\delta} 
\end{aligned}
\end{equation}

\subsection{Deriving a property}
Our goal is to derive a property which connects the agent-based implementation to the SD equations. The foundation are both the infection- and recovery-rate where the infection-rate determines how many \textit{Susceptible} agents per time-unit become \textit{Infected} and the recovery-rate determines how many \textit{Infected} agents per time-unit become \textit{Recovered}. Lets look at the algorithm of the susceptible agent behaviour, which is key for the infection-rate:

\begin{algorithm}
generate on average $\beta$ make-contact events per time-unit\; 
\If{make-contact event}{
  select random agent \textit{randA} from population\; 
  \If{agent randA infected}{
    become infected with probability $\gamma$\; 
  }  
}
\caption{Susceptible behaviour}
\end{algorithm}

Per time-unit, a susceptible agent makes \textit{on average} contact with $\beta$ other agents, where in the case of a contact with an infected agent, the susceptible agent becomes infected with a given probability $\gamma$. In this description there is another probability hidden, the probability of making contact with an infected agent, which is simply the ratio of number of infected agents to number non-infected agents. We can now derive the formula for the probability of a \textit{Susceptible} agent to become infected: $\frac{\beta * \gamma * \text{number of infected (I)}}{\text{number of non-infected (N)}}$. When we look at the formula we can see that it is conceptually the same representation of the \textit{infection-rate} of the SD specification as shown above - except that it only considers a single \textit{Susceptible} agent instead of the aggregate of \textit{S} susceptible agents. We have now a property we can check using a property-test.

\subsection{Constructing the property-based test}
Having a property (law), we want now to construct a property-test for it. The formula is invariant under random population mixes and thus should hold for varying agent populations where the mix of \textit{Susceptible, Infected and Recovered} agents is random - thus we use QuickCheck to generate the population randomly, the property must still hold.

Obviously we need to pay attention to the fact that we are dealing with a stochastic system thus we can only talk about averages and thus it does not suffice to only run a single agent but we are repeating this for e.g. 10.000 \textit{Susceptible} agents (all with different random-number seeds). 

To check whether this test has passed we compare the required amount of agents which on average should become infected using the above formula to the one from our tests (simply count the agents which got infected and divide by N) and if the value lies within some small $\epsilon$ then we accept the test as passed. Now we can construct the following property-based test as shown in Algorithm \ref{alg:prop_test_infectionrate}.

\begin{algorithm}
\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
\Input{List \textit{randAs} of random agent-population generated by QuickCheck}
populationCount     = length \textit{randAs}\;
infectedCount       = count \textit{Infected} in \textit{randAs}\;
infectionRate       = infectivity * contactRate * (infectedCount / populationCount)\;

susceptibles = create 10000 \textit{Susceptible} agents\;
countInfected = 0\;
\For{each agent sa in susceptibles}{
  run agent sa for 1.0 time-unit, with list \textit{randAs} as input\;
  \If{agent sa became \textit{Infected} }{
	countInfected = countInfected + 1\;
  }
}

averageInfectionRate = countInfected / (length susceptibles)\;
$\epsilon$ = 0.1\;
\eIf{abs (averageInfectionRate - infectionRate) $\leq \epsilon$}{
  PASS\;
} {
  FAIL\;
}
\caption{Property-based test for infection-rate.}
\end{algorithm}
\label{alg:prop_test_infectionrate}

When running, QuickCheck generates 100 test-cases by randomly generating 100 different \textit{randAs} inputs to the test. All have to pass for the whole property-test to pass, which should be the case with an $\epsilon = 0.1$. 

This is the very power which property-based testing is offering us: we directly express the specification of the original SD model in a test of our agent-based implementation and let QuickCheck generate random test cases for us. This closely ties our implementation to the original specification and raises the confidence to a very high level that it is actually a valid and correct implementation.

%\subsection{Infected Behaviour}
%An infected agent will \textit{always} recover after some finite time, which is \textit{on average} after $\delta$ time-units. Note that this property involves stochastics too, so to test this property we run a large number of infected agents e.g. $N = 10.000$ (all with different random-number seeds) until they recover, record the time of each agents recovery and then average over all recovery times. To check whether this test has passed we compare the average recovery times to $\delta$ and if they lie within some small $\epsilon$ then we accept the test as passed (note again that we could use a t-test for better stochastic robustness but this is not the point of this paper).
%
%TODO: clearly state the property we test
%
%TODO: produce some pseudo-code of how the property-test conceptually works
%
%in the infected agent test we check if the average duration is as specified. does this resemble the recovery rate? or in other words: can we somehow test the recovery rate?
%durationsAvg = sum durations / fromIntegral (length durations)
%
%We use property-testing with QuickCheck in this case as well to generate the set of other agents as input for the infected agents. Strictly speaking this would not be necessary as an infected agent never makes contact with other agents and simply ignores them - we could as well just feed in an empty list. We opted for using QuickCheck for the following reasons:
%
%\begin{itemize}
%	\item We wanted to stick to the interface specification of the agent-implementation as close as possible which asks to pass the states of all agents as input.
%	\item We shouldn't make any assumptions about the actual implementation and if it REALLY ignores the other agents, so we strictly stick to the interface which requires us to input the states of all the other agents.
%	\item The set of other agents is ignored when determining whether the test has failed or not which indicates by construction that the behaviour of an infected agent does not depend on other agents.
%	\item We are not just running a single replication over 10.000 agents but 100 of them which should give black-box verification more strength.
%\end{itemize}
%
%\subsection{Recovered Behaviour}
%A recovered agent will stay recovered \textit{forever}. Obviously we cannot write a property-based test that truly verifies that because it had to run in fact \textit{forever}. In this case we need to resort to white-box verification and look directly at the code and reason whether this property holds true.