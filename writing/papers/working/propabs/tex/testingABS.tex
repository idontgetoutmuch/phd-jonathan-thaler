\section{Testing ABS implementations}
\label{sec:testingABS}

Generally we need to distinguish between two types of testing / verification in ABS.

\begin{enumerate}
	\item Testing / verification of models for which we have real-world data or an analytical solution which can act as a ground-truth - examples for such models are the SIR model, stock-market simulations, social simulations of all kind.
	\item Testing / verification of models which are of exploratory nature, inspired by real-world phenomena but for which no ground-truth per se exists - examples for such models is the Sugarscape \cite{epstein_growing_1996} or Agent\_Zero model \cite{epstein_agent_zero:_2014}.
\end{enumerate}

The baseline is that either one has an analytical model as the foundation of an agent-based model or one does not. In the former case, e.g. the SIR model, one can very easily validate the dynamics generated by the simulation to the one generated by the analytical solution through System Dynamics. In the latter case one has basically no idea or description of the emergent behaviour of the system prior to its execution e.g. SugarScape. In this case it is important to have some hypothesis about the emergent property / dynamics. The question is how verification / validation works in this setting as there is no formal description of the expected behaviour: we don't have a ground-truth against which we can compare our simulation dynamics.

In black-box verification one generally feeds input and compares it to expected output. This type of verification is our primary concern in this paper as property-based testing is an instance of black-box verification. In the case of ABS we have the following levels of black-box tests:
\begin{enumerate}
	\item Isolated agent behaviour - test isolated agent behaviour under given inputs. For this we can use traditional unit-tests as shown by \cite{collier_test-driven_2013} and also property-based testing as we will show in the use-cases.
	\item Interacting agent behaviour - test if interaction between agents are correct. For this we can use traditional unit-tests as shown by \cite{collier_test-driven_2013} and also property-based testing as we will show in the use-cases.
	\item Simulation dynamics - compare emergent dynamics of the ABS as a whole under given inputs to an analytical solution or real-world dynamics in case there exists some using statistical tests. We see this type of tests conceptually as property-tests as well because we are testing properties of the model / simulation as we will see in the use-cases. Technically speaking we can both use traditional unit-tests and also property-based tests to implement them - conceptually they are property-tests.
	\item Hypotheses- test whether hypotheses about the model are valid or invalid. This is very similar to the previous point but without comparing it to analytical solutions or real-world dynamics but only to some hypothetical values.
\end{enumerate}

%\subsection{White-Box Verification}
%White-Box verification is necessary when we need to reason about properties like \textit{forever}, \textit{never}, which cannot be guaranteed from black-box tests. Additional help can be coverage tests with which we can show that all code paths have been covered in our tests. White-Box verification is a highly complex topic in its own and not of our concern in this paper but we will shortly refer to it in our SIR case study.

%TODO: List of Common Bugs and Programming Practices to avoid them \cite{vipindeep_list_2005}

%We have discussed in this section \textit{how} to approach an ABS implementation from a pure functional perspective using Haskell where we have also briefly touched on \textit{why} one should do so and what the benefits and drawbacks are. In the next two sections we will expand on the \textit{why} by presenting two case-studies which show the benefits of using Haskell in regards of testing and increasing the confidence in the correctness of the implementation.