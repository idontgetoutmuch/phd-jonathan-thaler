\section{Case-Study: Pure Functional SugarScape}
\label{sec:case_study}

To explore how to approach ABS based on pure functional programming concepts as introduced before, we did a \textit{full and verified} implementation of the seminal Sugarscape model \cite{epstein_growing_1996}. We chose the model because it is quite well known in the ABS community, it was highly influential in sparking the interest in ABS, it is quite complex with non-trivial agent-interactions and it used object-oriented techniques and explicitly advocates them as a good fit to ABS. 

Our goal was first to develop techniques and concepts to show \textit{how} to engineer a clean, maintainable and robust ABS in Haskell. The second step was then to identify benefits and drawbacks to identify \textit{why} one would follow such an approach. In a third step we pushed the benefits of pure functional programming further and tried to find a remedy for the drawbacks. Absolutely paramount in our research was, that we are being \textit{pure}, which avoids the IO effect type under all circumstances because we would practically lose all strong compile time guarantees \footnote{The code is freely accessible from \url{https://github.com/thalerjonathan/phd/tree/master/public/towards/SugarScape}}.

TODO: \cite{macal_everything_2016} sugarscape is level 4, chapter 2 is level 3 or 2?


\subsection{A Functional View}
Due to the fundamentally different approaches of functional programming (FP) an ABS needs to be implemented fundamentally different, compared to established object-oriented (OO) approaches. We face the following challenges:

\begin{enumerate}
	\item How can we represent an Agent, its local state and its interface?
	\item How can we implement direct agent-to-agent interactions?
	\item How can we implement an environment and agent-to-environment interactions? 
\end{enumerate}

The fundamental building blocks to solve these problems are \textit{recursion} and \textit{continuations}. In recursion a function is defined in terms of itself: in the process of computing the output it \textit{might} call itself with changed input data. Continuations in turn are functions which allow to encapsulate the execution state of a program by capturing local variables and pick up computation from that point later on by returning a new function.

Thus we implement an agent as a continuation: this lets us encapsulate arbitrary complex agent-state which is only visible and accessible from within the continuation - the agent has exclusive access to it. This allows also to switch behaviour dynamically e.g. switching from one mode of behaviour to another like in a state-machine, simply by returning new functions which encapsulate the new behaviour. If no change in behaviour should occur, the continuation simply recursively returns itself with the new state captured.

The fact that we design an agent as a function, raises the question of the interface of it: what are the inputs and the output? Note that the type of the function has to stay the same although we might switch into different continuations - our interface needs to capture all possible cases of behaviour. The way we define the interface is strongly determined by the direct agent-agent interaction. In case of Sugarscape, agents need to be able to conduct two types of direct agent-agent interaction: 1. one-directional, where agent A sends a message to agent B without requiring agent B to synchronously reply to that message e.g. repaying a loan or inheriting money to children; 2. bi-directional, where two agents negotiate over multiple steps e.g. accepting a trade, mating or lending.
Thus it seems reasonable to define as input type an algebraic data-type which defines all possible incoming messages and agent handles. The agents continuation is then called every time the agent receives a message and can process it, update its local state and might change its behaviour.
As output we define a data-structure which allows the agent to communicate to the simulation kernel 1. whether it wants to be removed from the system or not, 2. a list of new agents it wants to spawn, 3. a list of messages the agent wants to send to other agents. Further because the data is completely local, the agent also returns a data-structure which holds all \textit{observable} information, the agent wants to share with the outside world. Together with the continuation this guarantees that the agent is in full control over its local state, which no one can mutate or access from outside. This also implies that one can only get information out of the agent by running its function. It also means that the output type of the function has to cover all possible input cases - it cannot change or depend on the input. 

The simulation kernel keeps track of the existing agents and the message-queue and processes the queue one element at a time. The new messages of an agent are inserted \textit{at the front} of the queue, ensuring that synchronous bi-directional messages are possible without violating resources constraints. The Sugarscape model specifies that in each tick or time-step all agents run in random order and do their thing. Thus to start the agent-behaviour in a new time-step, the core inserts a Tick message to each agent in random order which then results in them being executed and emitting new messages. The current time-step has finished when all messages in the queue have been processed.

\begin{HaskellCode}
TODO: give a short example of continuation agent
\end{HaskellCode}

Obviously the agents in the Sugarscape are located in a discrete 2d environment where they move around and harvest resources, which means the need to read and write data of environment. This is conveniently implemented by adding a State side-effect type to the agent continuation function. Further we also add a Random effect type because dynamics in most ABS in general and Sugarscapes in particular are driven by random number streams, so our agent needs to have access to one as well. All of this low level continuation plumbing is not necessary to implement and there exists a high quality library called dunai, based on research on Functional Reactive Programming  \cite{hudak_arrows_2003} and Monadic Stream Functions \cite{perez_functional_2016,perez_extensible_2017}.

\subsection{Testing}
We implemented a number of tests for agent functions which don't cover a whole sub-part of an agents behaviour: checks whether an agent has died of age or starved to death, the metabolism, immunisation step, check if an agent is a potential borrower or fertile, lookout, trading transaction. What all these functions have in common is that they are not pure computations like utility functions but require an agent-continuation which means they have access to the agent state, environment and random-number stream. This allows testing to capture the \textit{complete} system state in one location, which allows the checking of much more invariants than in approaches which have implicit side-effects.
What is particularly powerful is that one has complete control and insight over the changed state before and after e.g. a function was called on an agent: thus it is very easy to check if the function just tested has changed the agent-state itself or the environment: the new environment is returned after running the agent and can be checked for equality of the initial one - if the environments are not the same, one simply lets the test fail. This behaviour is very hard to emulate in OOP because one can not exclude side-effect at compile time, which means that some implicit data-change might slip away unnoticed. In FP we get this for free.

We tested these functions with an approach called \textit{property-based} testing. Although it is now available in a wide range of programming languages and paradigms, property-based testing has its origins in Haskell \cite{claessen_quickcheck_2000,claessen_testing_2002} and we argue that for that reason it really shines in pure functional programming. Property-based testing allows to formulate \textit{functional specifications} in code which then the property-testing library (e.g. QuickCheck \cite{claessen_quickcheck_2000}) tries to falsify by automatically generating random test-data covering as much cases as possible. When an input is found for which the property fails, the library then reduces it to the most simple one. %For a technical, in-depth discussion on property-based testing in Haskell we refer to the following papers: \cite{claessen_quickcheck_2000,claessen_testing_2002}.

We implement custom data-generators for our agent state and environment and its cells and then let QuickCheck generate the random data and us running the agent with the provided data, checking for the properties. An example for such a property is that an agent has starved to death in case its sugar (or spice) level has dropped to 0. The corresponding property-test generates a random agent state and also a random sugar level which we set in the agent state. We then run the function which returns True in case the agent has starved to death. We can then check that this flag is true only if the initial random sugar level was less then or equal 0.

We found that property-based testing works surprisingly well in this context because properties seem to be quite abound here. Also, it is clear to see that this kind of testing is especially well suited to ABS, firstly due to ABS stochastic nature and second because we can formulate specifications, meaning we describe \textit{what} to test instead of \textit{how} to test (again the declarative nature of functional programming shines through). Also the deductive nature of falsification in property-based testing suits very well the constructive nature of ABS.

TODO: do we have some example?

\subsection{Issues}
Haskell is notorious for its space-leaks due to lazy evaluation: data is only evaluated when required. Even for simple programs one can be hit by a serious space-leak where unevaluated code pieces (thunks) builds up in memory until they are needed, leading to dramatically increased memory usage for a problem which could be solved using a fraction.

It is no surprise that our highly complex Sugarscape implementation initially suffered severely from space-leaks, piling up about 40 MByte of memory per second. In simulation this is a big issue, threatening the value of the whole implementation despite its other benefits: because simulations might run for a (very) long time or conceptually forever, one must make absolutely sure that the memory usage stays constant.

As a remedy, Haskell allows to add so-called strictness pragmas to code-modules which forces strict evaluation of all data even if it is not used. Carefully adding this conservatively file-by file applying other techniques of forcing evaluation removed most of the memory leaks. Another memory leak was caused by selecting the wrong data-structure for our environment, for which we initially used an immutable array. The problem is that in the case of an update the whole array is copied, causing memory leaks AND a performance problem. We replaced it by an IntMap which uses integers as key (mapping 2d coordinates to unique integers is trivial) and is internally implemented as a radix-tree which allows for very fast lookups and inserts because whole sub-trees can be re-used.

% SHORTENING: does not really add anything here
%\subsection{Concurrency and parallelism}
%To see how difficult it was to build a concurrent implementation we took the existing sequential implementation and added concurrency to it using Software Transactional Memory (STM). The main idea behind STM is that instead of locking and synchronising access to shared data, STM executes code-blocks as atomic transactions which either commit successfully in case no dirty-read happened or retries in case the value was changed since its last read. Although STM exists in other languages as well, Haskells type-system guarantees that retries have no persisting side-effects, which is crucial for the retry-semantics of STM implementations. We have written a separate paper about using STM to implement concurrent ABS TODO cite my paper in TOMACS, thus we will not go into more detail here but refer to it instead. 