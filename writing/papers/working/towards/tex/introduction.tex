\section{Introduction}
The traditional approach to Agent-Based Simulation (ABS) has so far always been object-oriented techniques, due to the influence of the seminal work of Epstein et al \cite{epstein_growing_1996} in which the authors claim \textit{"[..] object-oriented programming to be a particularly natural development environment for Sugarscape specifically and artificial societies generally [..]"} (p. 179). This work established the metaphor in the ABS community, that \textit{agents map naturally to objects} \cite{north_managing_2007} which still holds up today.

In this paper we challenge this metaphor and present ways of implementing ABS in the functional programming paradigm using the language Haskell \cite{hudak_history_2007}. We claim that functional programming has its place in ABS because of ABS' \textit{scientific computing} nature where results need to be reproducible and correct while simulations should be able to be exploit parallelism and concurrency as well. %The established object-oriented approaches need considerably high effort and might even fail to deliver these objectives due to its conceptually different approach to programming. In contrast,
We claim that by using functional programming for implementing ABS it is less difficult to add parallelism and correct concurrency, the resulting simulations are easier to test and verify, guaranteed to be reproducible already at compile-time, have fewer potential sources of bugs and are ultimately more likely to be correct. 

To substantiate our claims we first present fundamental concepts and advanced features of functional programming and then show how they can be used to engineer clean, maintainable and reusable ABS implementations. Further we discuss how the well known benefits of functional programming in general are applicable in ABS. We discuss this in the context of a practical case-study we conducted, in which we implemented the \textit{full} SugarScape model \cite{epstein_growing_1996} in Haskell. In this case study:
\begin{itemize}
	\item We developed techniques for engineering a clean, maintainable, general and reusable \textit{sequential} implementation in Haskell. Those techniques are directly applicable to other ABS implementations as well.
	
	\item We explored ways of exploiting data-parallelism to speed up the execution in our sequential implementation. Further we explored techniques for a \textit{concurrent} implementation using Software Transactional Memory (STM). We refer to (TODO: cite our own TOMACS paper) for an in-depth discussion of this work as we can only discuss it very briefly here due to lack of space.
	
	\item We explored ways of code-testing our implementation. We show how to use property-based testing for ensuring the correctness of individual agent parts, and unit-testing of the whole simulation which serves both as regression test and to check model hypotheses.
	
	\item Our Sugarscape implementation is fully validated against the dynamics reported in the book \cite{epstein_growing_1996} and an already existing NetLogo replication \cite{weaver_replicating_nodate}. Due to lack of space we cannot include the discussion of the validation process in the regular paper but added it as an Appendix \ref{app:validation}.
\end{itemize}

We present the challenges encountered in this case-study and discuss benefits and drawbacks. As will become apparent, our results support our claims that pure functional programming has indeed its place in ABS and that it has the mentioned benefits. 

The aim and contribution of this paper is to introduce the functional programming paradigm using Haskell to ABS on a \textit{conceptual} level, identifying benefits, difficulties and drawbacks. This is done through the above mentioned case-study which introduces general implementation techniques applicable to ABS and investigates benefits and drawbacks leveraged from functional programming. To the best of our knowledge, we are the first to do so.

The structure of the paper is as follows. 
In Section \ref{sec:related_work} we present related work on functional programming in ABS. 
In Section \ref{sec:fp} we introduce the functional programming paradigm, establish key features, motivate why we chose Haskell, discuss its type system and side-effects. 
In Section \ref{sec:case_study} we present our approach in the context of our Sugarscape case-study together with the challenges encountered and its benefits and drawbacks.
In Section \ref{sec:discussion} we discuss our initial claims in the light of the case-study.
In Section \ref{sec:conclusions} we conclude and point out further research.
We added an Appendix \ref{app:validation} in which we give a deeper insight into our process of validating our Sugarscape model against the book and \cite{epstein_growing_1996} and an already existing NetLogo replication \cite{weaver_replicating_nodate}.