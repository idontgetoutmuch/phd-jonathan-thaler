\section{Introduction}

Important: The strength of simulations is to put hypotheses to tests: The hypothesis-simulation-refinement cycle: 

All implementations of ABM/S models must solve two problems: 1. the model/data/ part: how agents can be represented and 2. the dynamic part: how the simulation is stepped

\subsection{Agent-definition}
An Agent is a metaphor for a pro-active unit, able to spawn new Agents, and interacting with other Agents in a network of neighbours by exchange of messages. The implementation of Agents can vary and strongly depends on the programming language and the kind of domain the simulation and model is situated in. This paper looks at how Agents can be implemented in various languages using the simple Heroes \& Cowards model (see below). The following implementations are discussed:

\begin{enumerate}
\item Java, Object-Oriented
\item Haskell, Pure Functional
\item Akka, Mixed Functional with Actors
\end{enumerate}

\subsection{The Model: Heroes and Cowards}
One starts with a crowd of Agents where each Agents is positioned \textit{randomly} in a continuous 2D-space. Each of the Agents then selects \textit{randomly} one friend and one enemy (except itself in both cases) and decided with a given probability whether the Agent acts in the role of a "Hero" or a "Coward" - friend, enemy and role don't change after the initial set-up. Now the simulation can start: in each step the Agent will move a given distance towards a given point. If the Agent is in the role of a "Hero" this point will be the half-way distance between the Agents friend and enemy - the Agent tries to protect the friend from the enemy. If the Agent is acting like a "Coward" it will try to hide behind the friend also the half-way distance between the Agents friend and enemy, just in the opposite direction. \\
Note that this simulation is determined by the random starting positions, random friend \& enemy selection, random role selection and number of agents. Note also that during the simulation-stepping no randomness is mentioned in the model and given the initial random set-up, the simulation-\textit{model} is completely deterministic - whether this is the case for the implementations is another question, not relevant to the model.

TODO: add random-noise with a configurable strength to direction: is closer to reality and also agents will never stop completely - may result in completely different pattern

The most obvious shortcomings of this model are its simplicity but that was chosen intentionally to prevent the research of the methods to be cluttered with too many subtle details of the model - also young children can easily understand how this model works and thus one does not need to constantly explain subtle implementation details because everything is pretty obvious. 

\subsubsection{Extension 1: World}

The coordinates calculated by the agents are \textit{virtual} ones ranging between 0.0 and 1.0. This prevents us from knowing the rendering-resolution and polluting code which has nothing to do with rendering with these implementation-details. Also this simulation could run without rendering-output or any rendering-frontend thus sticking to virtual coordinates is also very useful regarding this (but then again: what is the use of this simulation without any visual output=

\begin{itemize}
\item Infinite: movement is unrestricted.
\item Clipping: coordinates are clipped at 0.0 and 1.0 
\item Wraparound: coordinates are wrapped around to 0.0 when reaching 1.0. Will lead pursuing friends to change direction apruptly when wrapping around.
\end{itemize}

\subsubsection{Extension 2: Random-Noise}


\section{Visualization}
Render all
Render cowards only
Render heroes only

\section{Implementations}
\subsection{ABM/S Frameworks}
NetLogo
AnyLogic
ReLogo

\subsection{Object-Oriented in Java}
Mutable / Immutable
Side-Effects all over the place?

TODO: show how one can program more in a functional style in Java.

\subsection{Pure Functional in Haskell}
No framework
Yampa
Gloss
Aivika

\subsection{Multi-Paradigm Functional in Scala}
