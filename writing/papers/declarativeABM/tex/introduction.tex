\section{Introduction}
 the specification language should not be too technical, its focus should be on non-technical expressiveness. The question is: can we abstract away the technicalities and still translate it directly to haskell (more or less)? If not, can be adjust our Haskell implementation to come closer to our specification language? Thus it is a two-fold approach: both languages need to come closer to each other if we want to close the gap
 
TODO: \cite{nowak_evolutionary_1992}, \cite{huberman_evolutionary_1993}
it is still not exactly clear => we present a formal specification using ABS 

it is not trivial to reproduce the results as there is only very informal descriptions in \cite{nowak_evolutionary_1992}. \cite{huberman_evolutionary_1993} give a few more details but also stay quite informal. Thus here we represent a pure functional formulation of the original program which makes it formally exactly clear how the simulation should work. we then look how it can be translated to an ABM specification

Object-oriented (OO) programming is the current state-of-the-art method used in implementing ABM/S due to the natural way of mapping concepts and models of ABM/S to an OO-language. Although this dominance in the field we claim that OO has also its serious drawbacks:

\begin{itemize}
\item Mutable State is distributed over multiple objects which is often very difficult to understand, track and control.
\item Inheritance is a dangerous thing if not used properly and with care because it introduces very strong dependencies which cannot be changed during runtime any-more.
\item Objects don't compose very well due to their internal (mutable) state (note that we are aware that there is the concept of immutable objects which are becoming more and more popular but that does not solve the fundamental problem.
\item It is (nearly) impossible to reason about programs.
\end{itemize}

We claim that these drawbacks are non-existent in pure functional programming like Haskell due to the nature of the functional approach. To give an introduction into functional programming is out of scope of this paper but we refer to the classical paper of \cite{hughes_why_1989} which is a great paper explaining to non-functional programmers what the significance of functional programming is and helping functional programmers putting functional languages to maximum use by showing the real power and advantages of functional languages. The main conclusion of this classical paper is that \textit{modularity}, which is the key to successful programming, can be achieved best using higher-order functions and lazy evaluation provided in functional languages like Haskell. \cite{hughes_why_1989} argues that the ability to divide problems into sub-problems depends on the ability to glue the sub-problems together which depends strongly on the programming-language and \cite{hughes_why_1989} argues that in this ability functional languages are superior to structured programming.

The code is available at \url{https://github.com/thalerjonathan/phd/tree/master/coding/papers/declarativeABM/haskell/MinABS}

