\section{Introduction}
In the paper of \cite{huberman_evolutionary_1993} the authors showed that the results of the simulation of the classic prisoners-dilemma on a 2D-grid reported in \cite{nowak_evolutionary_1992} depends on a a very specific strategy of iterating this simulation and show that the beautiful patterns as reported by \cite{nowak_evolutionary_1992} will not form when selecting a different iteration-strategy. Thus the central message of this paper is that when doing Agent-Based Simulation \& Modelling (ABM/S) \textit{it is important to select the right iteration-strategy which reflects and supports the corresponding semantics of the model}. We find that this awareness is yet still under-represented in the literature about ABM/S and most important of all is lacking a systematic treatment. Thus it is our contribution in this paper is to provide such a systematic treatment by
\begin{itemize}
	\item Presenting all the general iteration-strategies which are possible in an ABM/S
	\item Developing a systematic terminology of talking about them
	\item Giving the philosophical interpretation and meaning of each of them
	\item Comparing the 3 programming languages Java, Haskell and Scala in regard of their suitability to implement each of these strategies
\end{itemize}

Besides the systematic treatment of all the general iteration-strategies the paper presents another novelty which is its use of the pure functional declarative language Haskell in the comparison. This language has so far been neglected by the ABM/S community which is dominated by object-oriented (OO) programming languages like Java thus the usage of Haskell presents a real, original novelty in this paper.


\section{Problem}
1 Page

\begin{itemize}
	\item describe in more technical detail what the introduction tells.
	\item \cite{huberman_evolutionary_1993} only mentions synchronous and asynchronous updates but this is not precise enough
	\item also there are more possible ways to iterate instead of synchronous and asynchronous
\end{itemize}

\section{Iteration-Strategies}
2 Pages

This is all programming-language agnostic

\begin{itemize}
	\item A terminology and classification of all the possible iteration-strategies presented as a list 
	\item short discussion separate paragraph for each
		\begin{itemize}
			\item Abstract implementation of the strategies
			\item Philosophical meaning and interpretation
			\item Advice for selecting it
		\end{itemize}
\end{itemize}

\section{Implementation}
5 Pages

This is now very programming-language specific

\begin{itemize}
	\item Mapping the strategies to 3 programming-languages: Java, Scala with Actors, Haskell
	\item Comparing the programming languages in regard of their suitability to implement each of these strategies
	\item Screenshots of results of the same simulation-model with all the strategies
\end{itemize}


\section{Related Research}
\begin{itemize}
	\item \cite{huberman_evolutionary_1993}
	\item \cite{a_framework_2008}
	\item \cite{botta_time_2010}
\end{itemize}

\section{Conclusion}
\begin{itemize}
	\item Selecting the correct Iteration-Strategy is of most importance and must match the model semantics
	\item Java: best for non-parallel, non-concurrent strategy
	\item Scala with Actors: best for concurrency
	\item Surprise: Haskell can faithfully implement all strategies equally well
\end{itemize}

\section{Further Research}
\begin{itemize}
	\item Reasoning about in Haskell about the Model \& the Simulation
	\item Develop a small modelling-language which is close to the Haskell-Version of modelling agents => specification and implementation match!
\end{itemize}