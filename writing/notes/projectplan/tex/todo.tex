\section{TODO-List as of \today}

\begin{enumerate}
\item implement Actors in Haskell: forkIO

\item Write John Garibaldi a Request for the School in April: Supervisors are OK with it but how can we finance it?

\item Arrange Meeting with Thorsten

\item Start Writing the paper
	\begin{itemize}
		\item Watch Youtube-Video
		\item 1 core message:
		\item not too complex (Peer-Olaf)
		\item Define Structure of Paper \& send to Peer: Headings with each having 2 bullet-points
		\item Consider Splitting the paper: influence of semantics / reasoning in functional ABM/S
		\item Real Abstract
		\item Title which sparks interest
		\item Aim of Paper
		\item what is the message of the paper? when implementing / running a simulation the semantics of the model MUST be considered otherwise the outcome could be completely different
		\item what is the novelty of the paper? comparison with pure functional approaches
		\item what is the contribution of the paper? 
		\item 
	\end{itemize}

\item Ideas to capture in the paper
	\begin{itemize}
		\item If one wants to write global in case of parallel this is regarded as a systematic error as this is not logical as it would imply an ordering thus we requiring different semantics: SEQ or CONCURRENT. Thus we would have to make the Environment in case of Par local to an agent which is the same as moving it into the agents state => we choose another approach: pass in an environment which cant be changed by the agents (no environment in return type) but only by the simulation-iterator after an iteration.  => dynamic WildFire-Model does not work with PAR
		\item note that the difference between SEQ and PAR in Haskell is in the end a 'fold' over the agents in the case of SEQ and a 'map' in the case of PAR
		\item haskell: dont have objects with methods which can call between each other but we need some way of representing agents. this is done using a struct type with a behaviour function and messaging mechanisms. important: agents are not carried arround but messages are sent to a receiver identified by an id. This is also a big difference to java where don't really need this kind of abstraction due to the use of objects and their 'messaging'. messaging mechanisms have up- and downsides, elaborate on it.

		\item reason for patterns: heroes try to stay 50 \% in between and have selected 2 cowards which themselves are at the borders opposite. need much more cowards than heroes 75/25.
		
		\item parallel more natural in haskell
		\item sequential more natural in java
		\item concurrent difficult in both, using stm in haskell it becomes very natural, STM available in java too. actors are an even better approach but is having problems with time in simulation
		
		\item question: do emergent patterns break down / global dynamics change completely in some ABM/S when changing sim-semantic? which kind of ABM could show this behaviour? which properties are responsible for it? Answer: Yes they do but only under given circumstances: discrete simulations with dependence on each other. continuous not so easy. 
		
		\item do we find a continuous simulation in which it breaks down under given circumstances? Yes: Heroes \& Cowards can lead to specific patterns as shown by the creators
	\end{itemize}
	
\item SEQ: two possibilities: time stays constant or time advances with every agent

\item FINALIZE AND FREEZE the literature I use for my paper (see next items READ): its all on my desk plus some prints to do (organize papers i need to read: ACE \& Economics, complex systems \& simulation, functional programming, abm \& actor model)
	\begin{itemize}
		\item READ: Gleichzeitige Ungleichzeitigkeiten
		\item READ: Complex Systems 'Cellular Automata' \& 'Turing Machines'
		\item READ: Functional programming \& Simulation papers (on desk)
		\item READ: Semantics of Actors (Hewitt, Greif \& Clinger)
		\item READ: philosophical papers of simulation
		\item READ: functional programming papers
		\item SEARCH: for further papers looking into my direction (when the difference between SEQ and PAR matters / matters not)
	\end{itemize}

\item Conference: ESSA (checkout website), Informs Proceedings Winter Simulation

\item Bring PureAgents to Yampa
	\begin{itemize}
		\item embed PureAgentsPar and Seq in Yampa: PureAgentsYampa so we can leverage the power of the EDSL, SFs, continuations,... of Yampa/Dunai.
		\item implement agent monad: PureAgentsMonadic. but what is an Agent-Monad? build a monad to chain actions of the agent and always run inside an agent-monad
		\item embed PureAgentsMonadic in Dunai
		\item implement wait blocking for a message so far. utilize yampas event mechanism?
	\end{itemize}
	
\item Push PureAgentsYampa by considering the next step: implementing an economics example at different levels of complexity e.g. Ionescus implementation of Gintis

\item Always ask the question: what is the difference to the OO approach? 
\end{enumerate} 


\section{Future-List as of \today}
\begin{enumerate}
\item Topics \& Issues of Haskell Implementation
	\begin{itemize}
		\item performance unacceptable: 1000 in haskell vs 100.000 in java is a shame on haskell, more should be possible. investigate using profiling both of CPU and memory: \url{http://keera.co.uk/blog/2014/10/15/from-60-fps-to-500/}. strictness \& tail-recursion!	
		\item look into QuickCheck and HPC
		\item problem: so far only agents with same static messagetypes, environment and states, can communicate: the agents are homogenous. how can we implement hetereogenous agents in this library?
		\item implement a general-purpose rendering-frontend with gloss but let the simulation be driven by Yampa/SimulationBackend instead of frontend (not real-time)
		\item implement PheroTrails: agents move on a 2d grid in a 8-neighbourhood and leave pheromone-trails which decay over time. the agents select the neighbourhood cell they move in the next step randomly according to the amount of pheromones present: the more pheromones are present the more likely they will move to that cell - note that this is relative: the pheromones of all neighbour cells are added up and normalized!

	\end{itemize}
	
\item Simulation Model Ideas
	\begin{itemize}
		\item IDEA: abm/s of a go game
		\item IDEA: what about an ABM/S of karma and rebirth? add to genesis paper
		\item IDEA: what about ABM/S generating sound? could be a perfect example for Yampa due to its signal functions. the sound is the result of interactions of agents which try to generate harmonies and agents trying to create dissonance
		\item IDEA: what about abm/s creating drawings/art? 2d continuous and each agents path is drawn

	\end{itemize}
\end{enumerate} 
