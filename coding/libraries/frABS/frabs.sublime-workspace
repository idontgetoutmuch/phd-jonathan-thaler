{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"if",
				"ifThenElse"
			],
			[
				"ifT",
				"ifThenElseM"
			],
			[
				"wrapCon",
				"wrapCont2D"
			],
			[
				"update",
				"updateDomainState"
			],
			[
				"initInput",
				"initInputsWithEnv"
			],
			[
				"Offerin",
				"OfferingData \tDoubleAuction.DAModel"
			],
			[
				"onMessageM",
				"onMessageMState ∷ AgentIn s m ec l → (AgentMessage m → State acc ()) → State acc ()\tFrABS.Agent.Monad"
			],
			[
				"onMe",
				"onMessageM ∷ Monad mon ⇒ AgentIn s m ec l → (acc → AgentMessage m → mon acc) → acc → mon acc\tFrABS.Agent.Monad"
			],
			[
				"error",
				"error ∷ HasCallStack ⇒ [Char] → a\tPrelude"
			],
			[
				"Age",
				"AgentMessage m\tFrABS.Agent.Agent"
			],
			[
				"Agent",
				"AgentMessage m\tFrABS.Agent.Agent"
			],
			[
				"Agen",
				"AgentId \tFrABS.Agent.Agent"
			],
			[
				"agentOu",
				"agentOutFromIn ∷ AgentIn s m ec l → AgentOut s m ec l\tFrABS.Agent.Agent"
			],
			[
				"ifthe",
				"ifThenElseM"
			],
			[
				"ifThen",
				"ifThenElse"
			],
			[
				"agentout",
				"agentOutFromIn ∷ AgentIn s m ec l → AgentOut s m ec l\tFrABS.Agent.Agent"
			],
			[
				"envion",
				"environmentPositionM"
			],
			[
				"igni",
				"ignitionEvent"
			],
			[
				"init",
				"initIgnite"
			],
			[
				"extractParamFrom",
				"extractParamFromVector ∷ Value → Int → Maybe Value\tRpc.Utils"
			],
			[
				"exc",
				"extractParam ∷ Value → Int → Text → Maybe Value\tRpc.Utils"
			],
			[
				"encod",
				"encodeQuantity ∷ Int → String\tRpc.Utils"
			],
			[
				"JsonRpcRe",
				"JsonRpcResponse \tEthJsonRpc.Methods"
			],
			[
				"server",
				"serverLoop"
			],
			[
				"et",
				"ethJsonRpcPort"
			],
			[
				"SockA",
				"SockAddrInet"
			],
			[
				"receivi",
				"receivingIdx"
			],
			[
				"rece",
				"receivingIn"
			],
			[
				"may",
				"mayIdx"
			],
			[
				"handleCon",
				"handleConversationAux"
			],
			[
				"mayb",
				"maybeFunc1"
			],
			[
				"SugarScapeC",
				"SugarScapeEnvCell \tSugarScape.SugarScapeModel"
			],
			[
				"sugEnv",
				"sugEnvSugarLevel ∷ SugarScapeEnvCell → Double\tSugarScape.SugarScapeModel"
			],
			[
				"sugAgSug",
				"sugAgSugarLevel ∷ SugarScapeAgentState → Double\tSugarScape.SugarScapeModel"
			],
			[
				"Cultur",
				"SugarScapeCulturalTag \tSugarScape.SugarScapeModel"
			]
		]
	},
	"buffers":
	[
		{
			"file": "examples/Main.hs",
			"settings":
			{
				"buffer_size": 1415,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"contents": "module FRP.FrABS.Simulation.Simulation (\n    UpdateStrategy (..),\n    EnvironmentCollapsing,\n    SimulationParams (..),\n\n    processIOInit,\n    processSteps\n  ) where\n\nimport FRP.FrABS.Simulation.SeqIteration\nimport FRP.FrABS.Simulation.ParIteration\nimport FRP.FrABS.Agent.Agent\nimport FRP.FrABS.Simulation.Internal\nimport FRP.FrABS.Environment.Definitions\nimport FRP.FrABS.Utils\n\nimport FRP.Yampa\nimport FRP.Yampa.InternalCore\n\nimport FRP.Titan.Debug.Core\nimport FRP.Titan.Debug.CommTCP\n\nimport Data.Maybe\nimport Data.List\nimport Data.Tuple\nimport System.Random\nimport qualified Data.Map as Map\nimport Control.Concurrent.STM.TVar\n\ndata UpdateStrategy = Sequential | Parallel deriving (Eq)\n\ndata SimulationParams e = SimulationParams {\n    simStrategy :: UpdateStrategy,\n    simEnvBehaviour :: Maybe (EnvironmentBehaviour e),\n    simEnvCollapse :: Maybe (EnvironmentCollapsing e),\n    simShuffleAgents :: Bool,\n    simRng :: StdGen,\n    simIdGen :: TVar Int\n}\n\n------------------------------------------------------------------------------------------------------------------------\n-- RUNNING SIMULATION FROM AN OUTER LOOP\n------------------------------------------------------------------------------------------------------------------------\nprocessIOInit :: [AgentDef s m e]\n                    -> e\n                    -> SimulationParams e\n                    -> (ReactHandle () ([AgentObservable s], e)\n                            -> Bool\n                            -> ([AgentObservable s], e)\n                            -> IO Bool)\n                    -> IO (ReactHandle () ([AgentObservable s], e))\nprocessIOInit adefs e params iterFunc = reactInit\n                                                (return ())\n                                                iterFunc\n                                                (process params adefs e)\n------------------------------------------------------------------------------------------------------------------------\n\n------------------------------------------------------------------------------------------------------------------------\n-- CALCULATING A FIXED NUMBER OF STEPS OF THE SIMULATION\n------------------------------------------------------------------------------------------------------------------------\nprocessSteps :: [AgentDef s m e]\n                -> e\n                -> SimulationParams e\n                -> Double\n                -> Int\n                -> [([AgentObservable s], e)]\nprocessSteps adefs e params dt steps = embed\n                                            (process params adefs e)\n                                            ((), sts)\n    where\n        sts = replicate steps (dt, Nothing)\n----------------------------------------------------------------------------------------------------------------------\n\n\nreactimateControl :: forall p a b\n                  .  (Read p, Show p, Show a, Read a, Show b, Read b, Pred p a b)\n                  => ExternalBridge                 -- ^ Debug: Communication bridge for the interactive GUI\n                  -> Preferences                    -- ^ Debug: Debugging preferences\n                  -> [Command p]                    -- ^ Debug: List of commands to execute\n                  -> IO a                           -- ^ FRP:   Initial sensing action\n                  -> (Bool -> IO (DTime, Maybe a))  -- ^ FRP:   Continued sensing action\n                  -> (Bool -> b -> IO Bool)         -- ^ FRP:   Rendering/consumption action\n                  -> SF a b                         -- ^ FRP:   Signal Function that defines the program\n                  -> IO ()\n\n------------------------------------------------------------------------------------------------------------------------\n-- DEBUGING THE SIMULATION USING HASKELL-TITAN\n------------------------------------------------------------------------------------------------------------------------\nprocessDebug :: (Show a, Read a, Show b, Read b)\n                => [AgentDef s m e]\n                -> e\n                -> SimulationParams e\n                -> Double\n                -> Int\n                -> [([AgentObservable s], e)]\n                -> IO ()\nprocessDebug adefs e params dt steps = \n    do\n        bridge <- mkTitanCommTCPBridge\n\n        reactimateControl\n            bridge                                      -- Communication channels\n            defaultPreferences                          -- Simulation preferences\n            [] --([] :: [Command PosLowerThan])              -- Initial command queue\n            initGraphs                                  -- IO a: Initial sensing action\n            (\\_ -> do                                   -- (Bool -> IO (DTime, Maybe a)):   Continued sensing action\n                dtSecs <- yampaSDLTimeSense timeRef \n                return (dtSecs, Nothing))\n            (\\_ e -> display e >> return False)         -- (Bool -> b -> IO Bool):   Rendering/consumption action\n            bouncingBall                                -- SF a b:   Signal Function that defines the program\n        where\n            sf = process\n----------------------------------------------------------------------------------------------------------------------\n\n\n----------------------------------------------------------------------------------------------------------------------\nprocess :: SimulationParams e\n            -> [AgentDef s m e]\n            -> e\n            -> SF () ([AgentObservable s], e)\nprocess params adefs e = sf >>> agentOutToObservableSF\n    where\n        asfs = map adBeh adefs\n        idGen = simIdGen params\n        ais = createStartingAgentIn adefs idGen\n        sf = iterationStrategy params asfs ais e \n\n----------------------------------------------------------------------------------------------------------------------\n\n----------------------------------------------------------------------------------------------------------------------\n-- NOTE: this is used for internal, recursive simulation and can be requested by agents in SEQUENTIAL strategy ONLY\nsimulate :: ([AgentIn s m e], e)\n            -> [AgentBehaviour s m e]\n            -> SimulationParams e\n            -> Double\n            -> Int\n            -> [([AgentOut s m e], e)]\nsimulate (ais, e) asfs params dt steps = embed sfStrat ((), sts)\n    where\n        sts = replicate steps (dt, Nothing)\n        sfStrat = iterationStrategy params asfs ais e\n----------------------------------------------------------------------------------------------------------------------\n\n----------------------------------------------------------------------------------------------------------------------\niterationStrategy :: SimulationParams e\n                        -> [AgentBehaviour s m e]\n                        -> [AgentIn s m e]\n                        -> e\n                        -> SF () ([AgentOut s m e], e)\niterationStrategy params asfs ais e\n    | Sequential == strategy = simulateSeq params asfs ais e\n    | Parallel == strategy = simulatePar params asfs ais e\n    where\n        strategy = simStrategy params\n----------------------------------------------------------------------------------------------------------------------\n\n----------------------------------------------------------------------------------------------------------------------\n-- SEQUENTIAL STRATEGY\n----------------------------------------------------------------------------------------------------------------------\nsimulateSeq :: SimulationParams e\n                -> [AgentBehaviour s m e]\n                -> [AgentIn s m e]\n                -> e\n                -> SF () ([AgentOut s m e], e)\nsimulateSeq initParams initSfs initAins initEnv = SF { sfTF = tf0 }\n    where\n        tf0 _ = (tfCont, (initOuts, initEnv))\n            where\n                -- NOTE: to prevent undefined outputs we create outputs based on the initials\n                initOuts = map agentOutFromIn initAins\n                --(nextSfs, initOs, nextIns) = runSeqInternal initSfs initInput clbk 0.0\n                -- NOTE: in SEQ we need already to know the dt for the NEXT step because we are iterating in sequence => ommit first output => need 1 step more\n                initInputsWithEnv = addEnvToAins initEnv initAins\n                tfCont = simulateSeqAux initParams initSfs initInputsWithEnv initEnv\n\n        -- NOTE: here we create recursively a new continuation\n        -- ins are the old inputs from which outs resulted, together with their sfs\n        -- simulateSeqAux :: SimulationParams e -> [AgentBehaviour s m e] -> [(AgentIn s m e, e)] -> e -> ?\n        simulateSeqAux params sfs insWithEnv e = SF' tf\n            where\n                -- NOTE: this is a function definition\n                -- tf :: DTime -> [i] -> Transition [i] [o]\n                tf dt _ = (tf', (outs, finalEnvAfterRun))\n                    where\n                        -- run the next step with the new sfs and inputs to get the sf-contintuations and their outputs\n                        (sfs', insWithEnv', outsWithEnv) = runSeqInternal \n                            sfs \n                            insWithEnv \n                            (seqCallback params) \n                            (seqCallbackIteration $ simIdGen initParams)\n                            dt\n\n                        -- NOTE: the 'last' environment is in the first of outs because runSeqInternal reverses the outputs\n                        finalEnv = if null outsWithEnv then e else snd $ head outsWithEnv\n                        (finalEnvAfterRun, params') = runEnv dt params finalEnv \n                        outs = map fst outsWithEnv\n\n                        insWithNewEnv = replaceEnvOfAins finalEnvAfterRun insWithEnv'\n\n                        (params'', sfsShuffled, insShuffled) = shuffleAgents params' sfs' insWithNewEnv\n\n                        -- create a continuation of this SF\n                        tf' = simulateSeqAux params'' sfsShuffled insShuffled finalEnvAfterRun\n\nseqCallbackIteration :: TVar Int \n                        -> [(AgentOut s m e, e)]\n                        -> ([AgentBehaviour s m e], [(AgentIn s m e, e)])\nseqCallbackIteration idGen aouts = (newSfs, newSfsIns')\n    where\n        -- NOTE: messages of this agent are ALWAYS distributed, whether it is killed or not\n        (newSfs, newSfsIns) = foldr (handleCreateAgents idGen) ([], []) aouts\n        -- NOTE: distribute messages to newly created agents as well\n        newSfsIns' = distributeMessages newSfsIns aouts\n\nseqCallback :: SimulationParams e\n                -> ([(AgentIn s m e, e)], [AgentBehaviour s m e])\n                -> AgentBehaviour s m e\n                -> (AgentBehaviour s m e, (AgentIn s m e, e), (AgentOut s m e, e))\n                -> ([(AgentIn s m e, e)], Maybe (AgentBehaviour s m e, (AgentIn s m e, e), (AgentOut s m e, e)))\nseqCallback params \n            (otherIns, otherSfs) \n            oldSf \n            (sf, (oldIn, oldInEnv), newOut)\n    | doRecursion = seqCallbackRec params otherIns otherSfs oldSf (sf, recIn, newOut)\n    | otherwise = handleAgent otherIns (sf, unRecIn, newOut)\n    where\n        -- NOTE: first layer of recursion: calling simulate within a simulation\n        -- NOTE: at this level we are determining how many levels of recursion we run: at the moment, we stop after the first level\n        doRecursion = if (isEvent $ aiRec oldIn) then\n                        False   -- this is recursion-level 1 (0 is the initial level), stop here, can be replaced by counter in the future\n                        else\n                            isEvent $ aoRec $ fst newOut      -- this is recursion-level 0 (initial level), do recursion only if the agent requests to do so\n\n        -- NOTE: need to handle inputs different based upon whether we are doing\n        recIn = if (isEvent $ aiRec oldIn) then\n                    (oldIn, oldInEnv) -- this is recursion level 1 => will do normal agent-handling and feed past outputs to the agent so it can select the best\n                    else\n                        (oldIn { aiRec = Event [] }, oldInEnv) -- this is recursion level 0 => start with empty past outputs\n\n        -- NOTE: need to stop recursion\n        unRecIn = (oldIn { aiRec = NoEvent }, oldInEnv)\n\n        -- NOTE: second layer of recursion: this allows the agent to simulate an arbitrary number of AgentOuts\n        seqCallbackRec :: SimulationParams e\n                           -> [(AgentIn s m e, e)]\n                           -> [AgentBehaviour s m e]\n                           -> AgentBehaviour s m e\n                           -> (AgentBehaviour s m e, (AgentIn s m e, e), (AgentOut s m e, e))\n                           -> ([(AgentIn s m e, e)],\n                               Maybe (AgentBehaviour s m e, (AgentIn s m e, e), (AgentOut s m e, e)))\n        seqCallbackRec params otherIns otherSfs oldSf (sf, (recIn, recInEnv), newOut)\n            | isEvent $ aoRec $ fst newOut = handleRecursion params otherIns otherSfs oldSf (sf, recIn', newOut)     -- the last output requested recursion, perform it\n            | otherwise = handleAgent otherIns (sf, unRecIn, newOut)                                                     -- no more recursion request, just handle agent as it is and return it, this will transport it back to the outer level\n            where\n                pastOutputs = fromEvent $ aiRec recIn                           -- at this point we can be sure that there MUST be an aiRec - Event otherwise would make no sense: having an aiRec - Event with a list means, that we are inside a recursion level (either 0 or 1)\n                recIn' = (recIn { aiRec = Event (newOut : pastOutputs) }, recInEnv)         -- append the new output to the past ones\n\n                -- NOTE: need to stop recursion\n                unRecIn = (recIn { aiRec = NoEvent }, recInEnv)\n\n        -- this initiates the recursive simulation call\n        handleRecursion :: SimulationParams e\n                             -> [(AgentIn s m e, e)]     -- the inputs to the 'other' agents\n                             -> [AgentBehaviour s m e] -- the signal functions of the 'other' agents\n                             -> AgentBehaviour s m e     -- the OLD signal function of the current agent: it is the SF BEFORE having initiated the recursion\n                             -> (AgentBehaviour s m e, (AgentIn s m e, e), (AgentOut s m e, e))\n                             -> ([(AgentIn s m e, e)],\n                                    Maybe (AgentBehaviour s m e, (AgentIn s m e, e), (AgentOut s m e, e)))\n        handleRecursion params otherIns otherSfs oldSf a@(sf, oldIn, newOut)\n            | isJust mayAgent = retAfterRec\n            | otherwise = retSelfKilled       -- the agent killed itself, terminate recursion\n            where\n                -- NOTE: collect self-messages for agent, distribute its messages and environment to others\n                retSelfKilled@(otherIns', mayAgent) = handleAgent otherIns a\n\n                (_, newIn, _) = fromJust mayAgent\n\n                otherIns'' = if allowsRecOthers $ fst newOut then otherIns' else forbidRecursion otherIns'\n\n                -- TODO: to prevent an endless creation of recursions when running a recursion for more than 1 step one needs to let the recursive agent let know it is inside its own recursion with the same mechanism as letting others now they are inside another recursion.\n\n                -- NOTE: need to add agent, because not included\n                -- TODO: does it really have to be added at the end?\n                allAsfs = otherSfs ++ [oldSf]       -- NOTE: use the old sf, no time\n                allAins = otherIns'' ++ [newIn]\n\n                env = snd newOut\n\n                -- TODO: does it make sense to run multiple steps? what is the meaning of it?\n                -- TODO: when running for multiple steps it makes sense to specify WHEN the agent of oldSF runs\n                -- NOTE: when setting steps to > 1 we end up in an infinite loop\n                -- TODO: only running in sequential for now\n                allStepsRecOuts = simulate (map fst allAins, env) allAsfs params 1.0 1\n\n                (lastStepRecOuts, lastStepRecEnv) = last allStepsRecOuts\n                mayRecOut = Data.List.find (\\ao -> (aoId ao) == (aiId $ fst oldIn)) lastStepRecOuts\n\n                -- TODO: what happens to the environment? it could have changed by the other agents but we need to re-set it to before\n                \n                -- TODO: the agent died in the recursive simulation, what should we do?\n                retAfterRec = if isJust mayRecOut then\n                                seqCallbackRec params otherIns otherSfs oldSf (sf, newIn, (fromJust mayRecOut, lastStepRecEnv)) -- TODO: is this really correct to return this environment?\n                                else\n                                    retSelfKilled\n\n        forbidRecursion :: [(AgentIn s m e, e)] -> [(AgentIn s m e, e)]\n        forbidRecursion ains = map (\\(ai, e) -> (ai { aiRecInitAllowed = False }, e)) ains\n\n        handleAgent :: [(AgentIn s m e, e)]\n                        -> (AgentBehaviour s m e, (AgentIn s m e, e), (AgentOut s m e, e))\n                        -> ([(AgentIn s m e, e)], Maybe (AgentBehaviour s m e, (AgentIn s m e, e), (AgentOut s m e, e)))\n        handleAgent otherIns a@(sf, oldIn, newOut) = (otherIns'', mayAgent)\n            where\n                (otherIns', newOut') = handleConversation otherIns newOut\n                mayAgent = handleKillOrLiveAgent (sf, oldIn, newOut')\n                otherIns'' = distributeActions otherIns' newOut'\n\n        handleConversation :: [(AgentIn s m e, e)]\n                                -> (AgentOut s m e, e)\n                                -> ([(AgentIn s m e, e)], (AgentOut s m e, e))\n        handleConversation otherIns newOut\n            | hasConversation $ fst newOut = handleConversation otherIns' newOut'\n            | otherwise = (otherIns, newOut)\n            where\n                conv@(_, senderReplyFunc) = fromEvent $ aoConversation $ fst newOut\n\n                -- NOTE: it is possible that agents which are just newly created are already target of a conversation because\n                --       their position in the environment was occupied using their id which exposes them to potential messages\n                --       and conversations. These newly created agents are not yet available in the current iteration and can\n                --       only fully participate in the next one. Thus we ignore conversation-requests\n\n                mayRepl = conversationReply otherIns newOut conv\n                (otherIns', newOut') = maybe (otherIns, senderReplyFunc newOut Nothing) id mayRepl\n\n                conversationReply :: [(AgentIn s m e, e)] \n                                        -> (AgentOut s m e, e)\n                                        -> (AgentMessage m, AgentConversationSender s m e)\n                                        -> Maybe ([(AgentIn s m e, e)], (AgentOut s m e, e))\n                conversationReply otherIns newOut ((receiverId, receiverMsg), senderReplyFunc) =\n                    do\n                        receivingIdx <- findIndex ((==receiverId) . aiId . fst) otherIns\n                        let receivingIn = otherIns !! receivingIdx \n                        convHandler <- aiConversation $ fst receivingIn\n                        (replyM, receivingIn') <- convHandler receivingIn (aoId $ fst newOut, receiverMsg)\n                        let otherIns' = replace receivingIdx otherIns receivingIn'\n                        let newOut' = senderReplyFunc newOut (Just (receiverId, replyM))\n                        return (otherIns', newOut')\n\n        replace :: Int -> [a] -> a -> [a]\n        replace idx as a = front ++ (a : backNoElem)\n            where\n                (front, back) = splitAt idx as  -- NOTE: back includes the element with the index\n                backNoElem = tail back\n\n        handleKillOrLiveAgent :: (AgentBehaviour s m e, (AgentIn s m e, e), (AgentOut s m e, e))\n                                    -> Maybe (AgentBehaviour s m e, (AgentIn s m e, e), (AgentOut s m e, e))\n        handleKillOrLiveAgent (sf, oldIn, newOut)\n            | killAgent = Nothing\n            | otherwise = Just (sf, newIn', newOut)\n            where\n                killAgent = isEvent $ aoKill $ fst newOut\n                newIn = newAgentIn oldIn newOut\n                -- NOTE: need to handle sending messages to itself because the input of this agent is not in the list of all inputs because it will be replaced anyway by newIn\n                newIn' = collectMessagesFor [newOut] newIn\n\n        distributeActions :: [(AgentIn s m e, e)] -> (AgentOut s m e, e) -> [(AgentIn s m e, e)]\n        distributeActions otherIns newOut = otherIns1\n            where\n                 -- NOTE: distribute messages to all other agents\n                otherIns0 = distributeMessages otherIns [newOut]\n                -- NOTE: passing the changed environment to the next agents\n                otherIns1 = passEnvForward newOut otherIns0\n\n        passEnvForward :: (AgentOut s m e, e) -> [(AgentIn s m e, e)] -> [(AgentIn s m e, e)]\n        passEnvForward (out, e) allIns = replaceEnvOfAins e allIns\n----------------------------------------------------------------------------------------------------------------------\n\n----------------------------------------------------------------------------------------------------------------------\n-- PARALLEL STRATEGY\n----------------------------------------------------------------------------------------------------------------------\nsimulatePar :: SimulationParams e\n                -> [AgentBehaviour s m e]\n                -> [AgentIn s m e]\n                -> e\n                -> SF () ([AgentOut s m e], e)\nsimulatePar initParams initSfs initAis initEnv = SF { sfTF = tf0 }\n    where\n        tf0 _ = (tfCont, (initOuts, initEnv))\n            where\n                -- NOTE: to prevent undefined outputs we create outputs based on the initials\n                initOuts = map agentOutFromIn initAis\n                initInputsWithEnv = addEnvToAins initEnv initAis\n                tfCont = simulateParAux initParams initSfs initInputsWithEnv initEnv\n\n        -- NOTE: here we create recursively a new continuation\n        -- ins are the old inputs from which outs resulted, together with their sfs\n        simulateParAux params sfs insWithEnv e = SF' tf\n            where\n                -- NOTE: this is a function defition\n                -- tf :: DTime -> [i] -> Transition [i] [o]\n                tf dt _ =  (tf', (outs, e'))\n                    where\n                         -- run the next step with the new sfs and inputs to get the sf-contintuations and their outputs\n                        (sfs', outsWithEnv) = runParInternal sfs insWithEnv\n\n                        -- freezing the collection of SF' to 'promote' them back to SF\n                        frozenSfs = freezeCol sfs' dt\n\n                        -- using the callback to create the next inputs and allow changing of the SF-collection\n                        (sfs'', insWithEnv') = parCallback insWithEnv outsWithEnv frozenSfs\n\n                        (e', params') = collapseEnvironments dt params outsWithEnv e \n                        insWithEnv'' = distributeEnvironment params' insWithEnv' e'\n\n                        -- NOTE: although the agents make the move at the same time, when shuffling them, \n                        --          the order of collecting and distributing the messages makes a difference \n                        --          if model-semantics are relying on randomized message-ordering, then shuffling is required and has to be turned on in the params\n                        (params'', sfsShuffled, insShuffled) = shuffleAgents params' sfs'' insWithEnv''\n                        outs = map fst outsWithEnv\n\n                        -- create a continuation of this SF\n                        tf' = simulateParAux params'' sfsShuffled insShuffled e'\n\n        collapseEnvironments :: Double -> SimulationParams e -> [(AgentOut s m e, e)] -> e -> (e, SimulationParams e)\n        collapseEnvironments dt params outsWithEnv e\n            | isCollapsingEnv = runEnv dt params collapsedEnv \n            | otherwise = (e, params)\n            where\n                isCollapsingEnv = isJust mayEnvCollapFun\n\n                mayEnvCollapFun = simEnvCollapse params\n                envCollapFun = fromJust mayEnvCollapFun\n\n                allEnvs = map snd outsWithEnv\n                collapsedEnv = envCollapFun allEnvs \n\n        distributeEnvironment :: SimulationParams e -> [(AgentIn s m e, e)] -> e -> [(AgentIn s m e, e)]\n        distributeEnvironment params ins e \n            | isCollapsingEnv = replaceEnvOfAins e ins\n            | otherwise = ins\n            where\n                isCollapsingEnv = isJust $ simEnvCollapse params\n\nparCallback :: [(AgentIn s m e, e)]\n                -> [(AgentOut s m e, e)]\n                -> [AgentBehaviour s m e]\n                -> ([AgentBehaviour s m e], [(AgentIn s m e, e)])\nparCallback oldAgentIns newAgentOuts asfs = (asfs', newAgentIns')\n    where\n        (asfs', newAgentIns) = processAgents asfs oldAgentIns newAgentOuts\n        newAgentIns' = distributeMessages newAgentIns newAgentOuts\n\n        processAgents :: [AgentBehaviour s m e]\n                            -> [(AgentIn s m e, e)]\n                            -> [(AgentOut s m e, e)]\n                            -> ([AgentBehaviour s m e], [(AgentIn s m e, e)])\n        processAgents asfs oldIs newOs = foldr handleAgent ([], []) asfsIsOs\n            where\n                asfsIsOs = zip3 asfs oldIs newOs\n\n                handleAgent :: (AgentBehaviour s m e, (AgentIn s m e, e), (AgentOut s m e, e))\n                                -> ([AgentBehaviour s m e], [(AgentIn s m e, e)])\n                                -> ([AgentBehaviour s m e], [(AgentIn s m e, e)])\n                handleAgent  a@(_, oldIn, newOut) acc = handleKillOrLiveAgent acc' a\n                    where\n                        idGen = aiIdGen $ fst oldIn\n                        acc' = handleCreateAgents idGen newOut acc \n\n                handleKillOrLiveAgent :: ([AgentBehaviour s m e], [(AgentIn s m e, e)])\n                                            -> (AgentBehaviour s m e, (AgentIn s m e, e), (AgentOut s m e, e))\n                                            -> ([AgentBehaviour s m e], [(AgentIn s m e, e)])\n                handleKillOrLiveAgent acc@(asfsAcc, ainsAcc) (sf, oldIn, newOut)\n                    | killAgent = acc\n                    | otherwise = (sf : asfsAcc, newIn : ainsAcc) \n                    where\n                        killAgent = isEvent $ aoKill $ fst newOut\n                        newIn = newAgentIn oldIn newOut\n----------------------------------------------------------------------------------------------------------------------\n\n\n----------------------------------------------------------------------------------------------------------------------\n-- utils\n----------------------------------------------------------------------------------------------------------------------\nnewAgentIn :: (AgentIn s m e, e) \n                -> (AgentOut s m e, e) \n                -> (AgentIn s m e, e)\nnewAgentIn (oldIn, _) (newOut, e') = (newIn, e')\n    where\n        newIn = oldIn { aiStart = NoEvent,\n                        aiState = aoState newOut,\n                        aiMessages = NoEvent,\n                        aiRng = aoRng newOut }\n\nshuffleAgents :: SimulationParams e \n                -> [AgentBehaviour s m e] \n                -> [(AgentIn s m e, e)] \n                -> (SimulationParams e, [AgentBehaviour s m e], [(AgentIn s m e, e)])\nshuffleAgents params sfs ins \n    | doShuffle = (params', sfs', ins')\n    | otherwise = (params, sfs, ins)\n    where\n        doShuffle = simShuffleAgents params\n        g = simRng params \n\n        sfsIns = zip sfs ins\n        (shuffledSfsIns, g') = fisherYatesShuffle g sfsIns\n\n        params' = params { simRng = g' }\n        --(sfs', ins') = foldr (\\(sf, i) (sfAcc, insAcc) -> (sf : sfAcc, i : insAcc)) ([], []) shuffledSfsIns\n        (sfs', ins') = unzip shuffledSfsIns\n\naddEnvToAins :: e -> [AgentIn s m e] -> [(AgentIn s m e, e)]\naddEnvToAins e ains = map (swap . ((,) e)) ains\n\nreplaceEnvOfAins :: e ->  [(AgentIn s m e, e)] -> [(AgentIn s m e, e)]\nreplaceEnvOfAins e ains = map (swap . ((,) e) . fst) ains\n-----------------------------------------------------------------------------------\n\nrunEnv :: DTime -> SimulationParams e -> e -> (e, SimulationParams e)\nrunEnv dt params e = maybe (e, params) (runEnvAux params e) mayEnvBeh\n    where\n        mayEnvBeh = simEnvBehaviour params\n\n        runEnvAux :: SimulationParams e -> e -> EnvironmentBehaviour e -> (e, SimulationParams e)\n        runEnvAux params e envBeh = (e', params')\n            where\n                (envBeh', e') = runAndFreezeSF envBeh e dt\n                params' = params { simEnvBehaviour = Just envBeh' }\n\nhandleCreateAgents :: TVar Int\n                        -> (AgentOut s m e, e)\n                        -> ([AgentBehaviour s m e], [(AgentIn s m e, e)])\n                        -> ([AgentBehaviour s m e], [(AgentIn s m e, e)])\nhandleCreateAgents idGen (ao, e) acc@(asfsAcc, ainsAcc) \n    | hasCreateAgents = (asfsAcc ++ newSfs, ainsAcc ++ newAisWithEnv)\n    | otherwise = acc\n    where\n        newAgentDefsEvt = aoCreate ao\n        hasCreateAgents = isEvent newAgentDefsEvt\n        newAgentDefs = fromEvent newAgentDefsEvt\n        newSfs = map adBeh newAgentDefs\n        newAis = map (startingAgentInFromAgentDef idGen) newAgentDefs\n        newAisWithEnv = addEnvToAins e newAis\n\ncollectMessagesFor :: [(AgentOut s m e, e)] -> (AgentIn s m e, e) -> (AgentIn s m e, e)\ncollectMessagesFor aouts (ain, e) = (ain', e)\n    where\n        aid = aiId ain\n        aiMsgs = aiMessages ain\n\n        msgsEvt = foldr (\\ao accMsgs -> mergeMessages (collectMessagesFrom aid ao) accMsgs) aiMsgs aouts\n\n        ain' = ain { aiMessages = msgsEvt }\n\ncollectMessagesFrom :: AgentId -> (AgentOut s m e, e) -> Event [AgentMessage m]\ncollectMessagesFrom aid (ao, _) = foldr collectMessagesFromAux NoEvent msgs\n    where\n        senderId = aoId ao\n        msgsEvt = aoMessages ao\n        msgs = event [] id msgsEvt\n\n        collectMessagesFromAux :: AgentMessage m -> Event [AgentMessage m] -> Event [AgentMessage m]\n        collectMessagesFromAux (receiverId, m) accMsgs\n            | receiverId == aid = mergeMessages (Event [(senderId, m)]) accMsgs\n            | otherwise = accMsgs\n\ndistributeMessages = distributeMessagesFast\n\ndistributeMessagesSlow :: [(AgentIn s m e, e)] -> [(AgentOut s m e, e)] -> [(AgentIn s m e, e)]\ndistributeMessagesSlow ains aouts = map (collectMessagesFor aouts) ains\n\ndistributeMessagesFast :: [(AgentIn s m e, e)] -> [(AgentOut s m e, e)] -> [(AgentIn s m e, e)]\ndistributeMessagesFast ains aouts = map (distributeMessagesAux allMsgs) ains\n    where\n        allMsgs = collectAllMessages aouts\n\n        distributeMessagesAux :: Map.Map AgentId [AgentMessage m]\n                                    -> (AgentIn s m e, e)\n                                    -> (AgentIn s m e, e)\n        distributeMessagesAux allMsgs (ain, e) = (ain', e) \n            where\n                receiverId = aiId ain\n                msgs = aiMessages ain -- NOTE: ain may have already messages, they would be overridden if not incorporating them\n\n                mayReceiverMsgs = Map.lookup receiverId allMsgs\n                msgsEvt = maybe msgs (\\receiverMsgs -> mergeMessages (Event receiverMsgs) msgs) mayReceiverMsgs\n\n                ain' = ain { aiMessages = msgsEvt }\n\ncollectAllMessages :: [(AgentOut s m e, e)] -> Map.Map AgentId [AgentMessage m]\ncollectAllMessages aos = foldr collectAllMessagesAux Map.empty aos\n    where\n        collectAllMessagesAux :: (AgentOut s m e, e)\n                                    -> Map.Map AgentId [AgentMessage m]\n                                    -> Map.Map AgentId [AgentMessage m]\n        collectAllMessagesAux (ao, _) accMsgs \n            | isEvent msgsEvt = foldr collectAllMessagesAuxAux accMsgs (fromEvent msgsEvt)\n            | otherwise = accMsgs\n            where\n                senderId = aoId ao\n                msgsEvt = aoMessages ao\n\n                collectAllMessagesAuxAux :: AgentMessage m\n                                            -> Map.Map AgentId [AgentMessage m]\n                                            -> Map.Map AgentId [AgentMessage m]\n                collectAllMessagesAuxAux (receiverId, m) accMsgs = Map.insert receiverId newMsgs accMsgs\n                    where\n                        mayReceiverMsgs = Map.lookup receiverId accMsgs\n                        msg = (senderId, m)\n\n                        newMsgs = maybe [msg] (\\receiverMsgs -> (msg : receiverMsgs)) mayReceiverMsgs\n----------------------------------------------------------------------------------------------------------------------",
			"file": "src/FRP/FrABS/Simulation/Simulation.hs",
			"file_size": 32886,
			"file_write_time": 131504582886955323,
			"settings":
			{
				"buffer_size": 32977,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		}
	],
	"build_system": "",
	"build_system_choices":
	[
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 392.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"stack",
				"SublimeHaskell: Stack Exec"
			],
			[
				"haskell",
				"SublimeHaskell: Lint"
			],
			[
				"Package Control: insta",
				"Package Control: Install Package"
			],
			[
				"Package Control: install",
				"Package Control: Install Package"
			],
			[
				"install",
				"Package Control: Install Package"
			]
		],
		"width": 485.0
	},
	"console":
	{
		"height": 289.0,
		"history":
		[
			"import urllib.request,os,hashlib; h = 'df21e130d211cfc94d9b0905775a7c0f' + '1e3d39e33b79698005270310898eea76'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by) ",
			"import urllib.request,os; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), 'wb').write(urllib.request.urlopen( 'http://sublime.wbond.net/' + pf.replace(' ','%20')).read())"
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/home/jonathan/phd/coding/libraries/frABS",
		"/home/jonathan/phd/coding/libraries/frABS/examples",
		"/home/jonathan/phd/coding/libraries/frABS/src",
		"/home/jonathan/phd/coding/libraries/frABS/src/FRP",
		"/home/jonathan/phd/coding/libraries/frABS/src/FRP/FrABS",
		"/home/jonathan/phd/coding/libraries/frABS/src/FRP/FrABS/Simulation"
	],
	"file_history":
	[
		"/home/jonathan/phd/coding/libraries/frABS/examples/NewAgents/Run.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/NewAgents/Model.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/SugarScape/Exporter.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/SugarScape/Model.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/SugarScape/Run.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/Conversation/Run.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/DoubleAuction/Run.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/DoubleAuction/Model.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/FrSIRSNetwork/Run.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/FrSIRSSpatial/Run.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/FrSIRSNetwork/Model.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/FrSIRSSpatial/Model.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/PolicyEffects/Run.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/PolicyEffects/Model.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/PrisonersDilemma/Run.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/RecursiveABS/Run.hs",
		"/home/jonathan/phd/coding/libraries/frABS/src/FRP/FrABS.hs",
		"/home/jonathan/phd/coding/libraries/frABS/src/FRP/FrABS/Agent/Agent.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/SysDynSIR/Model.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/SysDynSIR/Run.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/Zombies/Model.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/Zombies/Run.hs",
		"/home/jonathan/phd/coding/libraries/frABS/src/FRP/FrABS/Simulation/Replication.hs",
		"/home/jonathan/phd/coding/libraries/frABS/src/FRP/FrABS/Simulation/Simulation.hs",
		"/home/jonathan/phd/coding/libraries/frABS/src/FRP/FrABS/Rendering/GlossSimulator.hs",
		"/home/jonathan/phd/coding/libraries/frABS/src/FRP/FrABS/Agent/Reactive.hs",
		"/home/jonathan/phd/coding/libraries/frABS/src/FRP/FrABS/Agent/Monad.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/DoubleAuction/Auctioneer.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/NewAgents/Agent.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/NewAgents/Init.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/DoubleAuction/Init.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/NewAgent/Model.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/NewAgent/Init.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/NewAgent/Agent.hs",
		"/home/jonathan/phd/coding/libraries/frABS/src/FRP/FrABS/Environment/Discrete.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/Main.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/Zombies/Agent.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/Segregation/Run.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/Zombies/Renderer.hs",
		"/home/jonathan/phd/coding/libraries/frABS/src/FRP/FrABS/Rendering/Discrete2d.hs",
		"/home/jonathan/phd/coding/libraries/frABS/src/FRP/FrABS/Environment/Continuous.hs",
		"/home/jonathan/phd/coding/libraries/frABS/src/FRP/FrABS/Environment/Utils.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/AgentZero/Init.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/AgentZero/Agent.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/AgentZero/Model.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/HeroesCowards/Agent.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/HeroesCowards/Model.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/Zombies/Init.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/SugarScape/Init.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/SugarScape/Agent.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/Wildfire/Init.hs",
		"/home/jonathan/phd/coding/libraries/frABS/src/FRP/FrABS/Rendering/Continuous2d.hs",
		"/home/jonathan/phd/coding/libraries/frABS/src/FRP/FrABS/Utils.hs",
		"/home/jonathan/phd/coding/libraries/frABS/FrABS.cabal",
		"/home/jonathan/phd/coding/libraries/frABS/src/FRP/FrABS/Agent/Random.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/AgentZero/Run.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/FrSIRSSpatial/Agent.hs",
		"/home/jonathan/phd/coding/libraries/frABS/src/FRP/FrABS/Environment/Spatial.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/SugarScape/Common.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/FrSIRSNetwork/Init.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/FrSIRSSpatial/Init.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/PrisonersDilemma/Agent.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/PrisonersDilemma/Init.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/SIRS/Agent.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/Segregation/Agent.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/Segregation/Init.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/Wildfire/Agent.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/Zombies/Environment.hs",
		"/home/jonathan/phd/coding/libraries/frABS/src/FRP/FrABS/Environment/Network.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/SugarScape/Tests/Common.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/SugarScape/Tests/Test.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/SugarScape/Renderer.hs",
		"/home/jonathan/phd/coding/libraries/frABS/src/tests/Environment/Discrete.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/SugarScape/Environment.hs",
		"/home/jonathan/phd/coding/libraries/frABS/src/FRP/FrABS/Rendering/Network.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/Segregation/Stats.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/PolicyEffects/Renderer.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/Wildfire/Renderer.hs",
		"/home/jonathan/phd/coding/libraries/frABS/src/tests/Test.hs",
		"/home/jonathan/.config/sublime-text-3/Packages/SublimeHaskell/Settings/SublimeHaskell.sublime-settings",
		"/home/jonathan/.config/sublime-text-3/Packages/User/SublimeHaskell.sublime-settings",
		"/home/jonathan/.config/sublime-text-3/Packages/User/SublimeREPL.sublime-settings",
		"/home/jonathan/phd/coding/libraries/frABS/src/tests/Discrete2d.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/frABSExamples.cabal",
		"/home/jonathan/phd/coding/libraries/frABS/examples/SugarScape/Tests/Main.hs",
		"/home/jonathan/phd/coding/libraries/frABS/Yampa/Yampa.cabal",
		"/home/jonathan/phd/coding/libraries/frABS/examples/SugarScape/AgentCommon.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/SIRS/Run.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/sugarscape_carryingcapacity.m",
		"/home/jonathan/phd/coding/libraries/frABS/src/FRP/FrABS/Environment/Definitions.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/        Actual type",
		"/home/jonathan/phd/coding/libraries/frABS/examples/    • Found hole",
		"/home/jonathan/phd/coding/libraries/frABS/examples/    Not in scope",
		"/home/jonathan/phd/coding/libraries/frABS/examples/SugarScape/AgentMonadic.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/SugarScape/AgentPure.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/Wildfire/Run.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/SysDynSIR/StockFlow.hs",
		"/home/jonathan/phd/coding/libraries/frABS/src/FRP/FrABS/Simulation/Init.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/AgentZero/Environment.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/AgentZero/Renderer.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/frSIRSNetworkDynamics_1024agents_1000steps_0.1dt.m",
		"/home/jonathan/phd/coding/libraries/frABS/examples/FrSIRSNetwork/Agent.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/PolicyEffects/Init.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/FrSIRSNetwork/Renderer.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/HeroesCowards/Init.hs",
		"/home/jonathan/phd/coding/libraries/frABS/src/FRP/FrABS/Agent/Utils.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/PolicyEffects/Agent.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/Segregation/Model.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/FrSIRSSpatial/Renderer.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/HeroesCowards/Renderer.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/PrisonersDilemma/Renderer.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/SIRS/Renderer.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/Segregation/Renderer.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/HeroesCowards/Run.hs",
		"/home/jonathan/phd/coding/libraries/frABS/src/FRP/FrABS/Rendering/Discrete2D.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/SIRS/Model.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/PrisonersDilemma/Model.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/SIRS/Init.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/SysDynSIR/Init.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/Wildfire/Model.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/DoubleAuction/Trader.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/Conversation/Model.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/RecursiveABS/Init.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/RecursiveABS/Model.hs",
		"/home/jonathan/phd/coding/libraries/frABS/src/FRP/FrABS/Simulation/Internal.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/Conversation/Init.hs",
		"/home/jonathan/phd/coding/libraries/frABS/src/FRP/FrABS/Simulation/SeqIteration.hs",
		"/home/jonathan/phd/coding/libraries/frABS/src/FRP/FrABS/Env/Environment.hs"
	],
	"find":
	{
		"height": 23.0
	},
	"find_in_files":
	{
		"height": 90.0,
		"where_history":
		[
			"C:\\Users\\Jonathan Thaler\\phd\\coding\\libraries\\frABS\\src,*.hs"
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"SugarScapeAgentObservable",
			"AGentOut",
			"(AgentId, s)",
			"updateDomainState",
			"agentPureIgnoreEnv",
			"DAEnvironment",
			"DoubleAuctionMsg",
			"DAAgentState",
			"coordPatch",
			"Continuous2DCoord",
			"Continuous2DDimension",
			"cellAt",
			"agentRandomPicks",
			"collectMessagesFor",
			"event",
			"replaceEnvOfAins",
			"runEnv",
			"replaceEnvOfAins",
			"newAgentIn ",
			"newAgentIn",
			"passEnvForward",
			"collectMessagesFor",
			"newAgentIn",
			"distributeMessages",
			"distributeActions",
			"sendMessageToM",
			"sendMessageTo",
			"hasMessage",
			"transitionOnMessage",
			"messageEventSource",
			"transitionOnMessage",
			"sendMessage",
			"(discrete",
			"(Discrete2dCoord, c)",
			"cellAt",
			"neighbourids",
			"neighbourIdsM",
			"agentLookoutM",
			"neighboursInNeumannDistance",
			"neighbours",
			"randomCoord",
			"agentZeroAgentBehaviourFuncM",
			"wrapDisc2d",
			"defaultEnvRendererDisc2d",
			"updateCellAt",
			" \n",
			"diseasesInitial",
			"calculateHammingDistances",
			"_enableDiseases_",
			"isdis",
			"Diseased",
			"agentNonCombatMoveM",
			"agentMoveM",
			"agentKilledInCombatM",
			"agentTradingM",
			"agentAgeingM",
			"agentKilledInCombatM",
			"agentCultureContactM",
			"agentSexM",
			"InheritSugar",
			"_enableInheritance_",
			"InheritSugar",
			"passWealthOnM",
			"crossover",
			"changeCellAt",
			"handleMatingConversationM",
			"satisfiesWealthForChildBearingM",
			"satisfiesWealthForChildBearing",
			"isFertile",
			"isFertileM",
			"agentSexM",
			"agentWelfareChange",
			"bestMeasureSugarLevel",
			"poluteCell",
			"neighbourIn",
			"neighboursIn",
			"Discrete2dNeighbourhood",
			"envDisc2dNeighbourhood",
			"neighbourInDistance",
			"SugarScapeEnvCell",
			"selectBestCells",
			"SugarScapeEnvironmentMonadicBehaviour",
			"winterSeasonSugarGrowbackRatio",
			"summerSeasonSugarGrowback",
			"updateCells",
			"_enablePassWealthOnDeath_",
			"_enableSugarPassedOnDeath_",
			"_enablePassWealthOnDeath_",
			"seasons",
			"passWealthOnM",
			"diseasedMetabolismIncrease",
			"metabolismAmount",
			"runSugarScapeStepsAndExport",
			"birthNewAgentM",
			"agentDiesM",
			"cellOccupier",
			"neighbourInDistance",
			"agentMetabolismM",
			"polutionEnabled",
			"metabolismAmount",
			"agentMetabolismM",
			"inheritSugarM",
			"agentDiesM",
			"unoccupyPositionM",
			"ageRange",
			"sugAgMaxAge",
			"agentAgeingM",
			"unoccupyPositionM",
			"sugarScapeAgentBehaviour",
			"sugarScapeAgentBehaviourM",
			"sugarScapeAgentConversation",
			"unoccupyPosition",
			"poluteCell",
			"agentLookout",
			"EnvCoord",
			"poluteCell",
			"polute",
			"cellAt",
			"EnvLimits",
			"EnvCoord",
			"e2",
			"agentDiseaseProcessesM",
			"agentCreditM",
			"agentTradingM",
			"agentSexM",
			"agentCultureContactM",
			"inheritSugarM",
			"agentMetabolismM"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
			"AgentObservable s",
			"NewAgentEnvironment",
			"NewAgentMsg",
			"NewAgentState",
			"originPatch",
			"Continuous2dCoord",
			"Continuous2dDimension",
			"Discrete2dCell c",
			"Discrete2dCoord",
			"Discrete2dDimension",
			"Discrete2dCoord",
			"EnvCellColorerDisc2d",
			"EnvRendererDisc2d",
			"Continuous2DCoord",
			"Discrete2dCoord",
			"e",
			"Continuous2DCoord",
			"Discrete2DNeighbourhood",
			"Discrete2DCoord",
			"e",
			"HACMsg",
			"HACAgentState",
			"HACEnvCell",
			"HACEnvLink",
			"FrSIRSSpatialAgentIn",
			"FrSIRSSpatialAgentOut",
			"FrSIRSSpatialAgentBehaviour",
			"RecursiveABSAgentIn",
			"RecursiveABSAgentOut",
			"RecursiveABSAgentState",
			"RecursiveABSMsg",
			"RecursiveABSEnvCell",
			"PolicyEffectsEnvLink",
			"PolicyEffectsEnvCell",
			"PolicyEffectsState",
			"PolicyEffectsMsg",
			"FrSIRSNetworkEnvCell",
			"FrSIRSNetworkEnvLink",
			"PolicyEffectsLink",
			"FrSIRSSpatialAgentBehaviour",
			"FrSIRSSpatialMsg",
			"FrSIRSSpatialAgentIn",
			"FrSIRSSpatialAgentOut",
			"FrSIRSSpatialAgentBehaviour",
			"FrSIRSSpatialAgentIn",
			"FrSIRSSpatialAgentOut",
			"FrSIRSSpatialEnvLink",
			"FrSIRSSpatialEnvCell",
			"FrSIRSSpatialMsg",
			"FrSIRSSpatialAgentState",
			"onMessageMState",
			"FrSIRSNetworkAgentIn",
			"FrSIRSNetworkAgentBehaviour",
			"FrSIRSNetworkAgentOut",
			"FrSIRSNetworkEnvLink",
			"FrSIRSNetworkEnvCell",
			"FrSIRSNetworkAgentState",
			"FrSIRSNetworkMsg",
			"SysDynSIRStockState",
			"SysDynSIRMsg",
			"SysDynSIREnvLink",
			"SysDynSIREnvCell",
			"FrSIRSAgentOut",
			"FrSIRSAgentIn",
			"FrSIRSAgentBehaviour",
			"agentCellOnPos",
			"updateDomainStateM",
			"domainStateFieldM",
			"updateDomainStateM",
			"updateDomainState",
			"distanceManhattan",
			"Environment",
			"nvironment ec l ",
			"AgentOut s m ec l",
			"AgentIn s m ec l",
			"AgentDef s m ec l",
			"PDAgentState",
			"PDAgentIn",
			"PDAgentOut",
			"PDEnvironment",
			"PDMsg",
			"PDLinkLabel",
			"PDCell",
			"WildfireAgentOut",
			"WildfireAgentIn",
			"WildfireEnvironment",
			"hexLitToInt",
			"-------------------------------------------------------------------------------"
		],
		"reverse": false,
		"show_context": false,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 1,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "examples/Main.hs",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1415,
						"regions":
						{
						},
						"selection":
						[
							[
								755,
								755
							]
						],
						"settings":
						{
							"syntax": "Packages/SublimeHaskell/Syntaxes/Haskell-SublimeHaskell.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 180.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "src/FRP/FrABS/Simulation/Simulation.hs",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 32977,
						"regions":
						{
						},
						"selection":
						[
							[
								4157,
								4157
							]
						],
						"settings":
						{
							"syntax": "Packages/Haskell/Haskell.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1173.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 23.0
	},
	"input":
	{
		"height": 35.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.exec":
	{
		"height": 273.0
	},
	"output.find_results":
	{
		"height": 0.0
	},
	"output.haskell_run_output":
	{
		"height": 100.0
	},
	"output.sublime_haskell_error_panel":
	{
		"height": 118.0
	},
	"output.sublime_haskell_output_panel":
	{
		"height": 302.0
	},
	"pinned_build_system": "Packages/Haskell/Haskell.sublime-build",
	"project": "frabs.sublime-project",
	"replace":
	{
		"height": 42.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 355.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
