{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"envion",
				"environmentPositionM"
			],
			[
				"igni",
				"ignitionEvent"
			],
			[
				"init",
				"initIgnite"
			],
			[
				"extractParamFrom",
				"extractParamFromVector ∷ Value → Int → Maybe Value\tRpc.Utils"
			],
			[
				"exc",
				"extractParam ∷ Value → Int → Text → Maybe Value\tRpc.Utils"
			],
			[
				"encod",
				"encodeQuantity ∷ Int → String\tRpc.Utils"
			],
			[
				"JsonRpcRe",
				"JsonRpcResponse \tEthJsonRpc.Methods"
			],
			[
				"server",
				"serverLoop"
			],
			[
				"et",
				"ethJsonRpcPort"
			],
			[
				"SockA",
				"SockAddrInet"
			],
			[
				"receivi",
				"receivingIdx"
			],
			[
				"rece",
				"receivingIn"
			],
			[
				"may",
				"mayIdx"
			],
			[
				"handleCon",
				"handleConversationAux"
			],
			[
				"mayb",
				"maybeFunc1"
			],
			[
				"SugarScapeC",
				"SugarScapeEnvCell \tSugarScape.SugarScapeModel"
			],
			[
				"sugEnv",
				"sugEnvSugarLevel ∷ SugarScapeEnvCell → Double\tSugarScape.SugarScapeModel"
			],
			[
				"sugAgSug",
				"sugAgSugarLevel ∷ SugarScapeAgentState → Double\tSugarScape.SugarScapeModel"
			],
			[
				"Cultur",
				"SugarScapeCulturalTag \tSugarScape.SugarScapeModel"
			]
		]
	},
	"buffers":
	[
		{
			"file": "examples/Main.hs",
			"settings":
			{
				"buffer_size": 839,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"contents": "{-# LANGUAGE Arrows #-}\nmodule SugarScape.SugarScapeAgent where\n\n-- Project-internal import first\nimport SugarScape.SugarScapeModel\nimport SugarScape.SugarScapeEnvironment\nimport Utils.Utils\n\nimport FrABS.Env.Environment\nimport FrABS.Agent.Agent\nimport FrABS.Agent.AgentUtils\n\n-- Project-specific libraries follow\nimport FRP.Yampa\n\n-- System imports then\nimport Data.Maybe\nimport Data.List\nimport System.Random\nimport Control.Monad.Random\nimport Control.Monad\nimport Control.Monad.IfElse\nimport Control.Monad.Trans.State\n\n-- debugging imports finally, to be easily removed in final version\nimport Debug.Trace\n\n\n------------------------------------------------------------------------------------------------------------------------\n-- DOMAIN-STATE FUNCTIONS not used for manipulating the state\n------------------------------------------------------------------------------------------------------------------------\nmetabolismAmount :: SugarScapeAgentState -> (Double, Double)\nmetabolismAmount s = (sugarMetab + inc, spiceMetab + inc)\n    where\n        sugarMetab = sugAgSugarMetab s\n        spiceMetab = sugAgSpiceMetab s\n        inc = if isDiseased s then diseasedMetabolismIncrease else 0 \n\ntype BestCellMeasureFunc = (SugarScapeEnvCell -> Double) \n\nselectBestCells :: BestCellMeasureFunc\n                    -> EnvCoord\n                    -> [(EnvCoord, SugarScapeEnvCell)]\n                    -> [(EnvCoord, SugarScapeEnvCell)]\nselectBestCells measureFunc refCoord cs = bestShortestdistanceManhattanCells\n    where\n        cellsSortedByMeasure = sortBy (\\c1 c2 -> compare (measureFunc $ snd c2) (measureFunc $ snd c1)) cs\n        bestCellMeasure = measureFunc $ snd $ head cellsSortedByMeasure\n        bestCells = filter ((==bestCellMeasure) . measureFunc . snd) cellsSortedByMeasure\n\n        shortestdistanceManhattanBestCells = sortBy (\\c1 c2 -> compare (distanceManhattan refCoord (fst c1)) (distanceManhattan refCoord (fst c2))) bestCells\n        shortestdistanceManhattan = distanceManhattan refCoord (fst $ head shortestdistanceManhattanBestCells)\n        bestShortestdistanceManhattanCells = filter ((==shortestdistanceManhattan) . (distanceManhattan refCoord) . fst) shortestdistanceManhattanBestCells\n\nbestMeasureSugarLevel :: BestCellMeasureFunc\nbestMeasureSugarLevel c = sugEnvSugarLevel c\n\nbestMeasureSugarAndSpiceLevel :: SugarScapeAgentState -> BestCellMeasureFunc\nbestMeasureSugarAndSpiceLevel s c = agentWelfareChange s (x1, x2)\n    where\n        x1 = sugEnvSugarLevel c\n        x2 = sugEnvSpiceLevel c\n\nbestMeasureSugarPolutionRatio :: BestCellMeasureFunc\nbestMeasureSugarPolutionRatio c = sugLvl / (1 + polLvl)\n    where\n        sugLvl = sugEnvSugarLevel c\n        polLvl = sugEnvPolutionLevel c\n------------------------------------------------------------------------------------------------------------------------\n\n------------------------------------------------------------------------------------------------------------------------\n-- AGENT-BEHAVIOUR MONADIC \n------------------------------------------------------------------------------------------------------------------------\nagentDiesM :: State SugarScapeAgentOut ()\nagentDiesM = unoccupyPositionM >> killM\n\nunoccupyPositionM :: State SugarScapeAgentOut ()\nunoccupyPositionM = \n    do\n        (cellCoord, cell) <- agentCellOnPosM\n        let cellUnoccupied = cell { sugEnvOccupier = Nothing }\n        runEnvironmentM $ changeCellAtM cellCoord cellUnoccupied\n\npassWealthOnM :: State SugarScapeAgentOut ()\npassWealthOnM =\n    do\n        sugarLevel <- domainStateFieldM sugAgSugarLevel\n        childrenIds <- domainStateFieldM sugAgChildren\n\n        let hasChildren = (not . null) childrenIds\n\n        when hasChildren $\n            do \n                let childrenCount = length childrenIds\n                let childrenSugarShare = sugarLevel / (fromRational $ toRational $ fromIntegral childrenCount)\n                broadcastMessageM (InheritSugar childrenSugarShare) childrenIds\n\nstarvedToDeathM :: State SugarScapeAgentOut Bool\nstarvedToDeathM = \n    do\n        sugar <- domainStateFieldM sugAgSugarLevel\n        spice <- domainStateFieldM sugAgSpiceLevel\n        return $ (sugar <= 0) || (spice <= 0)\n\n\nagentMetabolismM :: State SugarScapeAgentOut ()\nagentMetabolismM =\n    do\n        s <- getDomainStateM\n        let (sugarMetab, spiceMetab) = metabolismAmount s\n\n        sugarLevel <- domainStateFieldM sugAgSugarLevel\n        spiceLevel <- domainStateFieldM sugAgSpiceLevel\n\n        let newSugarLevel = max 0 (sugarLevel - sugarMetab)\n        let newSpiceLevel = max 0 (spiceLevel - spiceMetab)\n\n        updateDomainStateM (\\s -> s { sugAgSugarLevel = newSugarLevel, sugAgSpiceLevel = newSpiceLevel })\n\n        -- NOTE: for now the metabolism (and harvest) of spice does not cause any polution\n        let pol = sugarMetab * polutionMetabolismFactor\n        \n        cell <- agentCellOnPosM\n        agentPoluteCellM pol cell\n\n        whenM starvedToDeathM agentDiesM\n\nagentPoluteCellM :: Double -> (EnvCoord, SugarScapeEnvCell) -> State SugarScapeAgentOut ()\nagentPoluteCellM polutionIncrease (cellCoord, cell)\n    | polutionEnabled = \n        do\n            let cellAfterPolution = cell { sugEnvPolutionLevel = polutionIncrease + (sugEnvPolutionLevel cell) }\n            runEnvironmentM $ changeCellAtM cellCoord cellAfterPolution\n    | otherwise = return ()\n\nagentNonCombatMoveM :: State SugarScapeAgentOut ()\nagentNonCombatMoveM = \n    do\n        cellsInSight <- agentLookoutM\n        pos <- environmentPositionM\n\n        let unoccupiedCells = filter (cellUnoccupied . snd) cellsInSight\n        let bestCells = selectBestCells bestMeasureSugarLevel pos unoccupiedCells\n\n        (cellCoord, _) <- agentPickRandomM bestCells\n\n        ifThenElse (null unoccupiedCells)\n                    agentStayAndHarvestM\n                    (agentMoveAndHarvestCellM cellCoord)\n\nagentLookoutM :: State SugarScapeAgentOut [(EnvCoord, SugarScapeEnvCell)]\nagentLookoutM = \n    do\n        vis <- domainStateFieldM sugAgVision\n        pos <- environmentPositionM \n        runEnvironmentM $ neighboursDistanceM pos vis\n\nagentStayAndHarvestM :: State SugarScapeAgentOut ()\nagentStayAndHarvestM = \n    do\n        (cellCoord, _) <- agentCellOnPosM\n        agentHarvestCellM cellCoord\n\nagentMoveAndHarvestCellM :: EnvCoord -> State SugarScapeAgentOut ()\nagentMoveAndHarvestCellM cellCoord = \n    do\n        agentHarvestCellM cellCoord\n        agentMoveToM cellCoord\n\nagentMoveToM :: EnvCoord -> State SugarScapeAgentOut ()\nagentMoveToM cellCoord = \n    do\n        unoccupyPositionM\n\n        s <- getDomainStateM\n        aid <- agentIdM\n        cell <- runEnvironmentM $ cellAtM cellCoord\n\n        let cellOccupied = cell { sugEnvOccupier = Just (cellOccupier aid s) }\n\n        runEnvironmentM $ changeCellAtM cellCoord cellOccupied\n        changeEnvironmentPositionM cellCoord\n\nagentHarvestCellM :: EnvCoord -> State SugarScapeAgentOut ()\nagentHarvestCellM cellCoord = \n    do\n        cell <- runEnvironmentM $ cellAtM cellCoord\n\n        sugarLevelAgent <- domainStateFieldM sugAgSugarLevel\n        spiceLevelAgent <- domainStateFieldM sugAgSpiceLevel\n\n        let sugarLevelCell = sugEnvSugarLevel cell\n        let spiceLevelCell = sugEnvSpiceLevel cell\n\n        let newSugarLevelAgent = sugarLevelCell + sugarLevelAgent\n        let newSpiceLevelAgent = spiceLevelCell + spiceLevelAgent\n\n        updateDomainStateM (\\s -> s { sugAgSugarLevel = newSugarLevelAgent, sugAgSpiceLevel = newSpiceLevelAgent })\n\n        let cellHarvested = cell { sugEnvSugarLevel = 0.0, sugEnvSpiceLevel = 0.0 }\n        runEnvironmentM $ changeCellAtM cellCoord cellHarvested\n       \n        -- NOTE: at the moment harvesting SPICE does not influence the polution\n        let pol = sugarLevelCell * polutionHarvestFactor \n        agentPoluteCellM pol (cellCoord, cellHarvested)\n\nagentAgeingM :: Double -> State SugarScapeAgentOut ()\nagentAgeingM newAge =\n    do\n        updateDomainStateM (\\s -> s { sugAgAge = newAge })\n\n        whenM dieFromAgeM $ \n            do\n                -- birthNewAgentM\n                passWealthOnM\n                agentDiesM\n\nbirthNewAgentM :: State SugarScapeAgentOut ()\nbirthNewAgentM = \n    do\n        newAgentId <- agentIdM -- NOTE: we keep the old id\n        newAgentCoord <- findUnoccpiedRandomPositionM\n        newAgentDef <- runAgentRandomM $ randomAgent (newAgentId, newAgentCoord) sugarScapeAgentBehaviour sugarScapeAgentConversation\n        createAgentM newAgentDef\n\n    where\n        findUnoccpiedRandomPositionM :: State SugarScapeAgentOut EnvCoord\n        findUnoccpiedRandomPositionM =\n            do\n                env <- environmentM\n                (c, coord) <- runAgentRandomM $ (randomCell env)\n\n                ifThenElse (cellOccupied c) findUnoccpiedRandomPositionM (return coord)\n                \ndieFromAgeM :: State SugarScapeAgentOut Bool\ndieFromAgeM = \n    do\n        age <- domainStateFieldM sugAgAge\n        maxAge <- domainStateFieldM sugAgMaxAge\n        return $ age > maxAge\n\n\n\n        \n------------------------------------------------------------------------------------------------------------------------\n-- AGENT-BEHAVIOUR NON-MONADIC \n------------------------------------------------------------------------------------------------------------------------\n------------------------------------------------------------------------------------------------------------------------\n-- Chapter II: Life And Death On The Sugarscape\n------------------------------------------------------------------------------------------------------------------------\nagentDies :: SugarScapeAgentOut -> SugarScapeAgentOut\nagentDies = unoccupyPosition . kill\n\npassWealthOn :: SugarScapeAgentOut -> SugarScapeAgentOut\npassWealthOn a\n    | null childrenIds = a\n    | otherwise = broadcastMessage a (InheritSugar childrenSugarShare) childrenIds\n    where\n        s = aoState a\n        sugarLevel = sugAgSugarLevel s\n\n        childrenIds = sugAgChildren s\n        childrenCount = length childrenIds\n        childrenSugarShare = sugarLevel / (fromRational $ toRational $ fromIntegral childrenCount)\n\nunoccupyPosition ::  SugarScapeAgentOut -> SugarScapeAgentOut\nunoccupyPosition a = a { aoEnv = env' }\n    where\n        (cellCoord, cell) = agentCellOnPos a\n        cellUnoccupied = cell { sugEnvOccupier = Nothing }\n        env' = changeCellAt (aoEnv a) cellCoord cellUnoccupied\n\nstarvedToDeath :: SugarScapeAgentOut -> Bool\nstarvedToDeath a = noSugar || noSpice\n    where\n        noSugar = (sugAgSugarLevel $ aoState a) <= 0\n        noSpice = (sugAgSpiceLevel $ aoState a) <= 0\n\nagentMetabolism :: SugarScapeAgentOut -> SugarScapeAgentOut\nagentMetabolism a \n    | starvedToDeath a1 = agentDies a1\n    | otherwise = a1\n    where\n        s = aoState a\n        (sugarMetab, spiceMetab) = metabolismAmount s\n\n        newSugarLevel = max 0 ((sugAgSugarLevel s) - sugarMetab)\n        newSpiceLevel = max 0 ((sugAgSpiceLevel s) - spiceMetab)\n\n        a0 = updateDomainState a (\\s -> s { sugAgSugarLevel = newSugarLevel,\n                                        sugAgSpiceLevel = newSpiceLevel })\n\n        -- NOTE: for now the metabolism (and harvest) of spice does not cause any polution\n        pol = sugarMetab * polutionMetabolismFactor\n        cell = agentCellOnPos a0\n        a1 = agentPoluteCell pol cell a0\n\nagentNonCombatMove :: SugarScapeAgentOut -> SugarScapeAgentOut\nagentNonCombatMove a\n    | null unoccupiedCells = agentStayAndHarvest a\n    | otherwise = agentMoveAndHarvestCell a' cellCoord\n    where\n        cellsInSight = agentLookout a\n        unoccupiedCells = filter (cellUnoccupied . snd) cellsInSight\n\n        refCoord = aoEnvPos a\n        bestCells = selectBestCells bestMeasureSugarLevel refCoord unoccupiedCells\n        ((cellCoord, _), a') = agentPickRandom a bestCells\n\nagentMoveAndHarvestCell :: SugarScapeAgentOut -> EnvCoord -> SugarScapeAgentOut\nagentMoveAndHarvestCell a cellCoord = a1\n    where\n        a0 = agentHarvestCell a cellCoord\n        a1 = agentMoveTo a0 cellCoord\n\nagentStayAndHarvest :: SugarScapeAgentOut -> SugarScapeAgentOut\nagentStayAndHarvest a = agentHarvestCell a cellCoord\n    where\n        (cellCoord, _) = agentCellOnPos a\n\nagentPoluteCell :: Double -> (EnvCoord, SugarScapeEnvCell) -> SugarScapeAgentOut -> SugarScapeAgentOut\nagentPoluteCell polutionIncrease (cellCoord, cell) a \n    | polutionEnabled = a { aoEnv = env }\n    | otherwise = a\n    where\n        cellAfterPolution = cell {\n            sugEnvPolutionLevel = polutionIncrease + (sugEnvPolutionLevel cell)\n        }\n        env = changeCellAt (aoEnv a) cellCoord cellAfterPolution\n\nagentHarvestCell  :: SugarScapeAgentOut -> EnvCoord -> SugarScapeAgentOut\nagentHarvestCell a cellCoord = a2\n    where\n        cell = cellAt (aoEnv a) cellCoord\n\n        sugarLevelCell = sugEnvSugarLevel cell\n        sugarLevelAgent = sugAgSugarLevel $ aoState a\n        newSugarLevelAgent = sugarLevelCell + sugarLevelAgent\n\n        spiceLevelCell = sugEnvSpiceLevel cell\n        spiceLevelAgent = sugAgSpiceLevel $ aoState a\n        newSpiceLevelAgent = spiceLevelCell + spiceLevelAgent\n\n        a0 = updateDomainState a (\\s -> s { sugAgSugarLevel = newSugarLevelAgent,\n                                        sugAgSpiceLevel = newSpiceLevelAgent })\n\n        cellHarvested = cell { sugEnvSugarLevel = 0.0,\n                                 sugEnvSpiceLevel = 0.0 }\n        env = changeCellAt (aoEnv a0) cellCoord cellHarvested\n        a1 = a0 { aoEnv = env }\n\n        -- NOTE: at the moment harvesting SPICE does not influence the polution\n        pol = sugarLevelCell * polutionHarvestFactor \n        a2 = agentPoluteCell pol (cellCoord, cellHarvested) a1\n\nagentMoveTo :: SugarScapeAgentOut -> EnvCoord -> SugarScapeAgentOut\nagentMoveTo a cellCoord = a0 { aoEnvPos = cellCoord, aoEnv = env }\n    where\n        a0 = unoccupyPosition a\n        cell = cellAt (aoEnv a0) cellCoord\n        cellOccupied = cell { sugEnvOccupier = Just (cellOccupier (aoId a0) (aoState a0))}\n        env = changeCellAt (aoEnv a0) cellCoord cellOccupied\n\n\nagentLookout :: SugarScapeAgentOut -> [(EnvCoord, SugarScapeEnvCell)]\nagentLookout a = zip visionCoordsWrapped visionCells\n    where\n        env = aoEnv a\n        aPos = aoEnvPos a\n        n = envNeighbourhood env\n        vis = sugAgVision $ aoState a\n\n        -- TODO: put this logic into environment.hs\n        visionCoordsDeltas = foldr (\\v acc -> acc ++ (neighbourhoodScale n v)) [] [1 .. vis]\n        visionCoords = neighbourhoodOf aPos visionCoordsDeltas\n        visionCoordsWrapped = wrapCells (envLimits env) (envWrapping env) visionCoords\n        visionCells = cellsAt env visionCoordsWrapped\n\nagentAgeing :: Double -> SugarScapeAgentOut -> SugarScapeAgentOut\nagentAgeing newAge a\n    | dieFromAge a = agentDies $ passWealthOn a' -- $ birthNewAgent a\n    | otherwise = a'\n    where\n        a' = updateDomainState a (\\s -> s { sugAgAge = newAge })\n\nbirthNewAgent :: SugarScapeAgentOut -> SugarScapeAgentOut\nbirthNewAgent a = createAgent a1 newAgentDef\n    where\n        newAgentId = aoId a                                 -- NOTE: we keep the old id\n        (newAgentCoord, a0) = findUnoccpiedRandomPosition a\n        (newAgentDef, a1) = runAgentRandom a0\n            (randomAgent (newAgentId, newAgentCoord) sugarScapeAgentBehaviour sugarScapeAgentConversation)\n\n        findUnoccpiedRandomPosition :: SugarScapeAgentOut -> (EnvCoord, SugarScapeAgentOut)\n        findUnoccpiedRandomPosition a\n            | cellOccupied c = findUnoccpiedRandomPosition a'\n            | otherwise = (coord, a')\n            where\n                ((c, coord), a') = runAgentRandom a (randomCell (aoEnv a))\n                \ndieFromAge :: SugarScapeAgentOut -> Bool\ndieFromAge a = age > maxAge\n    where\n        s = aoState a\n        age = sugAgAge s\n        maxAge = sugAgMaxAge s\n------------------------------------------------------------------------------------------------------------------------\n\n------------------------------------------------------------------------------------------------------------------------\n-- CHAPTER III: Sex, Culture, And Conflict: The Emergence Of History\n------------------------------------------------------------------------------------------------------------------------\nagentSex :: SugarScapeAgentOut -> SugarScapeAgentOut\nagentSex a\n    | isFertile s = agentMatingConversation nids nncsUnoccupied a\n    | otherwise = a\n    where\n        s = aoState a\n        pos = aoEnvPos a\n        env = aoEnv a\n\n        neighbourCells = neighbours env pos\n        nids = neighbourIds a\n\n        -- NOTE: this calculates the cells which are in the initial neighbourhood and in the neighbourhood of all the neighbours\n        nncsDupl = foldr (\\(coord, _) acc -> (neighbours env coord) ++ acc) neighbourCells neighbourCells\n        -- NOTE: the nncs are not unique, remove duplicates\n        nncsUnique = nubBy (\\(coord1, _) (coord2, _) -> (coord1 == coord2)) nncsDupl\n        nncsUnoccupied = filter (isNothing . sugEnvOccupier . snd) nncsUnique\n\n        agentMatingConversation :: [AgentId]\n                                        -> [(EnvCoord, SugarScapeEnvCell)]\n                                        -> SugarScapeAgentOut\n                                        -> SugarScapeAgentOut\n        agentMatingConversation [] _ a = conversationEnd a\n        agentMatingConversation _ [] a = conversationEnd a\n        agentMatingConversation (receiverId:otherAis) allCoords@((coord, cell):cs) a\n            | satisfiesWealthForChildBearing s = conversation a (receiverId, m) agentMatingConversationsReply\n            | otherwise = conversationEnd a\n            where\n                s = aoState a\n                m =  MatingRequest (sugAgGender $ s) --trace (\"MatingRequest to \" ++ (show receiverId)) MatingRequest (sugAgGender $ s)\n\n                agentMatingConversationsReply :: SugarScapeAgentOut\n                                                    -> Maybe (AgentMessage SugarScapeMsg)\n                                                    -> SugarScapeAgentOut\n                agentMatingConversationsReply a Nothing = agentMatingConversation otherAis allCoords a  -- NOTE: the target was not found or does not have a handler, continue with the next\n                agentMatingConversationsReply a (Just (_, MatingReplyNo)) = agentMatingConversation otherAis allCoords a\n                agentMatingConversationsReply a (Just (senderId, (MatingReplyYes otherTup))) = \n                    conversation a3 (receiverId, (MatingChild newBornId)) (\\a' _ -> agentMatingConversation otherAis cs a')\n                    \n                    where\n                        s = aoState a\n                        initialSugarEndow = sugAgSugarInit s\n                        sugarLevel = sugAgSugarLevel s\n\n                        mySugarContribution = initialSugarEndow / 2.0\n                        mySugarMetab = sugAgSugarMetab s\n                        mySpiceMetab = sugAgSpiceMetab s\n                        myVision = sugAgVision s\n                        myCulturalTag = sugAgCulturalTag s\n                        myImmuneSysBorn = sugAgImmuneSysBorn s\n\n                        newBornId = senderId * aoId a   -- TODO: this is a real problem: which ids do we give our newborns?\n\n                        (newBornDef, a0) = runAgentRandom a\n                            (createNewBorn \n                                (newBornId, coord)\n                                (mySugarContribution, mySugarMetab, mySpiceMetab, myVision, myCulturalTag, myImmuneSysBorn)\n                                otherTup)\n\n                        env = aoEnv a0\n                        cell' = cell { sugEnvOccupier = Just (cellOccupier newBornId (adState newBornDef))}\n                        env' = changeCellAt env coord cell'\n\n                        a1 = a0 { aoEnv = env' }\n                        a2 = updateDomainState a1 (\\s -> s { sugAgSugarLevel = sugarLevel - mySugarContribution,\n                                                        sugAgChildren = newBornId : (sugAgChildren s)})\n                        a3 = createAgent a2 newBornDef\n\n                agentMatingConversationsReply a (Just (_, _)) = agentMatingConversation otherAis allCoords a  -- NOTE: unexpected/MatingChildAck reply, continue with the next\n\ncreateNewBorn :: (AgentId, EnvCoord)\n                    -> (Double, Double, Double, Int, SugarScapeCulturalTag, SugarScapeImmuneSystem)\n                    -> (Double, Double, Double, Int, SugarScapeCulturalTag, SugarScapeImmuneSystem)\n                    -> Rand StdGen SugarScapeAgentDef\ncreateNewBorn idCoord\n                (sugEndowFather, sugarMetabFather, spiceMetabFather, visionFather, cultureFather, immuneSysBornFather)\n                (sugEndowMother, sugarMetabMother, spiceMetabMother, visionMother, cultureMother, immuneSysBornMother) =\n    do\n        newBornSugarMetab <- crossover (sugarMetabFather, sugarMetabMother)\n        newBornSpiceMetab <- crossover (spiceMetabFather, spiceMetabMother)\n        newBornVision <- crossover (visionFather, visionMother)\n        newBornCulturalTag <- crossoverBools cultureFather cultureMother\n        newBornImmuneSystem <- crossoverBools immuneSysBornFather immuneSysBornMother\n\n        let newBornSugarEndow = sugEndowFather + sugEndowMother\n\n        newBornDef <- randomAgent\n                            idCoord\n                            sugarScapeAgentBehaviour\n                            sugarScapeAgentConversation\n\n        let newBornState' = (adState newBornDef) { sugAgSugarMetab = newBornSugarMetab,\n                                                   sugAgSpiceMetab = newBornSpiceMetab,\n                                                   sugAgVision = newBornVision,\n                                                   sugAgSugarInit = newBornSugarEndow,\n                                                   sugAgCulturalTag = newBornCulturalTag,\n                                                   sugAgTribe = calculateTribe newBornCulturalTag,\n                                                   sugAgImmuneSys = newBornImmuneSystem,\n                                                   sugAgImmuneSysBorn = newBornImmuneSystem,\n                                                   sugAgDiseases = [] }\n\n        return newBornDef { adState = newBornState' }\n\nexcessAmountToChildBearing :: SugarScapeAgentState -> Double\nexcessAmountToChildBearing s = currSugar - initSugar\n    where\n        currSugar = sugAgSugarLevel s\n        initSugar = sugAgSugarInit s\n\nsatisfiesWealthForChildBearing :: SugarScapeAgentState -> Bool\nsatisfiesWealthForChildBearing s = excessAmount >= 0\n    where\n        excessAmount = excessAmountToChildBearing s\n\nisFertile :: SugarScapeAgentState -> Bool\nisFertile s = withinRange age fertilityAgeRange\n    where\n        age = sugAgAge s\n        fertilityAgeRange = sugAgFertAgeRange s\n\ntooOldForChildren :: SugarScapeAgentState -> Bool\ntooOldForChildren s = age > fertilityAgeMax \n    where\n        age = sugAgAge s\n        (_, fertilityAgeMax) = sugAgFertAgeRange s\n\nwithinRange :: (Ord a) => a -> (a, a) -> Bool\nwithinRange a (l, u) = a >= l && a <= u\n\ninheritSugar :: SugarScapeAgentIn -> SugarScapeAgentOut -> SugarScapeAgentOut\ninheritSugar ain a = onMessage ain inheritSugarAction a\n    where\n        inheritSugarAction :: SugarScapeAgentOut -> AgentMessage SugarScapeMsg -> SugarScapeAgentOut\n        inheritSugarAction a (_, (InheritSugar sug)) = updateDomainState a (\\s -> s { sugAgSugarLevel = (sugAgSugarLevel s) + sug})\n        inheritSugarAction a _ = a\n\nhandleMatingConversation :: (SugarScapeAgentGender)\n                                -> SugarScapeAgentIn\n                                -> (SugarScapeMsg, SugarScapeAgentIn)\nhandleMatingConversation otherGender ain \n    | isFertile s &&\n        satisfiesWealthForChildBearing s &&\n        differentGender = (MatingReplyYes (mySugarContribution, mySugarMetab, mySpiceMetab, myVision, myCulturalTag, myImmuneSysBorn), ain')\n    | otherwise = (MatingReplyNo, ain)\n    where\n        s = aiState ain\n        myGender = sugAgGender s\n        differentGender = myGender /= otherGender\n\n        -- NOTE: to be fertile an agent must have at least as much sugar as initially endowed, therefore it cannot go negative\n        initialSugarEndow = sugAgSugarInit s\n        sugarLevel = sugAgSugarLevel s\n        mySugarContribution = initialSugarEndow / 2.0\n        mySugarMetab = sugAgSugarMetab s\n        mySpiceMetab = sugAgSpiceMetab s\n        myVision = sugAgVision s\n        myCulturalTag = sugAgCulturalTag s\n        myImmuneSysBorn = sugAgImmuneSysBorn s\n\n        s' = s { sugAgSugarLevel = sugarLevel - mySugarContribution }\n        ain' = ain { aiState = s'}\n\n\n\nagentCultureContact :: SugarScapeAgentIn -> SugarScapeAgentOut -> SugarScapeAgentOut\nagentCultureContact ain a = broadcastMessage a' (CulturalContact culturalTag) nids \n    where\n        a' = onMessage ain cultureContactAction a\n        nids = neighbourIds a'\n        culturalTag = sugAgCulturalTag $ aoState a'\n\n        cultureContactAction :: SugarScapeAgentOut -> AgentMessage SugarScapeMsg -> SugarScapeAgentOut\n        cultureContactAction a (_, (CulturalContact tagActive)) = \n                updateDomainState a' (\\s -> s { sugAgCulturalTag = agentTag',\n                                            sugAgTribe = tribe})\n            where\n                s = aoState a\n                agentTag = sugAgCulturalTag s\n                (agentTag', a') = runAgentRandom a (cultureContact tagActive agentTag)\n                tribe = calculateTribe agentTag'\n        cultureContactAction a _ = a\n\nagentKilledInCombat :: SugarScapeAgentIn -> SugarScapeAgentOut -> SugarScapeAgentOut\nagentKilledInCombat ain a = onMessage ain killedInCombatAction a\n    where\n        killedInCombatAction :: SugarScapeAgentOut -> AgentMessage SugarScapeMsg -> SugarScapeAgentOut\n        killedInCombatAction a (_, KilledInCombat) = kill a -- NOTE: don't unoccupie position (as in agentdies) because it is occupied by the killer already\n        killedInCombatAction a _ = a\n\nagentCombatMove :: SugarScapeAgentOut -> SugarScapeAgentOut\nagentCombatMove a \n    | null targetCells = agentStayAndHarvest a\n    | otherwise = if vulnerableToRetaliation payoff a' then agentStayAndHarvest a' else moveAndHarvestBestCell bestCell a'\n    where\n        s = aoState a\n        agentPos = aoEnvPos a\n        myTribe = sugAgTribe s\n        myWealth = sugAgSugarLevel s \n\n        cellsInSight = agentLookout a\n        targetCells = filter (filterTargetCell occupierCombatable) cellsInSight\n        targeCellsWithPayoff = map cellPayoff targetCells\n\n        cellsSortedByPayoff = sortBy (\\c1 c2 -> compare (snd c2) (snd c1)) targeCellsWithPayoff\n        bestCellPayoff = snd $ head cellsSortedByPayoff\n        bestCells = filter ((==bestCellPayoff) . snd) cellsSortedByPayoff\n\n        shortestdistanceManhattanBestCells = sortBy (\\c1 c2 -> compare (distanceManhattan agentPos (fst . fst $ c1)) (distanceManhattan agentPos (fst . fst $ c2))) bestCells\n        shortestdistanceManhattan = distanceManhattan agentPos (fst . fst $ head shortestdistanceManhattanBestCells)\n        bestShortestdistanceManhattanCells = filter ((==shortestdistanceManhattan) . (distanceManhattan agentPos) . fst . fst) shortestdistanceManhattanBestCells\n\n        (bestCell@((_,_), payoff), a') = agentPickRandom a bestShortestdistanceManhattanCells\n        \n        -- NOTE: calculate if retalion is possible: is there an agent of the other tribe in my vision which is wealthier AFTER i have preyed on the current one?\n        -- TODO: this is not very well specified in the SugarScape book. we don't know the vision of the other agent, and its information we should not have access to\n        vulnerableToRetaliation :: Double -> SugarScapeAgentOut -> Bool\n        vulnerableToRetaliation payoff a = (not . null) retaliatingCells\n            where\n                sugarLevelAgent = sugAgSugarLevel $ aoState a\n                futureSugarLevel = (payoff + sugarLevelAgent)\n\n                cellsInSight = agentLookout a\n                retaliatingCells = filter (filterTargetCell (occupierRetaliator futureSugarLevel)) cellsInSight\n\n        moveAndHarvestBestCell :: ((EnvCoord, SugarScapeEnvCell), Double) -> SugarScapeAgentOut -> SugarScapeAgentOut\n        moveAndHarvestBestCell ((cellCoord, cell), payoff) a \n            | cellOccupied cell = killOccupierOfCell a'' cell\n            | otherwise = a''\n                where\n                    sugarLevelAgent = sugAgSugarLevel $ aoState a\n                    newSugarLevelAgent = (payoff + sugarLevelAgent)\n\n                    a' = unoccupyPosition $ updateDomainState a (\\s -> s { sugAgSugarLevel = newSugarLevelAgent })\n\n                    cellHarvestedAndOccupied = cell {\n                            sugEnvSugarLevel = 0.0,\n                            sugEnvOccupier = Just (cellOccupier (aoId a') (aoState a')),\n                            sugEnvPolutionLevel = 0\n                    }\n                            \n                    env = changeCellAt (aoEnv a') cellCoord cellHarvestedAndOccupied\n                    a'' = a' { aoEnvPos = cellCoord, aoEnv = env }\n\n        killOccupierOfCell :: SugarScapeAgentOut -> SugarScapeEnvCell -> SugarScapeAgentOut\n        killOccupierOfCell a cell = sendMessage a (occupierId, KilledInCombat)\n            where\n                occupier = fromJust $ sugEnvOccupier cell\n                occupierId = sugEnvOccId occupier \n\n        filterTargetCell :: (SugarScapeEnvCellOccupier -> Bool) -> (EnvCoord, SugarScapeEnvCell) -> Bool\n        filterTargetCell f (coord, cell) = maybe True f mayOccupier\n            where\n                mayOccupier = sugEnvOccupier cell\n\n        occupierCombatable :: SugarScapeEnvCellOccupier -> Bool\n        occupierCombatable occupier = differentTribe && lessWealthy\n            where\n                otherTribe = sugEnvOccTribe occupier\n                otherWealth = sugEnvOccWealth occupier\n                differentTribe = otherTribe /= myTribe\n                lessWealthy = otherWealth <myWealth \n\n        occupierRetaliator :: Double -> SugarScapeEnvCellOccupier -> Bool\n        occupierRetaliator referenceWealth occupier = differentTribe && moreWealthy\n            where\n                otherTribe = sugEnvOccTribe occupier\n                otherWealth = sugEnvOccWealth occupier\n                differentTribe = otherTribe /= myTribe\n                moreWealthy = otherWealth > referenceWealth \n\n        cellPayoff :: (EnvCoord, SugarScapeEnvCell) -> ((EnvCoord, SugarScapeEnvCell), Double)\n        cellPayoff (c, cell) = ((c, cell), payoff)\n            where\n                mayOccupier = sugEnvOccupier cell\n                sugarLevel = sugEnvSugarLevel cell\n                payoff = maybe sugarLevel (\\occupier -> sugarLevel + (min combatReward (sugEnvOccWealth occupier))) mayOccupier\n------------------------------------------------------------------------------------------------------------------------\n\n------------------------------------------------------------------------------------------------------------------------\n-- Chapter IV: Sugar and Spice - Trade Comes to the Sugarscape\n------------------------------------------------------------------------------------------------------------------------\nagentTrading :: SugarScapeAgentOut -> SugarScapeAgentOut\nagentTrading a = agentTradingConversation nids a\n    where\n        nids = neighbourIds a\n\n        agentTradingConversation :: [AgentId]\n                                    -> SugarScapeAgentOut\n                                    -> SugarScapeAgentOut\n        agentTradingConversation [] a = conversationEnd a\n        agentTradingConversation (receiverId:otherAis) a = conversation a (receiverId, m) agentTradingConversationsReply\n            where\n                mrsSelf = agentMRS $ aoState a\n                m = TradingOffer mrsSelf\n\n                agentTradingConversationsReply :: SugarScapeAgentOut\n                                                    -> Maybe (AgentMessage SugarScapeMsg)\n                                                    -> SugarScapeAgentOut\n                agentTradingConversationsReply a Nothing = agentTradingConversation otherAis a \n                agentTradingConversationsReply a (Just (_, TradingRefuse)) = agentTradingConversation otherAis a\n                agentTradingConversationsReply a (Just (_, (TradingTransact _))) = agentTradingConversation otherAis a -- NOTE: other agent has transacted, continue with next\n                agentTradingConversationsReply a (Just (senderId, (TradingAccept mrsOther))) \n                    | welfareIncreases = conversation aAfterTrade (senderId, TradingTransact mrsSelf) agentTradingConversationsReply\n                    | otherwise = agentTradingConversation otherAis a \n                    where\n                        welfareIncreases = agentTradeIncreaseWelfare s mrsOther\n                        s = aoState a\n                        s' = agentTradeExchange s mrsOther\n                        aAfterTrade = a { aoState = s' }\n\n-- NOTE: we ignore cross-over trades which is forbidden in the SugarScape-Book. We claim in our implementation it is not a problem as it works different.\n--       also agents move on in the next step and won't be neighbours anyway, so a cross-over would not really become a problem in a way as Epstein and Axtell said it would create infinite recursion\n--       which probably would occur in their oo-implementation because of direct method-calls\nhandleTradingOffer :: Double\n                        -> SugarScapeAgentIn\n                        -> (SugarScapeMsg, SugarScapeAgentIn)\nhandleTradingOffer mrsOther ain \n    | welfareIncreases = (TradingAccept mrsSelf, ain)     -- This makes the agent better off\n    | otherwise = (TradingRefuse, ain)                      -- This trade would make the agent worse off, refuse the trade\n    where\n        s = aiState ain\n        mrsSelf = agentMRS s\n        welfareIncreases = agentTradeIncreaseWelfare s mrsOther\n\nhandleTradingTransact :: Double\n                            -> SugarScapeAgentIn\n                            -> (SugarScapeMsg, SugarScapeAgentIn)\nhandleTradingTransact mrsOther ain = (TradingTransact mrsOther, ainAfterTrade) -- NOTE: simply reply with the same transaction-message\n    where\n        s = aiState ain\n        s' = agentTradeExchange s mrsOther\n        ainAfterTrade = ain { aiState = s' }\n\nagentTradeIncreaseWelfare :: SugarScapeAgentState -> Double -> Bool\nagentTradeIncreaseWelfare s mrsOther = (newWelfare > currentWelfare)\n    where\n        mrsSelf = agentMRS s\n        exchangeTup = sugarSpiceExchange mrsOther mrsSelf\n        currentWelfare = agentWelfare s\n        newWelfare = agentWelfareChange s exchangeTup\n\nagentTradeExchange :: SugarScapeAgentState -> Double -> SugarScapeAgentState\nagentTradeExchange s mrsOther = sAfterTrade -- trace (\"Trade: mrsSelf = \" ++ (show mrsSelf) ++ \" mrsOther = \" ++ (show mrsOther) ++ \", sugarChange = \" ++ (show sugarChange) ++ \" spiceChange = \" ++ (show spiceChange) ) \n    where\n        mrsSelf = agentMRS s\n        (sugarChange, spiceChange) = sugarSpiceExchange mrsOther mrsSelf\n\n        sugarLevel = sugAgSugarLevel s\n        spiceLevel = sugAgSpiceLevel s\n\n        sAfterTrade  = s { sugAgSugarLevel = sugarLevel + sugarChange, sugAgSpiceLevel = spiceLevel + spiceChange }\n \nagentMRS :: SugarScapeAgentState -> Double\nagentMRS s = (w2 * m1) / (w1 * m2)\n    where\n        m1 = sugAgSugarMetab s\n        m2 = sugAgSpiceMetab s\n\n        w1 = sugAgSugarLevel s\n        w2 = sugAgSpiceLevel s\n\n-- NOTE: this returns the sugar-to-spice exchanges from the view-point of self\nsugarSpiceExchange :: Double -> Double -> (Double, Double)\nsugarSpiceExchange mrsOther mrsSelf \n    -- NOTE: if mrsOther is larger than mrsSelf then Other values sugar more and is willing to exchange it for spice\n        -- Other takes (+) sugar and gives spice\n        -- Self takes (+) spice and gives (-) sugar\n    | (mrsOther > mrsSelf) && (price > 1) = ((-1.0), price)\n    | (mrsOther > mrsSelf) && (price <= 1) = ((-invPrice), 1.0)\n\n    -- NOTE: if mrsSelf is larger than mrsOther then Self values sugar more and is willing to exchange it for spice\n        -- Self takes sugar and gives spice\n        -- Other takes spice and gives sugar\n    | (mrsOther <= mrsSelf) && (price > 1) = (1.0, (-price)) \n    | (mrsOther <= mrsSelf) && (price <= 1) = (invPrice, (-1.0))\n    where\n        price = tradingPrice mrsOther mrsSelf\n        invPrice = 1 / price\n\ntradingPrice :: Double -> Double -> Double\ntradingPrice mrsA mrsB = sqrt $ mrsA * mrsB\n\nagentWelfare :: SugarScapeAgentState -> Double\nagentWelfare s = agentWelfareChange s (0, 0)\n\nagentWelfareChange :: SugarScapeAgentState -> (Double, Double) -> Double\nagentWelfareChange s (sugarChange, spiceChange) = ((w1 + sugarChange)**(m1/mT)) * ((w2 + spiceChange)**(m2/mT))\n    where\n        m1 = sugAgSugarMetab s\n        m2 = sugAgSpiceMetab s\n        mT = m1 + m2\n\n        w1 = sugAgSugarLevel s\n        w2 = sugAgSpiceLevel s\n\nagentCredit :: SugarScapeAgentIn -> SugarScapeAgentOut -> SugarScapeAgentOut\nagentCredit ain a = agentRequestCredit $ agentCheckCreditPaybackDue $ agentCreditPaybackIncoming ain $ agentCreditDeathIncoming ain a\n\n-- NOTE: for now only sugar is lended & borrowed, no spice\nagentRequestCredit :: SugarScapeAgentOut -> SugarScapeAgentOut\nagentRequestCredit a\n    | hasNeighbours = agentCreditConversation nids a\n    | otherwise = a\n    where\n        s = aoState a\n        nids = neighbourIds a\n        hasNeighbours = (not $ null nids)\n\n        agentCreditConversation :: [AgentId]\n                                    -> SugarScapeAgentOut\n                                    -> SugarScapeAgentOut\n        agentCreditConversation [] a = conversationEnd a\n        agentCreditConversation (receiverId:otherAis) a \n            | isPotentialBorrower s = conversation a (receiverId, CreditRequest) agentCreditConversationsReply\n            | otherwise = conversationEnd a\n            where\n                agentCreditConversationsReply :: SugarScapeAgentOut\n                                                    -> Maybe (AgentMessage SugarScapeMsg)\n                                                    -> SugarScapeAgentOut\n                agentCreditConversationsReply a Nothing = agentCreditConversation otherAis a\n                agentCreditConversationsReply a (Just (_, CreditRequestRefuse)) = agentCreditConversation otherAis a \n                agentCreditConversationsReply a (Just (lenderId, CreditOffer credit)) = agentCreditConversation otherAis aAfterBorrowing\n                    where\n                        s = aoState a\n                        age = sugAgAge s\n\n                        (faceValue, creditDuration, creditInterestRate) = credit\n                        creditDueAge = age + creditDuration \n\n                        creditInfo = (lenderId, creditDueAge, credit)\n                        aAfterBorrowing = updateDomainState a (\\s -> s { sugAgSugarLevel = sugAgSugarLevel s + faceValue,\n                                                                    sugAgBorrowingCredits = creditInfo : sugAgBorrowingCredits s })\n\n-- NOTE: if a borrower dies: notify the lenders so they know they take a loss (remove it from open credits)\n-- NOTE: if a lender dies: notify the borrowers so they know they don't have to pay back\n-- NOTE that we don't implement the inheritance-rule for loans\nagentDeathHandleCredits :: SugarScapeAgentOut -> SugarScapeAgentOut\nagentDeathHandleCredits a = aNotifiedBorrowers\n    where\n        s = aoState a\n        lenderIds = map (\\(lid, _, _) -> lid) (sugAgBorrowingCredits s)\n        borrowerIds = sugAgLendingCredits s\n        \n        aNotifiedLenders = broadcastMessage a CreditBorrowerDied lenderIds\n        aNotifiedBorrowers = broadcastMessage aNotifiedLenders CreditLenderDied borrowerIds\n\nagentCreditDeathIncoming :: SugarScapeAgentIn -> SugarScapeAgentOut -> SugarScapeAgentOut\nagentCreditDeathIncoming ain a = onMessage ain creditDeathAction a\n    where\n        creditDeathAction :: SugarScapeAgentOut -> AgentMessage SugarScapeMsg -> SugarScapeAgentOut\n        creditDeathAction a (borrowerId, CreditBorrowerDied) = borrowerDied a borrowerId\n        creditDeathAction a (lenderId, CreditLenderDied) = lenderDied a lenderId\n        creditDeathAction a _ = a\n\n        -- NOTE: the borrower could have borrowed multiple times from this lender, remove ALL ids\n        borrowerDied :: SugarScapeAgentOut -> AgentId -> SugarScapeAgentOut\n        borrowerDied a borrowerId = a' \n            where\n                s = aoState a\n                borrowers = sugAgLendingCredits s\n                borrowersRemoved = filter (/=borrowerId) borrowers\n                a' = updateDomainState a (\\s -> s { sugAgLendingCredits = borrowersRemoved } )\n\n        -- NOTE: the lender could have lended multiple times to this borrower, remove ALL credits\n        lenderDied :: SugarScapeAgentOut -> AgentId -> SugarScapeAgentOut\n        lenderDied a lenderId = a' \n            where\n                s = aoState a\n                borrowedCredits = sugAgBorrowingCredits s\n                borrowersRemoved = filter (\\(lId, _, _) -> lId /= lenderId) borrowedCredits\n                a' = updateDomainState a (\\s -> s { sugAgBorrowingCredits = borrowersRemoved } )\n\nagentCreditPaybackIncoming :: SugarScapeAgentIn -> SugarScapeAgentOut -> SugarScapeAgentOut\nagentCreditPaybackIncoming ain a = onMessage ain creditPaybackAction a\n    where\n        creditPaybackAction :: SugarScapeAgentOut -> AgentMessage SugarScapeMsg -> SugarScapeAgentOut\n        creditPaybackAction a (_, (CreditPaybackHalf amount)) = halfCreditPayback a amount\n        creditPaybackAction a (borrowerId, (CreditPaybackFull amount)) = fullCreditPayback a borrowerId amount\n        creditPaybackAction a _ = a\n\n        -- NOTE: in this case we don't remove the borrower because it has not yet payed back the whole credit\n        halfCreditPayback :: SugarScapeAgentOut -> Double -> SugarScapeAgentOut\n        halfCreditPayback = agentChangeSugarWealth \n\n        -- NOTE: in this case we just remove the first borrower-id we find. It is possible that this lender has lended multiple times to the borrower but this doesnt matter in this case\n        fullCreditPayback :: SugarScapeAgentOut -> AgentId -> Double -> SugarScapeAgentOut\n        fullCreditPayback a borrowerId amount = agentChangeSugarWealth a' amount\n            where\n                s = aoState a\n                borrowers = sugAgLendingCredits s\n                borrowersFirstRemoved = delete borrowerId borrowers\n                a' = updateDomainState a (\\s -> s { sugAgLendingCredits = borrowersFirstRemoved } )\n\nagentChangeSugarWealth :: SugarScapeAgentOut -> Double -> SugarScapeAgentOut\nagentChangeSugarWealth a amount = updateDomainState a (\\s -> s { sugAgSugarLevel = newWealth } )\n    where\n        s = aoState a\n        wealth = sugAgSugarLevel s \n        newWealth = wealth + amount\n\nagentCheckCreditPaybackDue :: SugarScapeAgentOut -> SugarScapeAgentOut\nagentCheckCreditPaybackDue a = aAfterPayback\n    where\n        s = aoState a\n        borrowingCredits = sugAgBorrowingCredits s \n\n        (a', borrowingCredits') = foldr agentCheckCreditPaybackAux (a, []) borrowingCredits\n        aAfterPayback = updateDomainState a' (\\s -> s { sugAgBorrowingCredits = borrowingCredits'})\n\n        agentCheckCreditPaybackAux :: SugarScapeCreditInfo -> (SugarScapeAgentOut, [SugarScapeCreditInfo]) -> (SugarScapeAgentOut, [SugarScapeCreditInfo])\n        agentCheckCreditPaybackAux creditInfo@(lenderId, ageDue, credit) (a, accCredits) \n            | creditDue = (a, accCredits)\n            | otherwise = (a, creditInfo : accCredits)\n            where\n                s = aoState a\n                age = sugAgAge s\n                creditDue = ageDue >= age\n\n                paybackCredit :: (SugarScapeAgentOut, [SugarScapeCreditInfo])\n                paybackCredit \n                    | fullPaybackPossible = (aAfterPayback, accCredits)\n                    | otherwise = (aAfterPayback, newCreditInfo : accCredits)\n                    where\n                        (faceValue, creditDuration, creditInterestRate) = credit\n\n                        wealth = sugAgSugarLevel s\n                        dueAmount = faceValue + (faceValue * (creditInterestRate / 100))\n                        fullPaybackPossible = wealth >= paybackAmount\n\n                        paybackAmount = if fullPaybackPossible then paybackAmount else wealth * 0.5\n                        paybackMessage = if fullPaybackPossible then (CreditPaybackFull paybackAmount) else (CreditPaybackHalf paybackAmount)\n\n                        newCredit = (faceValue - paybackAmount, creditDuration, creditInterestRate)\n                        newCreditInfo = (lenderId, age + creditDuration, newCredit)\n\n                        aReducedWealth = agentChangeSugarWealth a paybackAmount\n                        aAfterPayback = sendMessage aReducedWealth (lenderId, paybackMessage)\n\nhandleCreditRequest :: SugarScapeAgentIn -> AgentId -> (SugarScapeMsg, SugarScapeAgentIn)\nhandleCreditRequest ain borrowerId\n    | isLender = (CreditOffer credit, ainAfterCreditOffer)\n    | otherwise = (CreditRequestRefuse, ain)\n    where\n        mayFaceValue = potentialLender s\n        isLender = isJust mayFaceValue\n        \n        faceValue = fromJust mayFaceValue\n        credit = (faceValue, lendingCreditDuration, lendingCreditInterestRate)\n\n        s = aiState ain\n        s' = s { sugAgSugarLevel = (sugAgSugarLevel s) - faceValue,\n                sugAgLendingCredits = borrowerId : (sugAgLendingCredits s) }\n        ainAfterCreditOffer = ain { aiState = s' }\n\npotentialLender :: SugarScapeAgentState -> Maybe Double\npotentialLender s\n    | tooOldForChildren s = Just $ half (sugAgSugarLevel s)\n    | isFertile s = fertileLending s\n    | otherwise = Nothing\n    where\n        fertileLending :: SugarScapeAgentState -> Maybe Double\n        fertileLending s \n            | excessAmount > 0 = Just excessAmount\n            | otherwise = Nothing\n            where\n                excessAmount = excessAmountToChildBearing s\n\n        half x = x * 0.5\n\nisPotentialBorrower :: SugarScapeAgentState -> Bool\nisPotentialBorrower s \n    | isFertile s && (not $ satisfiesWealthForChildBearing s) = True\n    | otherwise = False\n\n-- NOTE: haven't implemented \"On the Evolution of Foresight\"\n------------------------------------------------------------------------------------------------------------------------\n\n------------------------------------------------------------------------------------------------------------------------\n-- Chapter V: Disease Processes\n------------------------------------------------------------------------------------------------------------------------\nisDiseased :: SugarScapeAgentState -> Bool\nisDiseased s = not $ null (sugAgDiseases s)\n\nagentDiseaseContact :: SugarScapeAgentIn -> SugarScapeAgentOut -> SugarScapeAgentOut\nagentDiseaseContact ain a = onMessage ain diseaseContactAction a\n    where\n        diseaseContactAction :: SugarScapeAgentOut -> AgentMessage SugarScapeMsg -> SugarScapeAgentOut\n        diseaseContactAction a (_, (DiseaseContact d)) = updateDomainState a (\\s -> s { sugAgDiseases = d : (sugAgDiseases s) } )\n        diseaseContactAction a _ = a\n\nagentDiseasesTransmit :: SugarScapeAgentOut -> SugarScapeAgentOut\nagentDiseasesTransmit a  \n    | (isDiseased s) && hasNeighbours = sendMessages a msgs\n    | otherwise = a\n    where\n        s = aoState a\n        nids = neighbourIds a\n        hasNeighbours = not $ null nids\n\n        neighbourCount = length nids\n        diseases = sugAgDiseases $ aoState a\n        (randDisease, a') = agentPickRandomMultiple a diseases neighbourCount\n        msgs = map (\\(receiverId, disease) -> (receiverId, DiseaseContact disease)) (zip nids randDisease)\n\nagentImmunize :: SugarScapeAgentOut -> SugarScapeAgentOut\nagentImmunize a = updateDomainState a (\\s -> s { sugAgImmuneSys = immuneSystem',\n                                            sugAgDiseases = diseases' })\n    where\n        s = aoState a\n        immuneSystem = sugAgImmuneSys s\n        diseases = sugAgDiseases s\n\n        (immuneSystem', diseases') = foldr agentImmunizeAux (immuneSystem, []) diseases\n\n        agentImmunizeAux :: SugarScapeDisease -> (SugarScapeImmuneSystem, [SugarScapeDisease]) -> (SugarScapeImmuneSystem, [SugarScapeDisease])\n        agentImmunizeAux disease (imSys, accDis) \n            | minHam == 0 = (imSys, accDis)\n            | otherwise = (imSys', disease : accDis)\n            where\n                dLen = length disease\n\n                hd = calculateHammingDistances imSys disease\n                mi@(minHam, minHamIdx) = findMinWithIdx hd\n \n                minSubImmSys = take dLen (drop minHamIdx imSys)\n\n                tagIdx = findFirstDiffIdx minSubImmSys disease\n                globalIdx = minHamIdx + tagIdx\n                imSys' = flipBoolAtIdx imSys globalIdx\n\nagentDiseaseProcesses :: SugarScapeAgentIn -> SugarScapeAgentOut -> SugarScapeAgentOut\nagentDiseaseProcesses ain a = agentImmunize $ agentDiseasesTransmit $ agentDiseaseContact ain a\n------------------------------------------------------------------------------------------------------------------------\n\n\n------------------------------------------------------------------------------------------------------------------------\n-- GENERAL AGENT-RELATED\n------------------------------------------------------------------------------------------------------------------------\nsugarScapeAgentConversation :: SugarScapeAgentConversation\n\nsugarScapeAgentConversation ain (_, (MatingRequest tup)) = Just $ handleMatingConversation tup ain\nsugarScapeAgentConversation ain (_, (MatingChild childId)) = Just (MatingChildAck, ain')\n    where\n        s = aiState ain\n        s' = s { sugAgChildren = childId : (sugAgChildren s)}\n        ain' = ain { aiState = s' }\n\nsugarScapeAgentConversation ain (_, (TradingOffer mrs)) = Just $ handleTradingOffer mrs ain\nsugarScapeAgentConversation ain (_, (TradingTransact mrs)) = Just $ handleTradingTransact mrs ain\n\nsugarScapeAgentConversation ain (borrowerId, CreditRequest) = Just $ handleCreditRequest ain borrowerId\n\nsugarScapeAgentConversation _ _ = Nothing\n\n\nneighbourIds :: SugarScapeAgentOut -> [AgentId]\nneighbourIds a = map (sugEnvOccId . fromJust . sugEnvOccupier . snd) occupiedCells\n    where\n        env = aoEnv a\n        pos = aoEnvPos a\n        neighbourCells = neighbours env pos\n        occupiedCells = filter (isJust . sugEnvOccupier . snd) neighbourCells\n\nsugarScapeAgentBehaviourFunc :: Double -> SugarScapeAgentIn -> SugarScapeAgentOut -> SugarScapeAgentOut \nsugarScapeAgentBehaviourFunc age ain a = do     \n                                            let a0 = agentKilledInCombat ain a \n                                            if isDead a0 then\n                                                agentDeathHandleCredits a0\n                                                else\n                                                    do\n                                                        let a1 = agentAgeing age a0\n                                                        if isDead a1 then\n                                                            agentDeathHandleCredits a1\n                                                            else\n                                                                do\n                                                                    let a2 = agentMetabolism a1\n                                                                    if isDead a2 then\n                                                                        agentDeathHandleCredits a2\n                                                                        else \n                                                                            do\n                                                                                let a3 = agentNonCombatMove a2\n                                                                                let a4 = inheritSugar ain a3\n                                                                                -- let a5 = agentCultureContact ain a4\n                                                                                -- let a6 = agentSex a5\n                                                                                -- let a7 = agentTrading a5\n                                                                                let a8 = agentCredit ain a4\n                                                                                --let a9 = agentDiseaseProcesses ain a4\n                                                                                a8\n\n\nsugarScapeAgentBehaviour :: SugarScapeAgentBehaviour\nsugarScapeAgentBehaviour = proc ain ->\n    do\n        age <- time -< 0\n\n        let a = agentOutFromIn ain\n        returnA -< sugarScapeAgentBehaviourFunc age ain a\n\n------------------------------------------------------------------------------------------------------------------------",
			"file": "examples/SugarScape/SugarScapeAgent.hs",
			"file_size": 54134,
			"file_write_time": 131429730908829510,
			"settings":
			{
				"buffer_size": 53041,
				"encoding": "UTF-8",
				"line_ending": "Windows"
			}
		},
		{
			"file": "src/FrABS/Agent/Agent.hs",
			"settings":
			{
				"buffer_size": 15338,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/FrABS/Env/Environment.hs",
			"settings":
			{
				"buffer_size": 10971,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		}
	],
	"build_system": "",
	"build_system_choices":
	[
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 92.0,
		"last_filter": "Package Control: insta",
		"selected_items":
		[
			[
				"Package Control: insta",
				"Package Control: Install Package"
			],
			[
				"Package Control: install",
				"Package Control: Install Package"
			],
			[
				"install",
				"Package Control: Install Package"
			]
		],
		"width": 485.0
	},
	"console":
	{
		"height": 289.0,
		"history":
		[
			"import urllib.request,os,hashlib; h = 'df21e130d211cfc94d9b0905775a7c0f' + '1e3d39e33b79698005270310898eea76'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by) ",
			"import urllib.request,os; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), 'wb').write(urllib.request.urlopen( 'http://sublime.wbond.net/' + pf.replace(' ','%20')).read())"
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/home/jonathan/phd/coding/libraries/frABS",
		"/home/jonathan/phd/coding/libraries/frABS/examples",
		"/home/jonathan/phd/coding/libraries/frABS/examples/SugarScape",
		"/home/jonathan/phd/coding/libraries/frABS/examples/Utils",
		"/home/jonathan/phd/coding/libraries/frABS/src",
		"/home/jonathan/phd/coding/libraries/frABS/src/FrABS",
		"/home/jonathan/phd/coding/libraries/frABS/src/FrABS/Agent",
		"/home/jonathan/phd/coding/libraries/frABS/src/FrABS/Env"
	],
	"file_history":
	[
		"/home/jonathan/phd/coding/libraries/frABS/examples/Utils/Utils.hs",
		"/home/jonathan/phd/coding/libraries/frABS/src/FrABS/Agent/Agent.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/SIRS/SIRSAgent.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/    • Variable not in scope",
		"/home/jonathan/phd/coding/libraries/frABS/examples/SugarScape/SugarScapeModel.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/AgentZero/AgentZeroAgent.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/frABSExamples.cabal",
		"/home/jonathan/phd/coding/libraries/frABS/src/FrABS/Agent/AgentUtils.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/SugarScape/SugarScapeAgentM.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/SugarScape/SugarScapeEnvironmentM.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/AgentZero/AgentZeroEnvironment.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/        Actual type",
		"/home/jonathan/phd/coding/libraries/frABS/examples/DoubleAuction/DATrader.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/PrisonersDilemma/PDAgent.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/Conversation/ConversationModel.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/DoubleAuction/DAAuctioneer.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/RecursiveABS/RecursiveABSModel.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/Segregation/SegregationAgent.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/SugarScape/SugarScapeAgent.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/Wildfire/WildfireAgent.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/DoubleAuction/DARun.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/DoubleAuction/DAInit.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/DoubleAuction/DAModel.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/SIRS/SIRSRun.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/SIRS/SIRSInit.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/Wildfire/WildfireRun.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/SIRS/SIRSModel.hs",
		"/home/jonathan/phd/coding/libraries/frABS/frABS.cabal",
		"/home/jonathan/phd/coding/libraries/frABS/src/FrABS/Simulation/Simulation.hs",
		"/home/jonathan/phd/coding/libraries/frABS/src/FrABS/Simulation/SeqIteration.hs",
		"/home/jonathan/phd/coding/libraries/frABS/src/FrABS/Simulation/ParIteration.hs",
		"/home/jonathan/phd/coding/libraries/frABS/src/FrABS/Simulation/Utils.hs",
		"/home/jonathan/phd/coding/libraries/frABS/src/FrABS/Env/Environment.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/SugarScape/SugarScapeInit.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/Wildfire/WildfireInit.hs",
		"/home/jonathan/phd/coding/libraries/frABS/src/FrABS/FrABS.hs",
		"/home/jonathan/phd/coding/libraries/frABS/src/FrABS/Utils.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/Segregation/SegregationRun.hs",
		"/home/jonathan/phd/coding/libraries/frABS/src/FrABS/Rendering/GlossSimulator.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/AgentZero/AgentZeroRun.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/PrisonersDilemma/PDRun.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/SugarScape/SugarScapeRun.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/Segregation/SegregationModel.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/Segregation/SegregationStats.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/Segregation/SegregationInit.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/Segregation/SegregationRenderer.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/Conversation/ConversationRun.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/RecursiveABS/RecursiveABSRun.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/SIRS/SIRSRenderer.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/AgentZero/AgentZeroRenderer.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/SugarScape/SugarScapeRenderer.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/Main.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/PrisonersDilemma/PDRenderer.hs",
		"/home/jonathan/phd/coding/libraries/frABS/src/FrABS/Simulation/SimulationUtils.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/Wildfire/WildfireRenderer.hs",
		"/home/jonathan/phd/coding/libraries/frABS/src/FrABS/Rendering/Agents2DDiscrete.hs",
		"/home/jonathan/phd/coding/libraries/frABS/src/FrABS/Simulation/SimulationHelper.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/SIRS/RunSIRS.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/PrisonersDilemma/PDModel.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/PrisonersDilemma/PDInit.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/Wildfire/WildfireModel.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/    Saw",
		"/home/jonathan/phd/coding/libraries/frABS/examples/Wildfire/WildfireEnvironment.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/Wildfire/WilidfireRun.hs",
		"/home/jonathan/ethereum/ethaskell/src/Rpc/Server.hs",
		"/home/jonathan/ethereum/ethaskell/src/Rpc/Methods.hs",
		"/home/jonathan/ethereum/ethaskell/src/Rpc/CURL_TEST.txt",
		"/home/jonathan/ethereum/ethaskell/ETHaskell.cabal",
		"/C/Users/Jonathan Thaler/coding/ethaskell/src/Rpc/Utils.hs",
		"/C/Users/Jonathan Thaler/coding/ethaskell/src/Rpc/CURL_TEST.txt",
		"/C/Users/Jonathan Thaler/coding/ethaskell/src/p2p/Server.hs",
		"/C/Users/Jonathan Thaler/coding/ethaskell/src/Rpc/Server.hs",
		"/C/Users/Jonathan Thaler/coding/ethaskell/src/p2p/P2P.hs",
		"/C/Users/Jonathan Thaler/coding/ethaskell/src/Rpc/Methods.hs",
		"/C/Users/Jonathan Thaler/coding/ethaskell/src/Rpc/Json.hs",
		"/C/Users/Jonathan Thaler/coding/ethaskell/src/Rpc/JsonRpc.hs",
		"/C/Users/Jonathan Thaler/coding/ethaskell/src/    Variable not in scope",
		"/C/Users/Jonathan Thaler/coding/ethaskell/src/EthJsonRpc/Utils.hs",
		"/C/Users/Jonathan Thaler/coding/ethaskell/src/EthJsonRpc/Methods.hs",
		"/C/Users/Jonathan Thaler/coding/ethaskell/ETHaskell.cabal",
		"/C/Users/Jonathan Thaler/coding/ethaskell/src/    Parse error in pattern",
		"/C/Users/Jonathan Thaler/coding/ethaskell/src/EthJsonRpc/JsonRpc.hs",
		"/C/Users/Jonathan Thaler/coding/ethaskell/src/EthJsonRpc/Server.hs",
		"/C/Users/Jonathan Thaler/coding/ethaskell/src/                             imported from `Prelude' at EthJsonRpc/Server.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/examples/DoubleAuction/DAModel.hs",
		"/C/Users/Jonathan Thaler/coding/ethaskell/src/Devp2p/Devp2p.hs",
		"/C/Users/Jonathan Thaler/coding/ethaskell/src/jsonrpc/JSONRpc.hs",
		"/C/Users/Jonathan Thaler/coding/ethaskell/src/EthJsonRpc/EthJsonRpc.hs",
		"/C/Users/Jonathan Thaler/coding/ethaskell/TODO.txt",
		"/C/Users/Jonathan Thaler/coding/ethaskell/src/Main.hs",
		"/C/Users/Jonathan Thaler/coding/ETHaskell/ETHaskell.cabal",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/examples/Main.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/FrABS/Simulation/Simulation.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/examples/AgentZero/AgentZeroRun.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/examples/DoubleAuction/DARun.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/examples/SugarScape/SugarScapeRun.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/examples/Agent 1",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/examples/received AskOfferings from 1",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/examples/received AskOfferings from 2",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/examples/Agent received BidOfferings from 1",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/FrABS/Agent/Agent.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/examples/DoubleAuction/DAAuctioneer.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/examples/AgentZero/AgentZeroAgent.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/examples/SIRS/SIRSModel.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/examples/SugarScape/SugarScapeAgent.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/examples/DoubleAuction/DATrader.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/FrABS/Simulation/ParIteration.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/Main.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/Segregation/SegregationModel.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/Segregation/SegregationRun.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/RecursiveABS/RecursiveABSModel.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/RecursiveABS/RecursiveABSInit.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/SugarScape/SugarScapeModel.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/SugarScape/SugarScapeAgent.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/Conversation/ConversationModel.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/SIRS/SIRSModel.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/Segregation/SegregationInit.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/MetaABS/MetaABSModel.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/MetaABS/MetaABSInit.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/Conversation/ConversationInit.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/MessageSampling/MessageSamplingInit.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/MessageSampling/MessageSamplingModel.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/    Not in scope",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/FrABS/Env/Environment.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/SugarScape/SugarScapeInit.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/    * Variable not in scope",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/    Variable not in scope",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/SugarScape/SugarScapeRun.hs"
	],
	"find":
	{
		"height": 34.0
	},
	"find_in_files":
	{
		"height": 90.0,
		"where_history":
		[
			"C:\\Users\\Jonathan Thaler\\phd\\coding\\libraries\\frABS\\src,*.hs"
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"ifThenElse",
			"ifThenElse\n",
			"cellOccupied",
			"createAgent",
			"dieFromAge\n",
			"unoccupyPosition",
			"ifelsem",
			"cellAt",
			"neighboursDistanceM",
			"selectBestCells",
			"agentWelfareChange",
			"agentPickRandomM",
			"agentPoluteCell",
			"ifelsem",
			"when",
			"neighbourNodes",
			"foldM",
			"agentCell",
			"unoccu",
			"sirsAgentBehaviourFuncM",
			"onmessage",
			"todo",
			"updatedomainStateFieldM",
			"domainStateM",
			"updateStateM",
			"PDAgentOut",
			"updateState",
			"onMessage",
			"sirsAgentBehaviourFuncM",
			"burndown",
			"sirsCoord",
			"hasmess",
			"drawBoolWithProbFromAgent",
			"runSeqSF",
			"runSeqInternal",
			"internal",
			"calculate",
			"distance",
			"cellsAround",
			"renderCircles",
			"renderFrame",
			"dt ",
			"nvironment",
			"WildfireEnvironment",
			"WildfireAgentOut",
			"WildfireAgentIn",
			"WildfireAgentDef",
			"sirsAgentBehaviourFuncM",
			"WildfireAgentState",
			"WildfireAgentIn",
			"WildfireAgentOut",
			"WildfireEnvironment",
			"WildfireMsg",
			"WildfireLinkLabel",
			"WildfireCell",
			"kill",
			"AgentZeroAgentOut",
			"AgentZeroAgentIn",
			"AgentZeroEnvironment",
			"extractParam",
			"decodeUnformattedData",
			"alphaNumToHex",
			"-------------------------------------------------------------------------------------------",
			"contactInfected",
			"onMessage",
			"randomCellWithRadius",
			"runrandom",
			"rand",
			"random",
			"agentNonCombatMove",
			"inheritSugar",
			"agentCultureContact",
			"agentSex",
			"polute",
			"agentPoluteCell",
			"unoccupyPosition",
			"agentCell",
			"agentPolutingCell",
			"moveAndHarvestBestCell",
			"agentStayAndHarvest",
			"agentMetabolism",
			"agentLookout",
			"combatReward",
			"unoccupyPosition",
			"agentAgeing",
			"unoccupyPosition",
			"agentAgeing",
			"agentAction",
			"agentMoveAndHarvestCell",
			"agentPickRandom",
			"selectBestCells",
			"refCoord",
			"selectBestCells",
			"randomAgentIO",
			"cellOccupier",
			"SugarScapeAgentState",
			"createCells",
			"SugarScapeEnvCellOccupier",
			"cellOccupier",
			"filter",
			"filter (",
			"cellUnoccupied",
			"agentLookout",
			"agentCollecting",
			"cellUnoccupied",
			"agentLookout",
			"^(.*)$",
			"neighbourIds",
			"replace",
			"randomage",
			"handleCreateAgents",
			"handleKillOrLiveAgent",
			"handleAgent",
			"createAgent",
			"handleCreateAgents",
			"#",
			"handleCreateAgents"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": true,
		"replace_history":
		[
			"agentCellOnPos",
			"updateDomainStateM",
			"domainStateFieldM",
			"updateDomainStateM",
			"updateDomainState",
			"distanceManhattan",
			"Environment",
			"nvironment ec l ",
			"AgentOut s m ec l",
			"AgentIn s m ec l",
			"AgentDef s m ec l",
			"PDAgentState",
			"PDAgentIn",
			"PDAgentOut",
			"PDEnvironment",
			"PDMsg",
			"PDLinkLabel",
			"PDCell",
			"WildfireAgentOut",
			"WildfireAgentIn",
			"WildfireEnvironment",
			"hexLitToInt",
			"-------------------------------------------------------------------------------"
		],
		"reverse": false,
		"show_context": false,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 1,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "examples/Main.hs",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 839,
						"regions":
						{
						},
						"selection":
						[
							[
								548,
								548
							]
						],
						"settings":
						{
							"syntax": "Packages/SublimeHaskell/Syntaxes/Haskell-SublimeHaskell.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "examples/SugarScape/SugarScapeAgent.hs",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 53041,
						"regions":
						{
						},
						"selection":
						[
							[
								50232,
								50232
							]
						],
						"settings":
						{
							"syntax": "Packages/Haskell/Haskell.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 15661.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "src/FrABS/Agent/Agent.hs",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 15338,
						"regions":
						{
						},
						"selection":
						[
							[
								630,
								630
							]
						],
						"settings":
						{
							"syntax": "Packages/SublimeHaskell/Syntaxes/Haskell-SublimeHaskell.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "src/FrABS/Env/Environment.hs",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 10971,
						"regions":
						{
						},
						"selection":
						[
							[
								6923,
								6923
							]
						],
						"settings":
						{
							"syntax": "Packages/SublimeHaskell/Syntaxes/Haskell-SublimeHaskell.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2753.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 23.0
	},
	"input":
	{
		"height": 34.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.exec":
	{
		"height": 273.0
	},
	"output.find_results":
	{
		"height": 0.0
	},
	"output.sublime_haskell_error_panel":
	{
		"height": 118.0
	},
	"output.sublime_haskell_output_panel":
	{
		"height": 245.0
	},
	"pinned_build_system": "Packages/Haskell/Haskell.sublime-build",
	"project": "frabs.sublime-project",
	"replace":
	{
		"height": 62.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 250.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
