{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"igni",
				"ignitionEvent"
			],
			[
				"init",
				"initIgnite"
			],
			[
				"extractParamFrom",
				"extractParamFromVector ∷ Value → Int → Maybe Value\tRpc.Utils"
			],
			[
				"exc",
				"extractParam ∷ Value → Int → Text → Maybe Value\tRpc.Utils"
			],
			[
				"encod",
				"encodeQuantity ∷ Int → String\tRpc.Utils"
			],
			[
				"JsonRpcRe",
				"JsonRpcResponse \tEthJsonRpc.Methods"
			],
			[
				"server",
				"serverLoop"
			],
			[
				"et",
				"ethJsonRpcPort"
			],
			[
				"SockA",
				"SockAddrInet"
			],
			[
				"receivi",
				"receivingIdx"
			],
			[
				"rece",
				"receivingIn"
			],
			[
				"may",
				"mayIdx"
			],
			[
				"handleCon",
				"handleConversationAux"
			],
			[
				"mayb",
				"maybeFunc1"
			],
			[
				"SugarScapeC",
				"SugarScapeEnvCell \tSugarScape.SugarScapeModel"
			],
			[
				"sugEnv",
				"sugEnvSugarLevel ∷ SugarScapeEnvCell → Double\tSugarScape.SugarScapeModel"
			],
			[
				"sugAgSug",
				"sugAgSugarLevel ∷ SugarScapeAgentState → Double\tSugarScape.SugarScapeModel"
			],
			[
				"Cultur",
				"SugarScapeCulturalTag \tSugarScape.SugarScapeModel"
			]
		]
	},
	"buffers":
	[
		{
			"contents": "module FrABS.Agent.Agent (\n    AgentId,\n    AgentMessage,\n    AgentBehaviour,\n\n    AgentConversationReply,\n    AgentConversationReceiver,\n    AgentConversationSender,\n    \n    AgentDef (..),\n    AgentIn (..),\n    AgentOut (..),\n\n    runAgentRandom,\n    runAgentRandomM,\n    \n    drawRandomRangeFromAgent,\n    drawMultipleRandomRangeFromAgent,\n    drawBoolWithProbFromAgent,\n    drawBoolWithProbFromAgentM,\n    splitRandomFromAgent,\n    agentPickRandom,\n    agentPickRandomM,\n    agentPickRandomMultiple,\n    agentPickRandomMultipleM,\n    drawRandomBool,\n\n    agentIdM,\n    environmentM,\n    environmentPositionM,\n    changeEnvironmentPositionM,\n\n    createAgent,\n    createAgentM,\n    kill,\n    killM,\n    isDead,\n    isDeadM,\n\n    createStartingAgentIn,\n    agentOutFromIn,\n    startingAgentInFromAgentDef,\n\n    sendMessage,\n    sendMessageM,\n    sendMessages,\n    sendMessagesM,\n    broadcastMessage,\n    broadcastMessageM,\n    hasMessage,\n    onMessage,\n    onMessageM,\n    onMessageMState,\n    onFilterMessage,\n    onMessageFrom,\n    onMessageType,\n\n    hasConversation,\n    conversation,\n    conversationM,\n    conversationEnd,\n    conversationEndM,\n    conversationReplyMonadicRunner,\n    conversationIgnoreReplyMonadicRunner,\n\n    updateDomainState,\n    updateDomainStateM,\n    getDomainStateM,\n    setDomainState,\n    setDomainStateM,\n    domainStateFieldM,\n\n    runEnvironmentM,\n\n    onStart,\n    onEvent,\n\n    recInitAllowed,\n    allowsRecOthers,\n    recursive,\n    unrecursive,\n    isRecursive,\n\n    mergeMessages\n  ) where\n\nimport FrABS.Env.Environment\n\nimport FRP.Yampa\n\nimport System.Random\n\nimport Control.Monad\nimport Control.Monad.Random\nimport Control.Monad.Trans.State\n\nimport Data.List\n\ntype AgentId = Int\ntype AgentMessage m = (AgentId, m)\ntype AgentBehaviour s m ec l = SF (AgentIn s m ec l) (AgentOut s m ec l)\ntype MessageFilter m = (AgentMessage m -> Bool)\n\ntype AgentConversationReply s m ec l = Maybe (m, AgentIn s m ec l)\n\ntype AgentConversationReceiver s m ec l = (AgentIn s m ec l\n                                            -> AgentMessage m\n                                            -> AgentConversationReply s m ec l) -- NOTE: the receiver MUST reply, otherwise we could've used the normal messaging\n\ntype AgentConversationSender s m ec l = (AgentOut s m ec l\n                                        -> Maybe (AgentMessage m)   -- NOTE: this will be Nothing in case the conversation with the target was not established e.g. id not found, target got no receiving handler\n                                        -> AgentOut s m ec l)\n\ndata AgentDef s m ec l = AgentDef {\n    adId :: AgentId,\n    adState :: s,\n    adBeh :: AgentBehaviour s m ec l,\n    adConversation :: Maybe (AgentConversationReceiver s m ec l),\n    adInitMessages :: Event [AgentMessage m],     -- AgentId identifies sender\n    adEnvPos :: EnvCoord,\n    adRng :: StdGen\n}\n\ndata AgentIn s m ec l = AgentIn {\n    aiId :: AgentId,\n    aiMessages :: Event [AgentMessage m],     -- AgentId identifies sender\n    aiConversation :: Maybe (AgentConversationReceiver s m ec l),\n    aiStart :: Event (),\n    aiState :: s,\n    aiEnv :: Environment ec l,\n    aiEnvPos :: EnvCoord,\n    aiRec :: Event [AgentOut s m ec l],\n    aiRecInitAllowed :: Bool,\n    aiRng :: StdGen\n}\n\ndata AgentOut s m ec l = AgentOut {\n    aoId :: AgentId,\n    aoKill :: Event (),\n    aoCreate :: Event [AgentDef s m ec l],\n    aoMessages :: Event [AgentMessage m],     -- AgentId identifies receiver\n    aoConversation :: Event (AgentMessage m, AgentConversationSender s m ec l),\n    aoState :: s,\n    aoEnv :: Environment ec l,\n    aoEnvPos :: EnvCoord,\n    aoRec :: Event (),\n    aoRecOthersAllowed :: Bool,\n    aoRng :: StdGen\n}\n\n------------------------------------------------------------------------------------------------------------------------\n-- Agent Functions\n------------------------------------------------------------------------------------------------------------------------\nagentIdM :: State (AgentOut s m ec l) AgentId\nagentIdM = state (\\ao -> (aoId ao, ao))\n\nenvironmentM :: State (AgentOut s m ec l) (Environment ec l)\nenvironmentM = state (\\ao -> (aoEnv ao, ao))\n\nenvironmentPositionM :: State (AgentOut s m ec l) EnvCoord\nenvironmentPositionM = state (\\ao -> (aoEnvPos ao, ao))\n\nchangeEnvironmentPositionM :: EnvCoord -> State (AgentOut s m ec l) ()\nchangeEnvironmentPositionM pos = state (\\ao -> ((), ao { aoEnvPos = pos }))\n\n-- NOTE: beware of a = AgentOut (randomly manipulating AgentOut) because one will end up with 2 versions of AgentOut which need to be merged\nrunAgentRandom :: AgentOut s m ec l -> Rand StdGen a -> (a, AgentOut s m ec l)\nrunAgentRandom a f = (ret, a')\n    where\n        g = aoRng a\n        (ret, g') = runRand f g\n        a' = a {aoRng = g'}\n\nrunAgentRandomM :: Rand StdGen a -> State (AgentOut s m ec l) a\nrunAgentRandomM f = state (runAgentRandomMAux f)\n    where\n        runAgentRandomMAux :: Rand StdGen a -> AgentOut s m ec l -> (a, AgentOut s m ec l)\n        runAgentRandomMAux f ao = runAgentRandom ao f\n\ndrawRandomRangeFromAgent :: (Random a) => AgentOut s m ec l -> (a, a) -> (a, AgentOut s m ec l)\ndrawRandomRangeFromAgent a r = runAgentRandom a (getRandomR r)\n\ndrawRandomBool :: Double -> Rand StdGen Bool\ndrawRandomBool p =\n    do\n        r <- getRandomR (0.0, p) \n        return $ p >= r\n\ndrawMultipleRandomRangeFromAgent :: (Random a) => AgentOut s m ec l -> (a, a) -> Int -> ([a], AgentOut s m ec l)\ndrawMultipleRandomRangeFromAgent a r n = runAgentRandom a blub\n    where\n        blub = do\n                infRand <- getRandomRs r\n                let nRand = take n infRand\n                return nRand\n\ndrawBoolWithProbFromAgent :: AgentOut s m ec l -> Double -> (Bool, AgentOut s m ec l)\ndrawBoolWithProbFromAgent ao trueProb = (trueFlag, ao')\n    where\n        (randTrue, ao') = drawRandomRangeFromAgent ao (0.0, 1.0)\n        trueFlag = randTrue <= trueProb\n\ndrawBoolWithProbFromAgentM :: Double -> State (AgentOut s m ec l) Bool\ndrawBoolWithProbFromAgentM p = state drawBoolWithProbFromAgentMAux \n    where\n        drawBoolWithProbFromAgentMAux :: (AgentOut s m ec l) -> (Bool, AgentOut s m ec l)\n        drawBoolWithProbFromAgentMAux ao = drawBoolWithProbFromAgent ao p\n\nsplitRandomFromAgent :: AgentOut s m ec l -> (StdGen, AgentOut s m ec l)\nsplitRandomFromAgent a = runAgentRandom a getSplit\n\nagentPickRandom :: AgentOut s m ec l -> [a] -> (a, AgentOut s m ec l)\nagentPickRandom a xs\n    | null xs = error \"cannot draw single random element from empty list\"\n    | otherwise = (randElem, a')\n    where\n        cellCount = length xs\n        (randIdx, a') = drawRandomRangeFromAgent a (0, cellCount - 1)\n        randElem = xs !! randIdx\n\nagentPickRandomM :: [a] -> State (AgentOut s m ec l) a\nagentPickRandomM xs = state (\\ao -> agentPickRandom ao xs)\n\nagentPickRandomMultiple :: AgentOut s m ec l -> [a] -> Int -> ([a], AgentOut s m ec l)\nagentPickRandomMultiple a xs n\n    | null xs = error \"cannot draw multiple random elements from empty list\"\n    | otherwise = (randElems, a')\n    where\n        cellCount = length xs\n        (randIndices, a') = drawMultipleRandomRangeFromAgent a (0, cellCount - 1) n\n        randElems = foldr (\\idx acc -> (xs !! idx) : acc) [] randIndices  \n\nagentPickRandomMultipleM :: [a] -> Int -> State (AgentOut s m ec l) [a]\nagentPickRandomMultipleM xs n = state (\\ao -> agentPickRandomMultiple ao xs n)\n\nrecInitAllowed :: AgentIn s m ec l -> Bool\nrecInitAllowed = aiRecInitAllowed\n\nagentOutFromIn :: AgentIn s m ec l -> AgentOut s m ec l\nagentOutFromIn ai = AgentOut{ aoId = aiId ai,\n                              aoKill = NoEvent,\n                              aoCreate = NoEvent,\n                              aoMessages = NoEvent,\n                              aoConversation = NoEvent,\n                              aoState = aiState ai,\n                              aoEnv = aiEnv ai,\n                              aoRec = NoEvent,\n                              aoEnvPos = aiEnvPos ai,\n                              aoRecOthersAllowed = True,\n                              aoRng = aiRng ai }\n\nsendMessage :: AgentOut s m ec l -> AgentMessage m -> AgentOut s m ec l\nsendMessage ao msg = ao { aoMessages = mergedMsgs }\n    where\n        newMsgEvent = Event [msg]\n        existingMsgEvent = aoMessages ao\n        mergedMsgs = mergeMessages existingMsgEvent newMsgEvent\n\nsendMessageM :: AgentMessage m -> State (AgentOut s m ec l) ()\nsendMessageM msg = state (\\ao -> ((), sendMessage ao msg))\n\nhasConversation :: AgentOut s m ec l -> Bool\nhasConversation = isEvent . aoConversation\n\nconversation :: AgentOut s m ec l\n                -> AgentMessage m\n                -> AgentConversationSender s m ec l\n                -> AgentOut s m ec l\nconversation ao msg replyHdl = ao { aoConversation = Event (msg, replyHdl)}\n\nconversationM :: AgentMessage m\n                -> AgentConversationSender s m ec l\n                -> State (AgentOut s m ec l) ()\nconversationM msg replyHdl = state (\\ao -> ((), conversation ao msg replyHdl))\n\nconversationEnd :: AgentOut s m ec l -> AgentOut s m ec l\nconversationEnd ao = ao { aoConversation = NoEvent }\n\nconversationEndM :: State (AgentOut s m ec l) ()\nconversationEndM = state (\\ao -> ((), conversationEnd ao))\n\nconversationReplyMonadicRunner :: (Maybe (AgentMessage m) -> State (AgentOut s m ec l) ()) \n                                    -> AgentConversationSender s m ec l\nconversationReplyMonadicRunner replyAction ao mayReply = execState (replyAction mayReply) ao\n\nconversationIgnoreReplyMonadicRunner :: State (AgentOut s m ec l) () -> AgentConversationSender s m ec l\nconversationIgnoreReplyMonadicRunner replyAction ao _ = execState replyAction ao\n\nsendMessages :: AgentOut s m ec l -> [AgentMessage m] -> AgentOut s m ec l\nsendMessages ao msgs = foldr (\\msg ao' -> sendMessage ao' msg ) ao msgs\n\nsendMessagesM :: [AgentMessage m] -> State (AgentOut s m ec l) ()\nsendMessagesM msgs = state (\\ao -> ((), sendMessages ao msgs))\n\nbroadcastMessage :: AgentOut s m ec l -> m -> [AgentId] -> AgentOut s m ec l\nbroadcastMessage ao m receiverIds = sendMessages ao msgs\n    where\n        n = length receiverIds\n        ms = replicate n m\n        msgs = zip receiverIds ms\n\nbroadcastMessageM :: m -> [AgentId] -> State (AgentOut s m ec l) ()\nbroadcastMessageM m receiverIds = state (broadcastMessageMAux m)\n    where\n        broadcastMessageMAux :: m -> AgentOut s m ec l -> ((), AgentOut s m ec l)\n        broadcastMessageMAux m ao = ((), sendMessages ao msgs)\n            where\n                n = length receiverIds\n                ms = replicate n m\n                msgs = zip receiverIds ms\n\ncreateAgent :: AgentOut s m ec l -> AgentDef s m ec l -> AgentOut s m ec l\ncreateAgent ao newDef = ao { aoCreate = createEvt }\n    where\n        oldCreateEvt = aoCreate ao\n        createEvt = mergeBy (\\leftCreate rightCreate -> leftCreate ++ rightCreate) (Event [newDef]) oldCreateEvt\n\ncreateAgentM :: AgentDef s m ec l -> State (AgentOut s m ec l) ()\ncreateAgentM newDef = state (\\ao -> ((),createAgent ao newDef))\n\nkill :: AgentOut s m ec l -> AgentOut s m ec l\nkill ao = ao { aoKill = Event () }\n\nkillM :: State (AgentOut s m ec l) ()\nkillM = state (\\ao -> ((), ao { aoKill = Event () }))\n\nisDead :: AgentOut s m ec l -> Bool\nisDead = isEvent . aoKill\n\nisDeadM :: State (AgentOut s m ec l) Bool\nisDeadM = state (\\ao -> (isDead ao, ao))\n\nonStart :: AgentIn s m ec l -> (AgentOut s m ec l -> AgentOut s m ec l) -> AgentOut s m ec l -> AgentOut s m ec l\nonStart ai evtHdl ao = onEvent startEvt evtHdl ao\n    where\n        startEvt = aiStart ai\n\nonEvent :: Event () -> (AgentOut s m ec l -> AgentOut s m ec l) -> AgentOut s m ec l -> AgentOut s m ec l\nonEvent evt evtHdl ao = if isEvent evt then\n                            evtHdl ao\n                            else\n                                ao\n    \nhasMessage :: (Eq m) => AgentIn s m ec l -> m -> Bool\nhasMessage ai m\n    | not hasAnyMessage = False\n    | otherwise = hasMsg\n    where\n        msgsEvt = aiMessages ai\n        hasAnyMessage = isEvent msgsEvt\n        msgs = fromEvent msgsEvt\n        hasMsg = Data.List.any ((==m) . snd) msgs\n\nonMessage :: AgentIn s m ec l -> (acc -> AgentMessage m -> acc) -> acc -> acc\nonMessage ai msgHdl a \n    | not hasMessages = a\n    | otherwise = foldr (\\msg acc'-> msgHdl acc' msg ) a msgs\n    where\n        msgsEvt = aiMessages ai\n        hasMessages = isEvent msgsEvt\n        msgs = fromEvent msgsEvt\n\nonMessageMState :: AgentIn s m ec l -> (AgentMessage m -> State acc ()) -> State acc ()\nonMessageMState ai msgHdl = onMessageM ai (\\_ msg -> msgHdl msg) ()\n\nonMessageM :: (Monad mon) => AgentIn s m ec l -> (acc -> AgentMessage m -> mon acc) -> acc -> mon acc\nonMessageM ai msgHdl acc\n    | not hasMessages = return acc\n    -- | otherwise = foldM (\\acc msg -> msgHdl acc msg) acc msgs\n    | otherwise = foldM msgHdl acc msgs\n    where\n        msgsEvt = aiMessages ai\n        hasMessages = isEvent msgsEvt\n        msgs = fromEvent msgsEvt\n\nonFilterMessage :: MessageFilter m -> AgentIn s m ec l -> (acc -> AgentMessage m -> acc) -> acc -> acc\nonFilterMessage msgFilter ai msgHdl acc\n    | not hasMessages = acc\n    | otherwise = foldr (\\msg acc'-> msgHdl acc' msg ) acc filteredMsgs\n    where\n        msgsEvt = aiMessages ai\n        hasMessages = isEvent msgsEvt\n        msgs = fromEvent msgsEvt\n        filteredMsgs = filter msgFilter msgs\n\nonMessageFrom :: AgentId -> AgentIn s m ec l -> (acc -> AgentMessage m -> acc) -> acc -> acc\nonMessageFrom senderId ai msgHdl acc = onFilterMessage filterBySender ai msgHdl acc\n    where\n        filterBySender = (\\(senderId', _) -> senderId == senderId' )\n\nonMessageType :: (Eq m) => m -> AgentIn s m ec l -> (acc -> AgentMessage m -> acc) -> acc -> acc\nonMessageType m ai msgHdl acc = onFilterMessage filterByMsgType ai msgHdl acc\n    where\n        filterByMsgType = ((==m) . snd) --(\\(_, m') -> m == m' )\n\nupdateDomainState :: AgentOut s m ec l -> (s -> s) -> AgentOut s m ec l\nupdateDomainState ao sfunc = ao { aoState = s' }\n    where\n        s = aoState ao\n        s' = sfunc s\n    \nupdateDomainStateM :: (s -> s) -> State (AgentOut s m ec l) ()\nupdateDomainStateM sfunc = state (updateDomainStateMAux sfunc)\n    where\n        updateDomainStateMAux :: (s -> s) \n                            -> AgentOut s m ec l \n                            -> ((), AgentOut s m ec l)\n        updateDomainStateMAux sfunc ao = ((), updateDomainState ao sfunc)\n\nsetDomainState :: AgentOut s m ec l -> s -> AgentOut s m ec l\nsetDomainState ao s = updateDomainState ao (\\_ -> s)\n\nsetDomainStateM :: s -> State (AgentOut s m ec l) ()\nsetDomainStateM s = state (\\ao -> ((), setDomainState ao s))\n\ndomainStateFieldM :: (s -> t) -> State (AgentOut s m ec l) t\ndomainStateFieldM f = state (domainStateFieldMAux f)\n    where\n        domainStateFieldMAux :: (s -> t) \n                            -> AgentOut s m ec l\n                            -> (t, AgentOut s m ec l)\n        domainStateFieldMAux f ao = (f s, ao)\n            where\n                s = aoState ao\n\nrunEnvironmentM :: State (Environment ec l) a -> State (AgentOut s m ec l) a\nrunEnvironmentM envStateTrans =\n    do\n        env <- environmentM \n        let (a, env') = runState envStateTrans env\n        setEnvironmentM env'\n        return a\n\nsetEnvironmentM :: Environment ec l -> State (AgentOut s m ec l) ()\nsetEnvironmentM env =\n    do\n        ao <- get \n        put $ ao { aoEnv = env }\n\ngetDomainStateM :: State (AgentOut s m ec l) s\ngetDomainStateM = \n    do\n        ao <- get\n        let domainState = aoState ao \n        return domainState\n\nallowsRecOthers :: AgentOut s m ec l -> Bool\nallowsRecOthers = aoRecOthersAllowed\n\nrecursive :: AgentOut s m ec l -> Bool -> AgentOut s m ec l\nrecursive aout allowOthers = aout { aoRec = Event (), aoRecOthersAllowed = allowOthers }\n\nunrecursive :: AgentOut s m ec l -> AgentOut s m ec l\nunrecursive aout = aout { aoRec = NoEvent }\n\nisRecursive :: AgentIn s m ec l -> Bool\nisRecursive ain = isEvent $ aiRec ain\n\ncreateStartingAgentIn :: [AgentDef s m ec l] -> Environment ec l -> [AgentIn s m ec l]\ncreateStartingAgentIn as env = map (startingAgentInFromAgentDef env) as\n\nstartingAgentInFromAgentDef :: Environment ec l -> AgentDef s m ec l -> AgentIn s m ec l\nstartingAgentInFromAgentDef env ad = AgentIn { aiId = adId ad,\n                                                aiMessages = adInitMessages ad,\n                                                aiConversation = adConversation ad,\n                                                aiStart = Event (),\n                                                aiState = adState ad,\n                                                aiEnv = env,\n                                                aiEnvPos = adEnvPos ad,\n                                                aiRec = NoEvent,\n                                                aiRecInitAllowed = True,\n                                                aiRng = adRng ad }\n\nmergeMessages :: Event [AgentMessage m] -> Event [AgentMessage m] -> Event [AgentMessage m]\nmergeMessages l r = mergeBy (\\msgsLeft msgsRight -> msgsLeft ++ msgsRight) l r",
			"file": "src/FrABS/Agent/Agent.hs",
			"file_size": 17070,
			"file_write_time": 131433316694942424,
			"settings":
			{
				"buffer_size": 17070,
				"line_ending": "Unix"
			}
		}
	],
	"build_system": "",
	"build_system_choices":
	[
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 92.0,
		"last_filter": "Package Control: insta",
		"selected_items":
		[
			[
				"Package Control: insta",
				"Package Control: Install Package"
			],
			[
				"Package Control: install",
				"Package Control: Install Package"
			],
			[
				"install",
				"Package Control: Install Package"
			]
		],
		"width": 485.0
	},
	"console":
	{
		"height": 289.0,
		"history":
		[
			"import urllib.request,os,hashlib; h = 'df21e130d211cfc94d9b0905775a7c0f' + '1e3d39e33b79698005270310898eea76'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by) ",
			"import urllib.request,os; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), 'wb').write(urllib.request.urlopen( 'http://sublime.wbond.net/' + pf.replace(' ','%20')).read())"
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/home/jonathan/phd/coding/libraries/frABS",
		"/home/jonathan/phd/coding/libraries/frABS/examples",
		"/home/jonathan/phd/coding/libraries/frABS/src",
		"/home/jonathan/phd/coding/libraries/frABS/src/FrABS",
		"/home/jonathan/phd/coding/libraries/frABS/src/FrABS/Agent",
		"/home/jonathan/phd/coding/libraries/frABS/src/FrABS/Simulation"
	],
	"file_history":
	[
		"/home/jonathan/Main.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/Main.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/FrSIRS/FrSIRSRun.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/FrSIRS/FrSIRSAgent.hs",
		"/home/jonathan/phd/coding/libraries/frABS/src/FrABS/Rendering/GlossSimulator.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/SIRS/SIRSRenderer.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/FrSIRS/FrSIRSRenderer.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/SugarScape/SugarScapeAgentMonadic.hs",
		"/home/jonathan/phd/coding/libraries/frABS/src/FrABS/Agent/Agent.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/SugarScape/SugarScapeAgent.hs",
		"/home/jonathan/phd/coding/libraries/frABS/src/FrABS/Env/Environment.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/AgentZero/AgentZeroAgent.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/Utils/Utils.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/frABSExamples.cabal",
		"/home/jonathan/phd/coding/libraries/frABS/src/FrABS/Agent/AgentUtils.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/SIRS/SIRSAgent.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/SugarScape/SugarScapeAgentM.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/SugarScape/SugarScapeEnvironmentM.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/AgentZero/AgentZeroEnvironment.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/        Actual type",
		"/home/jonathan/phd/coding/libraries/frABS/examples/DoubleAuction/DATrader.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/PrisonersDilemma/PDAgent.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/Conversation/ConversationModel.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/DoubleAuction/DAAuctioneer.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/RecursiveABS/RecursiveABSModel.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/Segregation/SegregationAgent.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/Wildfire/WildfireAgent.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/DoubleAuction/DARun.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/DoubleAuction/DAInit.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/DoubleAuction/DAModel.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/SIRS/SIRSRun.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/SIRS/SIRSInit.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/Wildfire/WildfireRun.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/SIRS/SIRSModel.hs",
		"/home/jonathan/phd/coding/libraries/frABS/frABS.cabal",
		"/home/jonathan/phd/coding/libraries/frABS/src/FrABS/Simulation/Simulation.hs",
		"/home/jonathan/phd/coding/libraries/frABS/src/FrABS/Simulation/SeqIteration.hs",
		"/home/jonathan/phd/coding/libraries/frABS/src/FrABS/Simulation/ParIteration.hs",
		"/home/jonathan/phd/coding/libraries/frABS/src/FrABS/Simulation/Utils.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/SugarScape/SugarScapeInit.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/Wildfire/WildfireInit.hs",
		"/home/jonathan/phd/coding/libraries/frABS/src/FrABS/FrABS.hs",
		"/home/jonathan/phd/coding/libraries/frABS/src/FrABS/Utils.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/Segregation/SegregationRun.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/AgentZero/AgentZeroRun.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/PrisonersDilemma/PDRun.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/SugarScape/SugarScapeRun.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/Segregation/SegregationModel.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/Segregation/SegregationStats.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/Segregation/SegregationInit.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/Segregation/SegregationRenderer.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/Conversation/ConversationRun.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/RecursiveABS/RecursiveABSRun.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/AgentZero/AgentZeroRenderer.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/SugarScape/SugarScapeRenderer.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/PrisonersDilemma/PDRenderer.hs",
		"/home/jonathan/phd/coding/libraries/frABS/src/FrABS/Simulation/SimulationUtils.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/Wildfire/WildfireRenderer.hs",
		"/home/jonathan/phd/coding/libraries/frABS/src/FrABS/Rendering/Agents2DDiscrete.hs",
		"/home/jonathan/phd/coding/libraries/frABS/src/FrABS/Simulation/SimulationHelper.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/SugarScape/SugarScapeModel.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/SIRS/RunSIRS.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/PrisonersDilemma/PDModel.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/PrisonersDilemma/PDInit.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/Wildfire/WildfireModel.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/    Saw",
		"/home/jonathan/phd/coding/libraries/frABS/examples/Wildfire/WildfireEnvironment.hs",
		"/home/jonathan/phd/coding/libraries/frABS/examples/Wildfire/WilidfireRun.hs",
		"/home/jonathan/ethereum/ethaskell/src/Rpc/Server.hs",
		"/home/jonathan/ethereum/ethaskell/src/Rpc/Methods.hs",
		"/home/jonathan/ethereum/ethaskell/src/Rpc/CURL_TEST.txt",
		"/home/jonathan/ethereum/ethaskell/ETHaskell.cabal",
		"/C/Users/Jonathan Thaler/coding/ethaskell/src/Rpc/Utils.hs",
		"/C/Users/Jonathan Thaler/coding/ethaskell/src/Rpc/CURL_TEST.txt",
		"/C/Users/Jonathan Thaler/coding/ethaskell/src/p2p/Server.hs",
		"/C/Users/Jonathan Thaler/coding/ethaskell/src/Rpc/Server.hs",
		"/C/Users/Jonathan Thaler/coding/ethaskell/src/p2p/P2P.hs",
		"/C/Users/Jonathan Thaler/coding/ethaskell/src/Rpc/Methods.hs",
		"/C/Users/Jonathan Thaler/coding/ethaskell/src/Rpc/Json.hs",
		"/C/Users/Jonathan Thaler/coding/ethaskell/src/Rpc/JsonRpc.hs",
		"/C/Users/Jonathan Thaler/coding/ethaskell/src/    Variable not in scope",
		"/C/Users/Jonathan Thaler/coding/ethaskell/src/EthJsonRpc/Utils.hs",
		"/C/Users/Jonathan Thaler/coding/ethaskell/src/EthJsonRpc/Methods.hs",
		"/C/Users/Jonathan Thaler/coding/ethaskell/ETHaskell.cabal",
		"/C/Users/Jonathan Thaler/coding/ethaskell/src/    Parse error in pattern",
		"/C/Users/Jonathan Thaler/coding/ethaskell/src/EthJsonRpc/JsonRpc.hs",
		"/C/Users/Jonathan Thaler/coding/ethaskell/src/EthJsonRpc/Server.hs",
		"/C/Users/Jonathan Thaler/coding/ethaskell/src/                             imported from `Prelude' at EthJsonRpc/Server.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/examples/DoubleAuction/DAModel.hs",
		"/C/Users/Jonathan Thaler/coding/ethaskell/src/Devp2p/Devp2p.hs",
		"/C/Users/Jonathan Thaler/coding/ethaskell/src/jsonrpc/JSONRpc.hs",
		"/C/Users/Jonathan Thaler/coding/ethaskell/src/EthJsonRpc/EthJsonRpc.hs",
		"/C/Users/Jonathan Thaler/coding/ethaskell/TODO.txt",
		"/C/Users/Jonathan Thaler/coding/ethaskell/src/Main.hs",
		"/C/Users/Jonathan Thaler/coding/ETHaskell/ETHaskell.cabal",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/examples/Main.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/FrABS/Simulation/Simulation.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/examples/AgentZero/AgentZeroRun.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/examples/DoubleAuction/DARun.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/examples/SugarScape/SugarScapeRun.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/examples/Agent 1",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/examples/received AskOfferings from 1",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/examples/received AskOfferings from 2",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/examples/Agent received BidOfferings from 1",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/FrABS/Agent/Agent.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/examples/DoubleAuction/DAAuctioneer.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/examples/AgentZero/AgentZeroAgent.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/examples/SIRS/SIRSModel.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/examples/SugarScape/SugarScapeAgent.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/examples/DoubleAuction/DATrader.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/FrABS/Simulation/ParIteration.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/Main.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/Segregation/SegregationModel.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/Segregation/SegregationRun.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/RecursiveABS/RecursiveABSModel.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/RecursiveABS/RecursiveABSInit.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/SugarScape/SugarScapeModel.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/SugarScape/SugarScapeAgent.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/Conversation/ConversationModel.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/SIRS/SIRSModel.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/Segregation/SegregationInit.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/MetaABS/MetaABSModel.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/MetaABS/MetaABSInit.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/Conversation/ConversationInit.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/MessageSampling/MessageSamplingInit.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/MessageSampling/MessageSamplingModel.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/    Not in scope",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/FrABS/Env/Environment.hs"
	],
	"find":
	{
		"height": 23.0
	},
	"find_in_files":
	{
		"height": 90.0,
		"where_history":
		[
			"C:\\Users\\Jonathan Thaler\\phd\\coding\\libraries\\frABS\\src,*.hs"
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"agentPickRandomMultiple",
			"agentImmunizeAux",
			"isDiseased",
			"cellOccupiedM",
			"filterTargetCell",
			"occupierCombatable",
			"occupierRetaliator",
			"agentCombatMove",
			"filterTargetCell",
			"inheritSugar",
			"changeCellAt",
			"createNewBorn",
			"neighbourIds",
			"conversation",
			"isFertile",
			"ifelsem",
			"when",
			"neighbourNodes",
			"foldM",
			"agentCell",
			"unoccu",
			"sirsAgentBehaviourFuncM",
			"onmessage",
			"todo",
			"updatedomainStateFieldM",
			"domainStateM",
			"updateStateM",
			"PDAgentOut",
			"updateState",
			"onMessage",
			"sirsAgentBehaviourFuncM",
			"burndown",
			"sirsCoord",
			"hasmess",
			"drawBoolWithProbFromAgent",
			"runSeqSF",
			"runSeqInternal",
			"internal",
			"calculate",
			"distance",
			"cellsAround",
			"renderCircles",
			"renderFrame",
			"dt ",
			"nvironment",
			"WildfireEnvironment",
			"WildfireAgentOut",
			"WildfireAgentIn",
			"WildfireAgentDef",
			"sirsAgentBehaviourFuncM",
			"WildfireAgentState",
			"WildfireAgentIn",
			"WildfireAgentOut",
			"WildfireEnvironment",
			"WildfireMsg",
			"WildfireLinkLabel",
			"WildfireCell",
			"kill",
			"AgentZeroAgentOut",
			"AgentZeroAgentIn",
			"AgentZeroEnvironment",
			"extractParam",
			"decodeUnformattedData",
			"alphaNumToHex",
			"-------------------------------------------------------------------------------------------",
			"contactInfected",
			"onMessage",
			"randomCellWithRadius",
			"runrandom",
			"rand",
			"random",
			"agentNonCombatMove",
			"inheritSugar",
			"agentCultureContact",
			"agentSex",
			"polute",
			"agentPoluteCell",
			"unoccupyPosition",
			"agentCell",
			"agentPolutingCell",
			"moveAndHarvestBestCell",
			"agentStayAndHarvest",
			"agentMetabolism",
			"agentLookout",
			"combatReward",
			"unoccupyPosition",
			"agentAgeing",
			"unoccupyPosition",
			"agentAgeing",
			"agentAction",
			"agentMoveAndHarvestCell",
			"agentPickRandom",
			"selectBestCells",
			"refCoord",
			"selectBestCells",
			"randomAgentIO",
			"cellOccupier",
			"SugarScapeAgentState",
			"createCells",
			"SugarScapeEnvCellOccupier",
			"cellOccupier",
			"filter",
			"filter (",
			"cellUnoccupied",
			"agentLookout",
			"agentCollecting",
			"cellUnoccupied",
			"agentLookout",
			"^(.*)$",
			"neighbourIds",
			"replace",
			"randomage",
			"handleCreateAgents",
			"handleKillOrLiveAgent",
			"handleAgent",
			"createAgent",
			"handleCreateAgents",
			"#",
			"handleCreateAgents"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": true,
		"replace_history":
		[
			"agentCellOnPos",
			"updateDomainStateM",
			"domainStateFieldM",
			"updateDomainStateM",
			"updateDomainState",
			"distanceManhattan",
			"Environment",
			"nvironment ec l ",
			"AgentOut s m ec l",
			"AgentIn s m ec l",
			"AgentDef s m ec l",
			"PDAgentState",
			"PDAgentIn",
			"PDAgentOut",
			"PDEnvironment",
			"PDMsg",
			"PDLinkLabel",
			"PDCell",
			"WildfireAgentOut",
			"WildfireAgentIn",
			"WildfireEnvironment",
			"hexLitToInt",
			"-------------------------------------------------------------------------------"
		],
		"reverse": false,
		"show_context": false,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 0,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "src/FrABS/Agent/Agent.hs",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 17070,
						"regions":
						{
						},
						"selection":
						[
							[
								2567,
								2567
							]
						],
						"settings":
						{
							"syntax": "Packages/SublimeHaskell/Syntaxes/Haskell-SublimeHaskell.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": -0.0,
						"translation.y": 1485.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 23.0
	},
	"input":
	{
		"height": 34.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.exec":
	{
		"height": 273.0
	},
	"output.find_results":
	{
		"height": 0.0
	},
	"output.sublime_haskell_error_panel":
	{
		"height": 118.0
	},
	"output.sublime_haskell_output_panel":
	{
		"height": 245.0
	},
	"pinned_build_system": "Packages/Haskell/Haskell.sublime-build",
	"project": "frabs.sublime-project",
	"replace":
	{
		"height": 42.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 250.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
