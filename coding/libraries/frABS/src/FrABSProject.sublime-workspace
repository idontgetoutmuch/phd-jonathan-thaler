{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"SugarScapeC",
				"SugarScapeEnvCell \tSugarScape.SugarScapeModel"
			],
			[
				"sugEnv",
				"sugEnvSugarLevel ∷ SugarScapeEnvCell → Double\tSugarScape.SugarScapeModel"
			],
			[
				"sugAgSug",
				"sugAgSugarLevel ∷ SugarScapeAgentState → Double\tSugarScape.SugarScapeModel"
			],
			[
				"Cultur",
				"SugarScapeCulturalTag \tSugarScape.SugarScapeModel"
			]
		]
	},
	"buffers":
	[
		{
			"file": "Main.hs",
			"settings":
			{
				"buffer_size": 1319,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "{-# LANGUAGE Arrows #-}\nmodule SugarScape.SugarScapeAgent where\n\n-- Project-internal import first\nimport SugarScape.SugarScapeModel\nimport SugarScape.SugarScapeEnvironment\nimport FrABS.Env.Environment\nimport FrABS.Agent.Agent\n\n-- Project-specific libraries follow\nimport FRP.Yampa\n\n-- System imports then\nimport Data.Maybe\nimport Data.List\nimport System.Random\nimport Control.Monad.Random\nimport Control.Monad\n\n-- debugging imports finally, to be easily removed in final version\nimport Debug.Trace\n\n------------------------------------------------------------------------------------------------------------------------\n-- Chapter II: Life And Death On The Sugarscape\n------------------------------------------------------------------------------------------------------------------------\nagentDies :: SugarScapeAgentOut -> SugarScapeAgentOut\nagentDies = unoccupyPosition . kill\n\npassWealthOn :: SugarScapeAgentOut -> SugarScapeAgentOut\npassWealthOn a\n    | null childrenIds = a\n    | otherwise = broadcastMessage a (InheritSugar childrenSugarShare) childrenIds\n    where\n        s = aoState a\n        sugarLevel = sugAgSugarLevel s\n\n        childrenIds = sugAgChildren s\n        childrenCount = length childrenIds\n        childrenSugarShare = sugarLevel / (fromRational $ toRational $ fromIntegral childrenCount)\n\nunoccupyPosition ::  SugarScapeAgentOut -> SugarScapeAgentOut\nunoccupyPosition a = a { aoEnv = env' }\n    where\n        (cellCoord, cell) = agentCell a\n        cellUnoccupied = cell { sugEnvOccupier = Nothing }\n        env' = changeCellAt (aoEnv a) cellCoord cellUnoccupied\n\nstarvedToDeath :: SugarScapeAgentOut -> Bool\nstarvedToDeath a = (sugAgSugarLevel $ aoState a) <= 0\n\nagentMetabolism :: SugarScapeAgentOut -> SugarScapeAgentOut\nagentMetabolism a \n    | starvedToDeath a1 = agentDies a1\n    | otherwise = a1\n    where\n        metab = sugAgMetabolism $ aoState a\n        a0 = updateState a (\\s -> s {\n                                sugAgSugarLevel =\n                                    max\n                                        0\n                                        ((sugAgSugarLevel s) - metab)})\n        pol = metab * polutionMetabolismFactor \n        cell = agentCell a0\n        a1 = agentPoluteCell pol cell a0\n\nagentNonCombatMove :: SugarScapeAgentOut -> SugarScapeAgentOut\nagentNonCombatMove a\n    | null unoccupiedCells = agentStayAndHarvest a\n    | otherwise = agentMoveAndHarvestCell a' cellCoord\n    where\n        cellsInSight = agentLookout a\n        unoccupiedCells = filter (cellUnoccupied . snd) cellsInSight\n\n        bestCells = selectBestCells (aoEnvPos a) unoccupiedCells\n        ((cellCoord, _), a') = agentPickRandom a bestCells\n\nagentMoveAndHarvestCell :: SugarScapeAgentOut -> EnvCoord -> SugarScapeAgentOut\nagentMoveAndHarvestCell a cellCoord = a1\n    where\n        a0 = agentHarvestCell a cellCoord\n        a1 = agentMoveTo a0 cellCoord\n\nagentStayAndHarvest :: SugarScapeAgentOut -> SugarScapeAgentOut\nagentStayAndHarvest a = agentHarvestCell a cellCoord\n    where\n        (cellCoord, _) = agentCell a\n\nagentCell :: SugarScapeAgentOut -> (EnvCoord, SugarScapeEnvCell)\nagentCell a = (agentPos, cellOfAgent)\n    where\n        env = aoEnv a\n        agentPos = aoEnvPos a\n        cellOfAgent = cellAt env agentPos\n\nagentPoluteCell :: Double -> (EnvCoord, SugarScapeEnvCell) -> SugarScapeAgentOut -> SugarScapeAgentOut\nagentPoluteCell polutionIncrease (cellCoord, cell) a \n    | polutionEnabled = a { aoEnv = env }\n    | otherwise = a\n    where\n        cellAfterPolution = cell {\n            sugEnvPolutionLevel = polutionIncrease + (sugEnvPolutionLevel cell)\n        }\n        env = changeCellAt (aoEnv a) cellCoord cellAfterPolution\n\nagentHarvestCell  :: SugarScapeAgentOut -> EnvCoord -> SugarScapeAgentOut\nagentHarvestCell a cellCoord = a2\n    where\n        cell = cellAt (aoEnv a) cellCoord\n\n        sugarLevelCell = sugEnvSugarLevel cell\n        sugarLevelAgent = sugAgSugarLevel $ aoState a\n        newSugarLevelAgent = (sugarLevelCell + sugarLevelAgent)\n\n        a0 = updateState a (\\s -> s { sugAgSugarLevel = newSugarLevelAgent })\n\n        cellHarvested = cell { sugEnvSugarLevel = 0.0 }\n        env = changeCellAt (aoEnv a0) cellCoord cellHarvested\n        a1 = a0 { aoEnv = env }\n\n        pol = sugarLevelCell * polutionHarvestFactor \n        a2 = agentPoluteCell pol (cellCoord, cellHarvested) a1\n\nagentMoveTo :: SugarScapeAgentOut -> EnvCoord -> SugarScapeAgentOut\nagentMoveTo a cellCoord = a0 { aoEnvPos = cellCoord, aoEnv = env }\n    where\n        a0 = unoccupyPosition a\n        cell = cellAt (aoEnv a0) cellCoord\n        cellOccupied = cell { sugEnvOccupier = Just (cellOccupier (aoId a0) (aoState a0))}\n        env = changeCellAt (aoEnv a0) cellCoord cellOccupied\n\nselectBestCells :: EnvCoord -> [(EnvCoord, SugarScapeEnvCell)] -> [(EnvCoord, SugarScapeEnvCell)]\nselectBestCells refCoord cs = bestShortestDistanceCells\n    where\n        measureFunc = bestMeasureSugarLevel\n\n        cellsSortedByMeasure = sortBy (\\c1 c2 -> compare (measureFunc $ snd c2) (measureFunc $ snd c1)) cs\n        bestCellMeasure = measureFunc $ snd $ head cellsSortedByMeasure\n        bestCells = filter ((==bestCellMeasure) . measureFunc . snd) cellsSortedByMeasure\n\n        shortestDistanceBestCells = sortBy (\\c1 c2 -> compare (distance refCoord (fst c1)) (distance refCoord (fst c2))) bestCells\n        shortestDistance = distance refCoord (fst $ head shortestDistanceBestCells)\n        bestShortestDistanceCells = filter ((==shortestDistance) . (distance refCoord) . fst) shortestDistanceBestCells\n\n        bestMeasureSugarLevel :: SugarScapeEnvCell -> Double\n        bestMeasureSugarLevel c = sugEnvSugarLevel c\n\n        bestMeasureSugarPolutionRatio :: SugarScapeEnvCell -> Double\n        bestMeasureSugarPolutionRatio c = sugLvl / (1 + polLvl)\n            where\n                sugLvl = sugEnvSugarLevel c\n                polLvl = sugEnvPolutionLevel c\n\nagentLookout :: SugarScapeAgentOut -> [(EnvCoord, SugarScapeEnvCell)]\nagentLookout a = zip visionCoordsWrapped visionCells\n    where\n        env = aoEnv a\n        aPos = aoEnvPos a\n        n = envNeighbourhood env\n        vis = sugAgVision $ aoState a\n\n        -- TODO: put this logic into environment.hs\n        visionCoordsDeltas = foldr (\\v acc -> acc ++ (neighbourhoodScale n v)) [] [1 .. vis]\n        visionCoords = neighbourhoodOf aPos visionCoordsDeltas\n        visionCoordsWrapped = wrapCells (envLimits env) (envWrapping env) visionCoords\n        visionCells = cellsAt env visionCoordsWrapped\n\nagentAgeing :: Double -> SugarScapeAgentOut -> SugarScapeAgentOut\nagentAgeing newAge a\n    | dieFromAge a = agentDies $ passWealthOn a' -- $ birthNewAgent a\n    | otherwise = a'\n    where\n        a' = updateState a (\\s -> s { sugAgAge = newAge })\n\nbirthNewAgent :: SugarScapeAgentOut -> SugarScapeAgentOut\nbirthNewAgent a = createAgent a1 newAgentDef\n    where\n        newAgentId = aoId a                                 -- NOTE: we keep the old id\n        (newAgentCoord, a0) = findUnoccpiedRandomPosition a\n        (newAgentDef, a1) = runAgentRandom a0\n            (randomAgent (newAgentId, newAgentCoord) sugarScapeAgentBehaviour sugarScapeAgentConversation)\n\n        findUnoccpiedRandomPosition :: SugarScapeAgentOut -> (EnvCoord, SugarScapeAgentOut)\n        findUnoccpiedRandomPosition a\n            | cellOccupied c = findUnoccpiedRandomPosition a'\n            | otherwise = (coord, a')\n            where\n                ((c, coord), a') = runAgentRandom a (randomCell (aoEnv a))\n                \ndieFromAge :: SugarScapeAgentOut -> Bool\ndieFromAge a = age > maxAge\n    where\n        s = aoState a\n        age = sugAgAge s\n        maxAge = sugAgMaxAge s\n------------------------------------------------------------------------------------------------------------------------\n\n------------------------------------------------------------------------------------------------------------------------\n-- CHAPTER III: Sex, Culture, And Conflict: The Emergence Of History\n------------------------------------------------------------------------------------------------------------------------\nagentSex :: SugarScapeAgentOut -> SugarScapeAgentOut\nagentSex a\n    | isFertile s = agentMatingConversation nids nncsUnoccupied a\n    | otherwise = a\n    where\n        s = aoState a\n        pos = aoEnvPos a\n        env = aoEnv a\n\n        neighbourCells = neighbours env pos\n        nids = neighbourIds a\n\n        -- NOTE: this calculates the cells which are in the initial neighbourhood and in the neighbourhood of all the neighbours\n        nncsDupl = foldr (\\(coord, _) acc -> (neighbours env coord) ++ acc) neighbourCells neighbourCells\n        -- NOTE: the nncs are not unique, remove duplicates\n        nncsUnique = nubBy (\\(coord1, _) (coord2, _) -> (coord1 == coord2)) nncsDupl\n        nncsUnoccupied = filter (isNothing . sugEnvOccupier . snd) nncsUnique\n\n        agentMatingConversation :: [AgentId]\n                                        -> [(EnvCoord, SugarScapeEnvCell)]\n                                        -> SugarScapeAgentOut\n                                        -> SugarScapeAgentOut\n        agentMatingConversation [] _ a = conversationEnd a\n        agentMatingConversation _ [] a = conversationEnd a\n        agentMatingConversation (receiverId:otherAis) allCoords@((coord, cell):cs) a\n            | satisfiesWealthForChildBearing s = conversation a (receiverId, m) agentMatingConversationsReply\n            | otherwise = conversationEnd a\n            where\n                s = aoState a\n                m =  MatingRequest (sugAgGender $ s) --trace (\"MatingRequest to \" ++ (show receiverId)) MatingRequest (sugAgGender $ s)\n\n                agentMatingConversationsReply :: SugarScapeAgentOut\n                                                    -> Maybe (AgentMessage SugarScapeMsg)\n                                                    -> SugarScapeAgentOut\n                agentMatingConversationsReply a Nothing = agentMatingConversation otherAis allCoords a  -- NOTE: the target was not found or does not have a handler, continue with the next\n                agentMatingConversationsReply a (Just (_, MatingReplyNo)) = agentMatingConversation otherAis allCoords a\n                agentMatingConversationsReply a (Just (senderId, (MatingReplyYes otherTup))) = \n                    conversation a3 (receiverId, (MatingChild newBornId)) (\\a' _ -> agentMatingConversation otherAis cs a')\n                    \n                    where\n                        s = aoState a\n                        initialSugarEndow = sugAgSugarInit s\n                        sugarLevel = sugAgSugarLevel s\n\n                        mySugarContribution = initialSugarEndow / 2.0\n                        myMetab = sugAgMetabolism s\n                        myVision = sugAgVision s\n                        myCulturalTag = sugAgCulturalTag s\n\n                        newBornId = senderId * aoId a   -- TODO: this is a real problem: which ids do we give our newborns?\n\n                        (newBornDef, a0) = runAgentRandom a\n                            (createNewBorn \n                                (newBornId, coord)\n                                (mySugarContribution, myMetab, myVision, myCulturalTag)\n                                otherTup)\n\n                        env = aoEnv a0\n                        cell' = cell { sugEnvOccupier = Just (cellOccupier newBornId (adState newBornDef))}\n                        env' = changeCellAt env coord cell'\n\n                        a1 = a0 { aoEnv = env' }\n                        a2 = updateState a1 (\\s -> s { sugAgSugarLevel = sugarLevel - mySugarContribution,\n                                                        sugAgChildren = newBornId : (sugAgChildren s)})\n                        a3 = createAgent a2 newBornDef\n\n                agentMatingConversationsReply a (Just (_, _)) = agentMatingConversation otherAis allCoords a  -- NOTE: unexpected reply, continue with the next\n\ncreateNewBorn :: (AgentId, EnvCoord)\n                    -> (Double, Double, Int, SugarScapeCulturalTag)\n                    -> (Double, Double, Int, SugarScapeCulturalTag)\n                    -> Rand StdGen SugarScapeAgentDef\ncreateNewBorn idCoord\n                (sugEndowFather, metabFather, visionFather, cultureFather)\n                (sugEndowMother, metabMother, visionMother, cultureMother) =\n    do\n        newBornMetabolism <- crossover (metabFather, metabMother)\n        newBornVision <- crossover (visionFather, visionMother)\n        newBornCulturalTag <- culturalCrossover cultureFather cultureMother\n\n        let newBornSugarEndow = sugEndowFather + sugEndowMother\n\n        newBornDef <- randomAgent\n                            idCoord\n                            sugarScapeAgentBehaviour\n                            sugarScapeAgentConversation\n\n        let newBornState' = (adState newBornDef) { sugAgMetabolism = newBornMetabolism,\n                                                   sugAgVision = newBornVision,\n                                                   sugAgSugarInit = newBornSugarEndow,\n                                                   sugAgCulturalTag = newBornCulturalTag,\n                                                   sugAgTribe = calculateTribe newBornCulturalTag }\n\n        return newBornDef { adState = newBornState' }\n\nsatisfiesWealthForChildBearing :: SugarScapeAgentState -> Bool\nsatisfiesWealthForChildBearing s = currSugar >= initSugar\n    where\n        currSugar = sugAgSugarLevel s\n        initSugar = sugAgSugarInit s\n\nisFertile :: SugarScapeAgentState -> Bool\nisFertile s = withinRange age fertilityAgeRange\n    where\n        age = sugAgAge s\n        fertilityAgeRange = sugAgFertAgeRange s\n\nwithinRange :: (Ord a) => a -> (a, a) -> Bool\nwithinRange a (l, u) = a >= l && a <= u\n\ninheritSugar :: SugarScapeAgentIn -> SugarScapeAgentOut -> SugarScapeAgentOut\ninheritSugar ain a = onMessage inheritSugarMatch ain inheritSugarAction a\n    where\n        inheritSugarAction :: SugarScapeAgentOut -> AgentMessage SugarScapeMsg -> SugarScapeAgentOut\n        inheritSugarAction a (_, (InheritSugar sug)) = updateState a (\\s -> s { sugAgSugarLevel = (sugAgSugarLevel s) + sug})\n\n        inheritSugarMatch :: AgentMessage SugarScapeMsg -> Bool\n        inheritSugarMatch (_, InheritSugar _) = True\n        inheritSugarMatch _ = False\n\nagentCultureContact :: SugarScapeAgentIn -> SugarScapeAgentOut -> SugarScapeAgentOut\nagentCultureContact ain a = broadcastMessage a' (CulturalContact culturalTag) nids \n    where\n        a' = onMessage cultureContactMatch ain cultureContactAction a\n        nids = neighbourIds a'\n        culturalTag = sugAgCulturalTag $ aoState a'\n\n        cultureContactMatch :: AgentMessage SugarScapeMsg -> Bool\n        cultureContactMatch (_, CulturalContact _) = True\n        cultureContactMatch _ = False\n\n        cultureContactAction :: SugarScapeAgentOut -> AgentMessage SugarScapeMsg -> SugarScapeAgentOut\n        cultureContactAction a (_, (CulturalContact tagActive)) = \n                updateState a' (\\s -> s { sugAgCulturalTag = agentTag',\n                                            sugAgTribe = tribe})\n            where\n                s = aoState a\n                agentTag = sugAgCulturalTag s\n                (agentTag', a') = runAgentRandom a (cultureContact tagActive agentTag)\n                tribe = calculateTribe agentTag'\n\nagentKilledInCombat :: SugarScapeAgentIn -> SugarScapeAgentOut -> SugarScapeAgentOut\nagentKilledInCombat ain a = onMessage killedInCombatMatch ain killedInCombatAction a\n    where\n        killedInCombatAction :: SugarScapeAgentOut -> AgentMessage SugarScapeMsg -> SugarScapeAgentOut\n        killedInCombatAction a (_, KilledInCombat) = kill a -- NOTE: don't unoccupie position (as in agentdies) because it is occupied by the killer already\n\n        killedInCombatMatch :: AgentMessage SugarScapeMsg -> Bool\n        killedInCombatMatch (_, KilledInCombat) = True\n        killedInCombatMatch _ = False\n\nagentCombatMove :: SugarScapeAgentOut -> SugarScapeAgentOut\nagentCombatMove a \n    | null targetCells = agentStayAndHarvest a\n    | otherwise = if vulnerableToRetaliation payoff a' then agentStayAndHarvest a' else moveAndHarvestBestCell bestCell a'\n    where\n        s = aoState a\n        agentPos = aoEnvPos a\n        myTribe = sugAgTribe s\n        myWealth = sugAgSugarLevel s \n\n        cellsInSight = agentLookout a\n        targetCells = filter (filterTargetCell occupierCombatable) cellsInSight\n        targeCellsWithPayoff = map cellPayoff targetCells\n\n        cellsSortedByPayoff = sortBy (\\c1 c2 -> compare (snd c2) (snd c1)) targeCellsWithPayoff\n        bestCellPayoff = snd $ head cellsSortedByPayoff\n        bestCells = filter ((==bestCellPayoff) . snd) cellsSortedByPayoff\n\n        shortestDistanceBestCells = sortBy (\\c1 c2 -> compare (distance agentPos (fst . fst $ c1)) (distance agentPos (fst . fst $ c2))) bestCells\n        shortestDistance = distance agentPos (fst . fst $ head shortestDistanceBestCells)\n        bestShortestDistanceCells = filter ((==shortestDistance) . (distance agentPos) . fst . fst) shortestDistanceBestCells\n\n        (bestCell@((_,_), payoff), a') = agentPickRandom a bestShortestDistanceCells\n        \n        -- NOTE: calculate if retalion is possible: is there an agent of the other tribe in my vision which is wealthier AFTER i have preyed on the current one?\n        -- TODO: this is not very well specified in the SugarScape book. we don't know the vision of the other agent, and its information we should not have access to\n        vulnerableToRetaliation :: Double -> SugarScapeAgentOut -> Bool\n        vulnerableToRetaliation payoff a = (not . null) retaliatingCells\n            where\n                sugarLevelAgent = sugAgSugarLevel $ aoState a\n                futureSugarLevel = (payoff + sugarLevelAgent)\n\n                cellsInSight = agentLookout a\n                retaliatingCells = filter (filterTargetCell (occupierRetaliator futureSugarLevel)) cellsInSight\n\n        moveAndHarvestBestCell :: ((EnvCoord, SugarScapeEnvCell), Double) -> SugarScapeAgentOut -> SugarScapeAgentOut\n        moveAndHarvestBestCell ((cellCoord, cell), payoff) a \n            | cellOccupied cell = killOccupierOfCell a'' cell\n            | otherwise = a''\n                where\n                    sugarLevelAgent = sugAgSugarLevel $ aoState a\n                    newSugarLevelAgent = (payoff + sugarLevelAgent)\n\n                    a' = unoccupyPosition $ updateState a (\\s -> s { sugAgSugarLevel = newSugarLevelAgent })\n\n                    cellHarvestedAndOccupied = cell {\n                            sugEnvSugarLevel = 0.0,\n                            sugEnvOccupier = Just (cellOccupier (aoId a') (aoState a')),\n                            sugEnvPolutionLevel = 0\n                    }\n                            \n                    env = changeCellAt (aoEnv a') cellCoord cellHarvestedAndOccupied\n                    a'' = a' { aoEnvPos = cellCoord, aoEnv = env }\n\n        killOccupierOfCell :: SugarScapeAgentOut -> SugarScapeEnvCell -> SugarScapeAgentOut\n        killOccupierOfCell a cell = sendMessage a (occupierId, KilledInCombat)\n            where\n                occupier = fromJust $ sugEnvOccupier cell\n                occupierId = sugEnvOccId occupier \n\n        filterTargetCell :: (SugarScapeEnvCellOccupier -> Bool) -> (EnvCoord, SugarScapeEnvCell) -> Bool\n        filterTargetCell f (coord, cell) = maybe True f mayOccupier\n            where\n                mayOccupier = sugEnvOccupier cell\n\n        occupierCombatable :: SugarScapeEnvCellOccupier -> Bool\n        occupierCombatable occupier = differentTribe && lessWealthy\n            where\n                otherTribe = sugEnvOccTribe occupier\n                otherWealth = sugEnvOccWealth occupier\n                differentTribe = otherTribe /= myTribe\n                lessWealthy = otherWealth <myWealth \n\n        occupierRetaliator :: Double -> SugarScapeEnvCellOccupier -> Bool\n        occupierRetaliator referenceWealth occupier = differentTribe && moreWealthy\n            where\n                otherTribe = sugEnvOccTribe occupier\n                otherWealth = sugEnvOccWealth occupier\n                differentTribe = otherTribe /= myTribe\n                moreWealthy = otherWealth > referenceWealth \n\n        cellPayoff :: (EnvCoord, SugarScapeEnvCell) -> ((EnvCoord, SugarScapeEnvCell), Double)\n        cellPayoff (c, cell) = ((c, cell), payoff)\n            where\n                mayOccupier = sugEnvOccupier cell\n                sugarLevel = sugEnvSugarLevel cell\n                payoff = maybe sugarLevel (\\occupier -> sugarLevel + (min combatReward (sugEnvOccWealth occupier))) mayOccupier\n------------------------------------------------------------------------------------------------------------------------\n\n------------------------------------------------------------------------------------------------------------------------\n-- GENERAL AGENT-RELATED\n------------------------------------------------------------------------------------------------------------------------\nsugarScapeAgentConversation :: SugarScapeAgentConversation\nsugarScapeAgentConversation ain (_, (MatingRequest tup)) = (Just m, Just ain')\n    where \n        (m, ain') = handleMatingConversation tup ain\nsugarScapeAgentConversation ain (_, (MatingChild childId)) = (Nothing, Just ain')\n    where\n        s = aiState ain\n        s' = s { sugAgChildren = childId : (sugAgChildren s)}\n        ain' = ain { aiState = s' }\nsugarScapeAgentConversation ain _ = (Nothing, Nothing)\n\nhandleMatingConversation :: (SugarScapeAgentGender)\n                                -> SugarScapeAgentIn\n                                -> (SugarScapeMsg, SugarScapeAgentIn)\nhandleMatingConversation otherGender ain \n    | isFertile s &&\n        satisfiesWealthForChildBearing s &&\n        differentGender = (MatingReplyYes (mySugarContribution, myMetab, myVision, myCulturalTag), ain')\n    | otherwise = (MatingReplyNo, ain)\n    where\n        s = aiState ain\n        myGender = sugAgGender s\n        differentGender = myGender /= otherGender\n\n        -- NOTE: to be fertile an agent must have at least as much sugar as initially endowed, therefore it cannot go negative\n        initialSugarEndow = sugAgSugarInit s\n        sugarLevel = sugAgSugarLevel s\n        mySugarContribution = initialSugarEndow / 2.0\n        myMetab = sugAgMetabolism s\n        myVision = sugAgVision s\n        myCulturalTag = sugAgCulturalTag s\n        \n        s' = s { sugAgSugarLevel = sugarLevel - mySugarContribution }\n        ain' = ain { aiState = s'}\n\nneighbourIds :: SugarScapeAgentOut -> [AgentId]\nneighbourIds a = map (sugEnvOccId . fromJust . sugEnvOccupier . snd) occupiedCells\n    where\n        env = aoEnv a\n        pos = aoEnvPos a\n        neighbourCells = neighbours env pos\n        occupiedCells = filter (isJust . sugEnvOccupier . snd) neighbourCells\n\nsugarScapeAgentBehaviourFunc :: Double -> SugarScapeAgentIn -> SugarScapeAgentOut -> SugarScapeAgentOut \nsugarScapeAgentBehaviourFunc age ain a = do     \n                                            let a0 = agentKilledInCombat ain a \n                                            if isDead a0 then\n                                                a0\n                                                else\n                                                    do\n                                                        let a1 = agentAgeing age a0\n                                                        if isDead a1 then\n                                                            a1\n                                                            else\n                                                                do\n                                                                    let a2 = agentMetabolism a1\n                                                                    if isDead a2 then\n                                                                        a2\n                                                                        else \n                                                                            do\n                                                                                let a3 = agentNonCombatMove a2\n                                                                                let a4 = inheritSugar ain a3\n                                                                                let a5 = agentCultureContact ain a4\n                                                                                let a6 = agentSex a5\n                                                                                a6\n\n\nsugarScapeAgentBehaviour :: SugarScapeAgentBehaviour\nsugarScapeAgentBehaviour = proc ain ->\n    do\n        age <- time -< 0\n\n        let a = agentOutFromIn ain\n        returnA -< sugarScapeAgentBehaviourFunc age ain a\n\n------------------------------------------------------------------------------------------------------------------------",
			"file": "SugarScape/SugarScapeAgent.hs",
			"file_size": 25471,
			"file_write_time": 131364938020720097,
			"settings":
			{
				"buffer_size": 24948,
				"line_ending": "Windows"
			}
		}
	],
	"build_system": "",
	"build_system_choices":
	[
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 150.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"install",
				"Package Control: Install Package"
			]
		],
		"width": 432.0
	},
	"console":
	{
		"height": 289.0,
		"history":
		[
			"import urllib.request,os; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), 'wb').write(urllib.request.urlopen( 'http://sublime.wbond.net/' + pf.replace(' ','%20')).read())"
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/SugarScape"
	],
	"file_history":
	[
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/FrABS/Agent/Agent.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/SIRS/SIRSModel.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/Segregation/SegregationInit.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/Segregation/SegregationModel.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/MetaABS/MetaABSModel.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/MetaABS/MetaABSInit.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/SugarScape/SugarScapeAgent.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/SugarScape/SugarScapeModel.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/Conversation/ConversationInit.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/Conversation/ConversationModel.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/MessageSampling/MessageSamplingInit.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/MessageSampling/MessageSamplingModel.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/    Not in scope",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/FrABS/Simulation/Simulation.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/FrABS/Env/Environment.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/SugarScape/SugarScapeInit.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/Main.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/    * Variable not in scope",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/    Variable not in scope",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/SugarScape/SugarScapeRun.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/frABS.cabal",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/SugarScape/SugarScapeEnvironment.hs",
		"/C/Users/Jonathan Thaler/AppData/Roaming/Sublime Text 3/Packages/User/SublimeHaskell.sublime-settings",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/SugarScape/SugarScapeRenderer.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/MessageSampling/MessageSamplingRun.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/Conversation/ConversationRun.hs",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/FrABSProject.sublime-project",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/    Illegal datatype context (use DatatypeContexts)",
		"/C/Users/Jonathan Thaler/phd/coding/libraries/frABS/src/FrABS/Simulation/Utils.hs",
		"/C/Users/Jonathan Thaler/Desktop/test"
	],
	"find":
	{
		"height": 34.0
	},
	"find_in_files":
	{
		"height": 90.0,
		"where_history":
		[
			"C:\\Users\\Jonathan Thaler\\phd\\coding\\libraries\\frABS\\src,*.hs"
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"randomCellWithRadius",
			"runrandom",
			"rand",
			"random",
			"agentNonCombatMove",
			"inheritSugar",
			"agentCultureContact",
			"agentSex",
			"polute",
			"agentPoluteCell",
			"unoccupyPosition",
			"agentCell",
			"agentPolutingCell",
			"moveAndHarvestBestCell",
			"agentStayAndHarvest",
			"agentMetabolism",
			"agentLookout",
			"combatReward",
			"unoccupyPosition",
			"agentAgeing",
			"unoccupyPosition",
			"agentAgeing",
			"agentAction",
			"agentMoveAndHarvestCell",
			"agentPickRandom",
			"selectBestCells",
			"refCoord",
			"selectBestCells",
			"randomAgentIO",
			"cellOccupier",
			"SugarScapeAgentState",
			"createCells",
			"SugarScapeEnvCellOccupier",
			"cellOccupier",
			"filter",
			"filter (",
			"cellUnoccupied",
			"agentLookout",
			"agentCollecting",
			"cellUnoccupied",
			"agentLookout",
			"^(.*)$",
			"neighbourIds",
			"replace",
			"randomage",
			"handleCreateAgents",
			"handleKillOrLiveAgent",
			"handleAgent",
			"createAgent",
			"handleCreateAgents",
			"#",
			"handleCreateAgents"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": true,
		"replace_history":
		[
		],
		"reverse": false,
		"show_context": false,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 1,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "Main.hs",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1319,
						"regions":
						{
						},
						"selection":
						[
							[
								223,
								223
							]
						],
						"settings":
						{
							"syntax": "Packages/SublimeHaskell/Syntaxes/Haskell-SublimeHaskell.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "SugarScape/SugarScapeAgent.hs",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 24948,
						"regions":
						{
						},
						"selection":
						[
							[
								6504,
								6504
							]
						],
						"settings":
						{
							"syntax": "Packages/SublimeHaskell/Syntaxes/Haskell-SublimeHaskell.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": -0.0,
						"translation.y": 9180.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 26.0
	},
	"input":
	{
		"height": 34.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.exec":
	{
		"height": 223.0
	},
	"output.find_results":
	{
		"height": 0.0
	},
	"output.sublime_haskell_error_panel":
	{
		"height": 118.0
	},
	"output.sublime_haskell_output_panel":
	{
		"height": 0.0
	},
	"pinned_build_system": "Packages/Haskell/Haskell.sublime-build",
	"project": "FrABSProject.sublime-project",
	"replace":
	{
		"height": 48.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 250.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
