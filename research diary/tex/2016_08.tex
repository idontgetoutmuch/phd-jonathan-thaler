\section*{2016 August 8th}
First entry of research diary is a retrospective how I got to study a PhD at Nottingham. Due to the length of it I placed it in the appendices as Appendix \ref{app:studentship}. Note that the next entry (10th) will give a short overview of the topic as it was at that point (10th).

\section*{2016 August 10th}
\subsection*{Where do I stand now}
On 21st June I had the opportunity to give a Phd-Seminar presenting my research ideas within 45mins + 15min discussion. This gave me the opportunity to make up my mind about the ideas I want to follow and which ones I want to reject. Also to better shape my ideas and to give a clear overview of them I started to write down a research proposal about 3 months ago. Of course this proposal is always changing and will continue to do so during the 1st semester as according to my supervisor the 1st semester is reserved to get started and to really carve out the research ideas and most important of all the research questions. So this is a still ongoing process but to give an overview where I stand NOW regarding the research direction I have will cite here the abstract of my research proposal which I have recently reworked (again) and which pretty well sums up the overall ideas and directions I want to follow:

\begin{quote}
Agent-Based Modeling and Simulation (ABM/S) is still a young discipline and the dominant approach to it is object oriented computation. This thesis goes into the opposite direction and asks how ABM/S can be mapped to and implemented using pure functional computation and what one gains from doing so. To the best knowledge of the author, so far no proper treatment of ABM/S in pure functional computation exists but only a few papers which only scratch the surface. The author argues that approaching ABM/S from a pure functional direction  offers a wealth of new powerful tools and methods. The most obvious one is that when using pure functional computation (equational) resoning about the correctness and about total and partial correctness of the simulation becomes possible. The ultimate benefit is that Agda becomes applicable which is both a pure functional programming language and a proof assistant allowing both to compute the dynamics of the simulation and to look at meta-level properties of the simulation - termination, convergence, equilibria, domain specific properties - by constructing proofs utilizing computer aided verification. \\
To map ABM/S to pure functional computation the idea is to apply both Robin Milner's PI-calculus and category theory. The PI-calculus will be used for a formal modelling of the problem and allows already a basic form of algebraic reasoning. Then the agents and the process of the agent-simulation will be mapped to category theory because pure functional programming approaches complex problems from the direction of category theory in the form of monadic programming. \\
The application will be in the field of agent-based computational economics where the approach will be to take an established model/theory and then apply the above mentioned methods to it and to show that using them will lead to the same results. 
\end{quote}

Note that the goal is not to establish new economic theories but to provide methods and tools for deeper insight and verification in the context of agent-based computational economics - this is after all still a thesis purely rooted in computer science.

\subsection*{PhD Roadmap Semesters}
\begin{enumerate}
\item Semester: Literature research \& research questions. Topics: 
	\begin{itemize}
	\item Functional computation \& programming: Agda, Haskell \& monads, category theory, type-systems, computer aided formal verification 
	\item Formal ABM/S: pi-calculus, various formal agent-types
	\item Finding application in agent-based computational economics: auction theory \& auction types, market design
	\end{itemize}
\item Semester: First publication: ? (Mapping auction types and ABM/S to category theory)
\item Semester: Second publication: ? (formalization of ABM/S and auction types in pi-calculus )
\item Semester: Simulation Framework, Finished Simulation framework implementation: basic framework with correctness \& proofs 
\item Semester: Third publication: ABM/S in Agda
\item Semester: Finalizing PhD - Writing final thesis combining all research \& results.
\end{enumerate}

\subsection*{Discussions with my Supervisors}
\begin{itemize}
\item So far the proposed ideas are a huge amount for 3 years and I doubt it is realistic to do in 3 years. Also it is yet totally unclear whether it makes sense/is possible to map ZI-Agents and the auction-types to category theory AND write specifications in pi-calculus for both. Maybe only one of them is really necessary or maybe only part of each? This is to be discussed with my supervisors.
\item Does it even make sense to study these auction-types with these types of agents? To look only at the dynamics? Is computational economics interested in these dynamics of the equilibrium processes? I really need to look into theoretical work on the various auction-types AND the computational economics approach to them.
\item Do we really need the pi-calculus when we have category-theory and vice versa? Does not just one method suffice? Or is there a mapping between both methods / a connection?
\end{itemize}

\section*{August 2016 11th}
\subsection*{Paper: Dependently-typed programming in scientific computing \cite{Ionescu2013}}
The authors give a short and nice introduction into the very basics of what economics is and what it tries to achieve: exchange of goods. They then go on and explain allocation and endowment and explain walrasian equilibrium and then use Agda for constructing fundamental economic proofs about Pareto Efficiency, Walrasian Equilibrium. Remarkable is their criticism of the equilibrium models:

\begin{quote}
A general criticism of all these models is that they neglect the dynamical
aspect of reaching the equilibrium situation. There is no known plausible mechanism
which explains exactly how equilibrium prices can arise in practice. Walras'
own proposal for such a price-formation mechanism involved an auctioneer. This
is a central entity who can see all supply-demand imbalances and adjust prices
accordingly, raising the prices of goods for which there is too great demand, and
lowering those for which there is too little, in an iterative process. Even if one
accepts that in some situations one could have an authority that might act as
auctioneer, there is no general proof that the iterative process will eventually
converge.
\end{quote}

This is insofar remarkable as this is exactly the direction I want to head to and which was also the work of the Leverage-Cycle project in which I've written my Masterthesis: \textbf{compute (by simulation) and understand the dynamics of an equilibrium process}. One of the goals of this PhD thesis is to develop a tool in which such equilibrium processes can be modelled and simulated but it is still not clear in which economical context / which theory exactly - this is still an open question I have to deal with. \\

Another interesting point they make in the paper is that:

\begin{quote}
The bad news is that most of these concepts are not constructive. Specifications of programs that take as input agents characterized by preference relations and initial endowments and return a Walrasian (or Nash, or correlated, ...) equilibrium can in general not be fulfilled. Even the so-called computable general equilibrium models are not, in fact, computable.
\end{quote}

I can't yet tell the implication for my thesis but it will be interesting to see whether it has one or not.

\subsection*{Paper: Engineering Proof by Reflection in Agda \cite{vanderWalt2013}}
The authors explain the reflection-mechanics of Agda and discuss how they can be put to use.
In general reflection allows for a kind of meta-programming during both compile- and run-time by accessing and modifying the abstract syntax tree (AST) thus changing the structure and behaviour of the program during compile- and run-time. According to the authors, Proof by Reflection
\begin{quote}
is the method of mechanically constructing a proof of a theorem by inspecting its shape.
\end{quote}

Unfortunately this is paper comes too early as I don't know enough about Agda, intuitionistic logic, type theory and computer aided formal verification. I have to come back to this paper at a later point again.

\subsection*{Paper: Dependent Types at Work \cite{Bove2009}}
According to the authors

\begin{quote}
The aim of these notes is to give a gentle introduction to dependently typed programming for a reader who is familiar with ordinary functional programming, and who has basic knowledge of logic and type systems.
\end{quote}

A few things I will going to clarify after having worked through the paper

\begin{itemize}
\item Dependent Types
\item The Curry-Howard correspondence
\item Totality of Agda programs and Type-normalisation (types must be normal otherwise the type-checking algorithm may not terminate)
\item The connection of Dependent Types to the Curry-Howard correspondence
\end{itemize}

\section*{August 2016 16th}
Been working on \cite{Bove2009} (Dependent Types at Work) which includes Exercises at the end of each subsections which are of great help to better understand the content if one solves them.

\subsection*{Category Theory vs. Pi-Calculus?}
I've been thinking again about the combined application of category theory and pi-calculus in my thesis. Initially I thought that either of them is going to make it into the thesis because just one of them will be useful as a tool for formally expressing the type of agents I want to implement but I think this is wrong. \\
I now think that the pi-calculus will serve as a tool to formally specify the agents and their interactions in a process-calculus way and that I will use category theory for the implementation of the Domain-Specific Language which runs these pi-calculus specifications.
\medskip
It is interesting so see that the more I know and the more I learn the more I can picture and imagine and the clearer the road to my PhD gets.

\subsection*{Foundations of computation}
Since I got in touch with the term of computability and computation I wondered what exactly is meant with it. I would now say that \textit{computation is the manipulation of symbols according to specific rules}. More generally speaking the symbols are letters over an alphabet of a formal language and could be any e.g. the binary system where the symbols are just 0 and 1. \\
What intrigued me was why did the Old Gods (Turing, Church, Gödel) make such a fuss about computing natural numbers? I asked myself why in the world didn't they just use the binary system in which we can represent numbers? \\ The problem was my approach to computable numbers: the Old Gods never thought about the natural numbers in a binary system but in a purely mathematical sense defined by peano: the peano numbers. Those are inductively defined as being successors of the initial number zero. Thus 1 is successor of zero, 2 is the successor of the successor of zero and so on. Now they asked how one can perform basic arithmetic operations on such numbers? They asked how one can \textit{compute} the addition, subtraction, division, multiplication of two peano numbers. This led to the invention of Gödel System T, Churchs Lambda Calculus and the Turing Machine. All of them had a different approach to computing the results but were shown to be of equal computational power. \\ 
While working on \cite{Bove2009} (Dependent Types at Work) where the natural numbers were introduced in the style of peano it became clear for me that I did look at the whole problem from the wrong point of view. Now I better understand the approach of the Old Gods and with what they were struggling with. Still I have to think about how the problem of undeciability relates to these things. \\
What is clear now is that the computation over the natural peano numbers has the alphabet of {zero, succ} where the operations are implemented in the systems mentioned above: The Turing Machine performs the computations in imperative steps by changing a global (infinite) memory and Church and Gödel follow a functional mathematical style using so called primitive recursion.

\section*{August 2016 17th}
As already mentioned in the entry of August 2016 11th, the authors of \cite{Ionescu2013} tell bad news because \enquote{most of the concepts are not constructive}. After thinking about this I have the feeling that this implies that I have to approach my agent-based simulation from a constructive direction: both the agents and the simulation itself have to be \textit{constructive}. It is still not very clear to me what that means but I guess that one can draw parallels to the peano numbers: I think the peano numbers are an inductive \textit{constructive} way of, well... \textit{constructing} the natural numbers and not just postulating their existence - each number has to be computed! We will see whether my intuition is right and how this will apply to ABM/S.